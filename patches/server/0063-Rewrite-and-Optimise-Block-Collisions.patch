From 14b9dae7fd6fdfca88263e15fdd27b2a5ce26b4f Mon Sep 17 00:00:00 2001
From: Samsuik <40902469+Samsuik@users.noreply.github.com>
Date: Sat, 17 Jun 2023 15:47:14 +0100
Subject: [PATCH] Rewrite and Optimise Block Collisions


diff --git a/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java b/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
index c50f3e1c9..a65306dc9 100644
--- a/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
+++ b/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
@@ -378,4 +378,13 @@ public class BlossomConfig {
         activationRangeDelay = Math.max(getInt("mobs.activation-range-delay", 0) + 1, 1);
     }
 
+    public static boolean extendedCollisionSearch;
+    public static boolean useFastBlockCollisions;
+    public static boolean optimisedMovement;
+    private static void RewriteBlockCollisions() {
+        extendedCollisionSearch = getBoolean("tnt.extended-collision-search", false);
+        useFastBlockCollisions = getBoolean("tnt.use-fast-block-collisions", true);
+        optimisedMovement = getBoolean("tnt.optimised-movement", true);
+    }
+
 }
diff --git a/src/main/java/me/samsuik/blossom/utils/SectionChunkCache.java b/src/main/java/me/samsuik/blossom/utils/SectionChunkCache.java
new file mode 100644
index 000000000..6b43d6bd7
--- /dev/null
+++ b/src/main/java/me/samsuik/blossom/utils/SectionChunkCache.java
@@ -0,0 +1,34 @@
+package me.samsuik.blossom.utils;
+
+import net.minecraft.server.*;
+
+public class SectionChunkCache {
+
+    private final Chunk[][] chunks;
+    private final int baseX, baseZ;
+
+    public SectionChunkCache(World world, AxisAlignedBB bb) {
+        int minChunkX = MathHelper.floor(bb.a) >> 4;
+        int minChunkZ = MathHelper.floor(bb.c) >> 4;
+        int maxChunkX = MathHelper.floor(bb.d) >> 4;
+        int maxChunkZ = MathHelper.floor(bb.f) >> 4;
+
+        chunks = new Chunk[maxChunkX - minChunkX + 1][maxChunkZ - minChunkZ + 1];
+
+        baseX = minChunkX;
+        baseZ = minChunkZ;
+
+        for (int chunkX = minChunkX; chunkX <= maxChunkX; ++chunkX) {
+            for (int chunkZ = minChunkZ; chunkZ <= maxChunkZ; ++chunkZ) {
+                chunks[chunkX - baseX][chunkZ - baseZ] = world.getChunkAt(chunkX, chunkZ);
+            }
+        }
+    }
+
+    public IBlockData getType(int x, int y, int z) {
+        Chunk chunk = chunks[(x >> 4) - baseX][(z >> 4) - baseZ];
+        ChunkSection section = chunk.getSections()[y >> 4];
+        return section != null ? section.getType(x & 15, y & 15, z & 15) : Blocks.AIR.getBlockData();
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index 431097ec3..ab5fe46dc 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -93,6 +93,38 @@ public class AxisAlignedBB {
         return new AxisAlignedBB(this.a + d0, this.b + d1, this.c + d2, this.d + d0, this.e + d1, this.f + d2);
     }
 
+    // Blossom start
+    public double collideX(AxisAlignedBB axisalignedbb, double dir) {
+        if (dir > 0.0D && axisalignedbb.d <= a) {
+            return Math.min(a - axisalignedbb.d, dir);
+        } else if (dir < 0.0D && axisalignedbb.a >= d) {
+            return Math.max(d - axisalignedbb.a, dir);
+        } else {
+            return dir;
+        }
+    }
+
+    public double collideY(AxisAlignedBB axisalignedbb, double dir) {
+        if (dir > 0.0D && axisalignedbb.e <= b) {
+            return Math.min(b - axisalignedbb.e, dir);
+        } else if (dir < 0.0D && axisalignedbb.b >= e) {
+            return Math.max(e - axisalignedbb.b, dir);
+        } else {
+            return dir;
+        }
+    }
+
+    public double collideZ(AxisAlignedBB axisalignedbb, double dir) {
+        if (dir > 0.0D && axisalignedbb.f <= c) {
+            return Math.min(c - axisalignedbb.f, dir);
+        } else if (dir < 0.0D && axisalignedbb.c >= f) {
+            return Math.max(f - axisalignedbb.c, dir);
+        } else {
+            return dir;
+        }
+    }
+    // Blossom end
+
     public double a(AxisAlignedBB axisalignedbb, double d0) {
         if (axisalignedbb.e > this.b && axisalignedbb.b < this.e && axisalignedbb.f > this.c && axisalignedbb.c < this.f) {
             double d1;
diff --git a/src/main/java/net/minecraft/server/Block.java b/src/main/java/net/minecraft/server/Block.java
index 8efe45ea2..f9d63d580 100644
--- a/src/main/java/net/minecraft/server/Block.java
+++ b/src/main/java/net/minecraft/server/Block.java
@@ -288,6 +288,7 @@ public class Block {
         return this.isTileEntity;
     }
 
+    public final void setBounds(float f, float f1, float f2, float f3, float f4, float f5) { this.a(f, f1, f2, f3, f4, f5); } // Blossom - OBFHELPER
     protected final void a(float f, float f1, float f2, float f3, float f4, float f5) {
         this.minX = (double) f;
         this.minY = (double) f1;
@@ -301,6 +302,23 @@ public class Block {
         return iblockaccess.getType(blockposition).getBlock().getMaterial().isBuildable();
     }
 
+    // Blossom start
+    public void testShape(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        if (iblockdata.isShapeDynamic() || !me.samsuik.blossom.configuration.BlossomConfig.useFastBlockCollisions) {
+            a(world, blockposition, iblockdata, axisalignedbb, list, entity); // fallback
+        } else {
+            List<AxisAlignedBB> shape = iblockdata.shape(); // cached shape
+            //noinspection ForLoopReplaceableByForEach
+            for (int i = 0, len = shape.size(); i < len; i++) {
+                final AxisAlignedBB moved = shape.get(i).c(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                if (axisalignedbb.b(moved)) {
+                    list.add(moved);
+                }
+            }
+        }
+    }
+    // Blossom end
+
     public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
         AxisAlignedBB axisalignedbb1 = this.a(world, blockposition, iblockdata);
 
@@ -310,6 +328,12 @@ public class Block {
 
     }
 
+    // Blossom start
+    public final AxisAlignedBB getBounds() {
+        return new AxisAlignedBB(this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);
+    }
+    // Blossom end
+
     public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
         return new AxisAlignedBB((double) blockposition.getX() + this.minX, (double) blockposition.getY() + this.minY, (double) blockposition.getZ() + this.minZ, (double) blockposition.getX() + this.maxX, (double) blockposition.getY() + this.maxY, (double) blockposition.getZ() + this.maxZ);
     }
@@ -622,6 +646,14 @@ public class Block {
         return vec3d;
     }
 
+    // Blossom start
+    protected boolean dynamicShape() {
+        return false;
+    }
+
+    public void updateShape(IBlockData iblockdata) {}
+    // Blossom end
+
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {}
 
     public final double B() {
@@ -1067,10 +1099,17 @@ public class Block {
                 int i = Block.REGISTRY.b(block13) << 4 | block13.toLegacyData(iblockdata);
                 // TacoSpigot start
 
+                // Blossom start
+                if (iblockdata instanceof BlockStateList.BlockData) {
+                    ((BlockStateList.BlockData) iblockdata).calculateShape();
+                }
+                if (block13.dynamicShape()) {
+                    ((BlockStateList.BlockData) iblockdata).markDynamic();
+                }
+                // Blossom end
                 Block.d.a(iblockdata, i);
             }
         }
-
     }
 
     private static void a(int i, MinecraftKey minecraftkey, Block block) {
diff --git a/src/main/java/net/minecraft/server/BlockAnvil.java b/src/main/java/net/minecraft/server/BlockAnvil.java
index 4707dcc1c..6c45336a4 100644
--- a/src/main/java/net/minecraft/server/BlockAnvil.java
+++ b/src/main/java/net/minecraft/server/BlockAnvil.java
@@ -41,7 +41,12 @@ public class BlockAnvil extends BlockFalling {
     }
 
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
-        EnumDirection enumdirection = (EnumDirection) iblockaccess.getType(blockposition).get(BlockAnvil.FACING);
+        // Blossom start
+        updateShape(iblockaccess.getType(blockposition));
+    }
+    public void updateShape(IBlockData iblockdata) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockAnvil.FACING);
+        // Blossom end
 
         if (enumdirection.k() == EnumDirection.EnumAxis.X) {
             this.a(0.0F, 0.0F, 0.125F, 1.0F, 1.0F, 0.875F);
diff --git a/src/main/java/net/minecraft/server/BlockCake.java b/src/main/java/net/minecraft/server/BlockCake.java
index 4918483ad..4b0382a60 100644
--- a/src/main/java/net/minecraft/server/BlockCake.java
+++ b/src/main/java/net/minecraft/server/BlockCake.java
@@ -13,8 +13,13 @@ public class BlockCake extends Block {
     }
 
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        // Blossom start
+        updateShape(iblockaccess.getType(blockposition));
+    }
+    public void updateShape(IBlockData iblockdata) {
+        // Blossom end
         float f = 0.0625F;
-        float f1 = (float) (1 + ((Integer) iblockaccess.getType(blockposition).get(BlockCake.BITES)).intValue() * 2) / 16.0F;
+        float f1 = (float) (1 + ((Integer) iblockdata.get(BlockCake.BITES)).intValue() * 2) / 16.0F; // Blossom
         float f2 = 0.5F;
 
         this.a(f1, 0.0F, f, 1.0F - f, f2, 1.0F - f);
diff --git a/src/main/java/net/minecraft/server/BlockCocoa.java b/src/main/java/net/minecraft/server/BlockCocoa.java
index c77b648ae..8455d8465 100644
--- a/src/main/java/net/minecraft/server/BlockCocoa.java
+++ b/src/main/java/net/minecraft/server/BlockCocoa.java
@@ -46,12 +46,16 @@ public class BlockCocoa extends BlockDirectional implements IBlockFragilePlantEl
     }
 
     public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        this.updateShape(world, blockposition);
+        // Blossom start
+        this.updateShape(iblockdata);
         return super.a(world, blockposition, iblockdata);
     }
 
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
-        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        updateShape(iblockaccess.getType(blockposition));
+    }
+    public void updateShape(IBlockData iblockdata) {
+        // Blossom end
         EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockCocoa.FACING);
         int i = ((Integer) iblockdata.get(BlockCocoa.AGE)).intValue();
         int j = 4 + i * 2;
diff --git a/src/main/java/net/minecraft/server/BlockDoor.java b/src/main/java/net/minecraft/server/BlockDoor.java
index d33d59bb7..4d5e9b593 100644
--- a/src/main/java/net/minecraft/server/BlockDoor.java
+++ b/src/main/java/net/minecraft/server/BlockDoor.java
@@ -22,6 +22,13 @@ public class BlockDoor extends Block {
         return LocaleI18n.get((this.a() + ".name").replaceAll("tile", "item"));
     }
 
+    // Blossom start
+    @Override
+    protected boolean dynamicShape() {
+        return true;
+    }
+    // Blossom end
+
     public boolean c() {
         return false;
     }
diff --git a/src/main/java/net/minecraft/server/BlockEnderPortalFrame.java b/src/main/java/net/minecraft/server/BlockEnderPortalFrame.java
index 43e1da0ee..1f49d5c17 100644
--- a/src/main/java/net/minecraft/server/BlockEnderPortalFrame.java
+++ b/src/main/java/net/minecraft/server/BlockEnderPortalFrame.java
@@ -25,7 +25,7 @@ public class BlockEnderPortalFrame extends Block {
     public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
         this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.8125F, 1.0F);
         super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
-        if (((Boolean) world.getType(blockposition).get(BlockEnderPortalFrame.EYE)).booleanValue()) {
+        if (((Boolean) iblockdata.get(BlockEnderPortalFrame.EYE)).booleanValue()) { // Blossom
             this.a(0.3125F, 0.8125F, 0.3125F, 0.6875F, 1.0F, 0.6875F);
             super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
         }
diff --git a/src/main/java/net/minecraft/server/BlockFenceGate.java b/src/main/java/net/minecraft/server/BlockFenceGate.java
index c02281293..6e0335ffd 100644
--- a/src/main/java/net/minecraft/server/BlockFenceGate.java
+++ b/src/main/java/net/minecraft/server/BlockFenceGate.java
@@ -37,7 +37,12 @@ public class BlockFenceGate extends BlockDirectional {
     }
 
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
-        EnumDirection.EnumAxis enumdirection_enumaxis = ((EnumDirection) iblockaccess.getType(blockposition).get(BlockFenceGate.FACING)).k();
+        // Blossom start
+        updateShape(iblockaccess.getType(blockposition));
+    }
+    public void updateShape(IBlockData iblockdata) {
+        EnumDirection.EnumAxis enumdirection_enumaxis = ((EnumDirection) iblockdata.get(BlockFenceGate.FACING)).k();
+        // Blossom end
 
         if (enumdirection_enumaxis == EnumDirection.EnumAxis.Z) {
             this.a(0.0F, 0.0F, 0.375F, 1.0F, 1.0F, 0.625F);
diff --git a/src/main/java/net/minecraft/server/BlockLadder.java b/src/main/java/net/minecraft/server/BlockLadder.java
index c12c43bb1..0b452b01f 100644
--- a/src/main/java/net/minecraft/server/BlockLadder.java
+++ b/src/main/java/net/minecraft/server/BlockLadder.java
@@ -14,13 +14,16 @@ public class BlockLadder extends Block {
     }
 
     public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        this.updateShape(world, blockposition);
+        // Blossom start
+        this.updateShape(iblockdata);
         return super.a(world, blockposition, iblockdata);
     }
 
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
-        IBlockData iblockdata = iblockaccess.getType(blockposition);
-
+        updateShape(iblockaccess.getType(blockposition));
+    }
+    public void updateShape(IBlockData iblockdata) {
+        // Blossom end
         if (iblockdata.getBlock() == this) {
             float f = 0.125F;
 
diff --git a/src/main/java/net/minecraft/server/BlockPiston.java b/src/main/java/net/minecraft/server/BlockPiston.java
index 3592951f9..e78eabb05 100644
--- a/src/main/java/net/minecraft/server/BlockPiston.java
+++ b/src/main/java/net/minecraft/server/BlockPiston.java
@@ -183,8 +183,11 @@ public class BlockPiston extends Block {
     }
 
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
-        IBlockData iblockdata = iblockaccess.getType(blockposition);
-
+        // Blossom start
+        updateShape(iblockaccess.getType(blockposition));
+    }
+    public void updateShape(IBlockData iblockdata) {
+        // Blossom end
         if (iblockdata.getBlock() == this && ((Boolean) iblockdata.get(BlockPiston.EXTENDED)).booleanValue()) {
             float f = 0.25F;
             EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockPiston.FACING);
@@ -231,7 +234,7 @@ public class BlockPiston extends Block {
     }
 
     public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        this.updateShape(world, blockposition);
+        this.updateShape(iblockdata); // Blossom
         return super.a(world, blockposition, iblockdata);
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockSkull.java b/src/main/java/net/minecraft/server/BlockSkull.java
index 95a104903..7f4ba92fb 100644
--- a/src/main/java/net/minecraft/server/BlockSkull.java
+++ b/src/main/java/net/minecraft/server/BlockSkull.java
@@ -44,7 +44,12 @@ public class BlockSkull extends BlockContainer {
     }
 
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
-        switch (BlockSkull.SyntheticClass_1.a[((EnumDirection) iblockaccess.getType(blockposition).get(BlockSkull.FACING)).ordinal()]) {
+        // Blossom start
+        updateShape(iblockaccess.getType(blockposition));
+    }
+    public void updateShape(IBlockData iblockdata) {
+        switch (BlockSkull.SyntheticClass_1.a[iblockdata.get(BlockSkull.FACING).ordinal()]) {
+        // Blossom end
         case 1:
         default:
             this.a(0.25F, 0.0F, 0.25F, 0.75F, 0.5F, 0.75F);
@@ -69,7 +74,7 @@ public class BlockSkull extends BlockContainer {
     }
 
     public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        this.updateShape(world, blockposition);
+        this.updateShape(iblockdata); // Blossom
         return super.a(world, blockposition, iblockdata);
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockSnow.java b/src/main/java/net/minecraft/server/BlockSnow.java
index 03b1a8bc8..2624876ec 100644
--- a/src/main/java/net/minecraft/server/BlockSnow.java
+++ b/src/main/java/net/minecraft/server/BlockSnow.java
@@ -22,6 +22,7 @@ public class BlockSnow extends Block {
     public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
         int i = ((Integer) iblockdata.get(BlockSnow.LAYERS)).intValue() - 1;
         float f = 0.125F;
+        if (i == 0) return null; // Blossom
 
         return new AxisAlignedBB((double) blockposition.getX() + this.minX, (double) blockposition.getY() + this.minY, (double) blockposition.getZ() + this.minZ, (double) blockposition.getX() + this.maxX, (double) ((float) blockposition.getY() + (float) i * f), (double) blockposition.getZ() + this.maxZ);
     }
diff --git a/src/main/java/net/minecraft/server/BlockStairs.java b/src/main/java/net/minecraft/server/BlockStairs.java
index 0a60daeb2..99dadd748 100644
--- a/src/main/java/net/minecraft/server/BlockStairs.java
+++ b/src/main/java/net/minecraft/server/BlockStairs.java
@@ -37,6 +37,13 @@ public class BlockStairs extends Block {
 
     }
 
+    // Blossom start
+    @Override
+    protected boolean dynamicShape() {
+        return true;
+    }
+    // Blossom end
+
     public boolean c() {
         return false;
     }
@@ -374,6 +381,7 @@ public class BlockStairs extends Block {
         return flag1;
     }
 
+    // collect collisions
     public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
         this.e(world, blockposition);
         super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
@@ -543,29 +551,29 @@ public class BlockStairs extends Block {
     public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
         if (this.h(iblockaccess, blockposition)) {
             switch (this.g(iblockaccess, blockposition)) {
-            case 0:
-                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.STRAIGHT);
-                break;
+                case 0:
+                    iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.STRAIGHT);
+                    break;
 
-            case 1:
-                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.INNER_RIGHT);
-                break;
+                case 1:
+                    iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.INNER_RIGHT);
+                    break;
 
-            case 2:
-                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.INNER_LEFT);
+                case 2:
+                    iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.INNER_LEFT);
             }
         } else {
             switch (this.f(iblockaccess, blockposition)) {
-            case 0:
-                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.STRAIGHT);
-                break;
+                case 0:
+                    iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.STRAIGHT);
+                    break;
 
-            case 1:
-                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.OUTER_RIGHT);
-                break;
+                case 1:
+                    iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.OUTER_RIGHT);
+                    break;
 
-            case 2:
-                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.OUTER_LEFT);
+                case 2:
+                    iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.OUTER_LEFT);
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/BlockStateList.java b/src/main/java/net/minecraft/server/BlockStateList.java
index fda96405b..61dba6cab 100644
--- a/src/main/java/net/minecraft/server/BlockStateList.java
+++ b/src/main/java/net/minecraft/server/BlockStateList.java
@@ -122,6 +122,12 @@ public class BlockStateList {
         private final Map<IBlockState, Comparable> b;
         private Table<IBlockState, Comparable, IBlockData> c;
         // TacoSpigot end
+        // Blossom start
+        private static final AxisAlignedBB MASSIVE_BB = new AxisAlignedBB(-100, -100, -100, 100, 100, 100);
+        private final List<AxisAlignedBB> shape = new ArrayList<>(0); // Blossom
+        private boolean dynamic = true;
+        private boolean collideAsFullBlock = false;
+        // Blossom end
 
         private BlockData(Block block, ImmutableMap<IBlockState, Comparable> immutablemap) {
             this.a = block;
@@ -135,6 +141,57 @@ public class BlockStateList {
             // TacoSpigot end
         }
 
+        // Blossom start
+        public void calculateShape() {
+            final Block block = this.a;
+            try {
+                block.updateShape(null, BlockPosition.ZERO);
+            } catch (Throwable e) {
+                block.updateShape(this); // recalculate shape using block state if possible
+            }
+
+            try {
+                block.a(null, BlockPosition.ZERO, this, MASSIVE_BB, shape, null);
+                this.dynamic = false;
+            } catch (Throwable e) {
+                this.shape.clear();
+                this.dynamic = true;
+            }
+
+            // This abomination should be configurable
+            this.collideAsFullBlock = block instanceof BlockSign || block instanceof BlockFenceGate
+                    || block instanceof BlockTorch || block instanceof BlockButtonAbstract
+                    || block instanceof BlockLever || block instanceof BlockTripwireHook
+                    || block instanceof BlockTripwire || block instanceof BlockChest
+                    || block instanceof BlockSlowSand || block instanceof BlockBed
+                    || block instanceof BlockEnderChest || block instanceof BlockEnchantmentTable
+                    || block instanceof BlockBrewingStand;
+
+//            if (this.dynamic) {
+//                MinecraftServer.LOGGER.info("{} has a dynamic shape", this);
+//            }
+        }
+
+        public void markDynamic() {
+            this.dynamic = true;
+        }
+
+        @Override
+        public boolean isShapeDynamic() {
+            return this.dynamic;
+        }
+
+        @Override
+        public List<AxisAlignedBB> shape() {
+            return this.shape;
+        }
+
+        @Override
+        public boolean collideAsFullBlock() {
+            return this.collideAsFullBlock;
+        }
+        // Blossom end
+
         public Collection<IBlockState> a() {
             return Collections.unmodifiableCollection(this.b.keySet());
         }
diff --git a/src/main/java/net/minecraft/server/BlockStepAbstract.java b/src/main/java/net/minecraft/server/BlockStepAbstract.java
index 70db05c40..9d93edc43 100644
--- a/src/main/java/net/minecraft/server/BlockStepAbstract.java
+++ b/src/main/java/net/minecraft/server/BlockStepAbstract.java
@@ -23,10 +23,15 @@ public abstract class BlockStepAbstract extends Block {
     }
 
     public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        // Blossom start
+        updateShape(iblockaccess.getType(blockposition));
+    }
+
+    public void updateShape(IBlockData iblockdata) {
         if (this.l()) {
             this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
         } else {
-            IBlockData iblockdata = iblockaccess.getType(blockposition);
+            // Blossom end
 
             if (iblockdata.getBlock() == this) {
                 if (iblockdata.get(BlockStepAbstract.HALF) == EnumSlabHalf.TOP) {
@@ -49,7 +54,7 @@ public abstract class BlockStepAbstract extends Block {
     }
 
     public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
-        this.updateShape(world, blockposition);
+        this.updateShape(iblockdata); // Blossom
         super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockTrapdoor.java b/src/main/java/net/minecraft/server/BlockTrapdoor.java
index 88131b507..5deed1646 100644
--- a/src/main/java/net/minecraft/server/BlockTrapdoor.java
+++ b/src/main/java/net/minecraft/server/BlockTrapdoor.java
@@ -33,7 +33,7 @@ public class BlockTrapdoor extends Block {
     }
 
     public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        this.updateShape(world, blockposition);
+        this.d(iblockdata); // Blossom
         return super.a(world, blockposition, iblockdata);
     }
 
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 110fbd6af..e4f431d27 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -672,6 +672,120 @@ public abstract class Entity implements ICommandListener {
         // Blossom end
     }
 
+    protected void move_cannon(double moveX, double moveY, double moveZ) {
+        if (!me.samsuik.blossom.configuration.BlossomConfig.optimisedMovement) {
+            move(moveX, moveY, moveZ);
+            return;
+        }
+        if (this.loadChunks) loadChunks(); // PaperSpigot - Load chunks
+
+        // CraftBukkit start - Don't do anything if we aren't moving
+        // We need to do this regardless of whether or not we are moving thanks to portals
+        this.checkBlockCollisions();
+
+        // Check if we're moving
+        if (moveX == 0 && moveY == 0 && moveZ == 0 && this.vehicle == null && this.passenger == null) {
+            return;
+        }
+        // CraftBukkit end
+
+        if (this.H) {
+            this.H = false;
+            moveX *= 0.25D;
+            moveY *= 0.05000000074505806D;
+            moveZ *= 0.25D;
+            this.motX = 0.0D;
+            this.motY = 0.0D;
+            this.motZ = 0.0D;
+        }
+
+        double old_moveX = moveX;
+        double old_moveY = moveY;
+        double old_moveZ = moveZ;
+
+        boolean patchedEastWest = world.tacoSpigotConfig.fixEastWest && Math.abs(moveX) > Math.abs(moveZ);
+
+        AxisAlignedBB boundingBox = getBoundingBox();
+        List<AxisAlignedBB> shapes = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(2);
+
+        if (moveY != 0.0) {
+            world.testShapesOnY(shapes, boundingBox, boundingBox.a(0.0, moveY, 0.0), this, moveY);
+            moveY = collideY(shapes, moveY, true);
+            boundingBox = boundingBox.c(0.0, moveY, 0.0);
+        }
+
+        if (!patchedEastWest && moveX != 0.0) {
+            world.testShapesOnX(shapes, boundingBox, boundingBox.a(moveX, 0.0, 0.0), this, moveX);
+            moveX = collideX(shapes, moveX, true);
+            boundingBox = boundingBox.c(moveX, 0.0, 0.0);
+        }
+
+        if (moveZ != 0.0) {
+            world.testShapesOnZ(shapes, boundingBox, boundingBox.a(0.0, 0.0, moveZ), this, moveZ);
+            moveZ = collideZ(shapes, moveZ, true);
+            boundingBox = boundingBox.c(0.0, 0.0, moveZ);
+        }
+
+        if (patchedEastWest && moveX != 0.0) {
+            world.testShapesOnX(shapes, boundingBox, boundingBox.a(moveX, 0.0, 0.0), this, moveX);
+            moveX = collideX(shapes, moveX, false);
+            boundingBox = boundingBox.c(moveX, 0.0, 0.0);
+        }
+
+        this.boundingBox = boundingBox;
+
+        this.recalcPosition();
+        this.positionChanged = old_moveX != moveX || old_moveZ != moveZ;
+        this.E = old_moveY != moveY;
+        this.onGround = this.E && old_moveY < 0.0D;
+        this.F = this.positionChanged || this.E;
+
+        if (old_moveX != moveX) {
+            this.motX = 0.0D;
+        }
+
+        if (old_moveZ != moveZ) {
+            this.motZ = 0.0D;
+        }
+
+        if (old_moveY != moveY) {
+            int i = MathHelper.floor(this.locX);
+            int j = MathHelper.floor(this.locY - 0.20000000298023224D);
+            int k = MathHelper.floor(this.locZ);
+
+            Chunk chunk = getChunkAtLocation();
+            if (chunk == null) return;
+            Block block = chunk.getBlockData(i, j, k).getBlock();
+
+            if (block.getMaterial() == Material.AIR) {
+                block = chunk.getBlockData(i, j - 1, k).getBlock();
+            }
+
+            block.a(this.world, this);
+        }
+    }
+
+    private double collideX(List<AxisAlignedBB> shapes, double moveX, boolean clear) {
+        for (int i = 0; i < shapes.size(); i++)
+            moveX = shapes.get(i).collideX(boundingBox, moveX);
+        if (clear) shapes.clear();
+        return moveX;
+    }
+
+    private double collideY(List<AxisAlignedBB> shapes, double moveY, boolean clear) {
+        for (int i = 0; i < shapes.size(); i++)
+            moveY = shapes.get(i).collideY(boundingBox, moveY);
+        if (clear) shapes.clear();
+        return moveY;
+    }
+
+    private double collideZ(List<AxisAlignedBB> shapes, double moveZ, boolean clear) {
+        for (int i = 0; i < shapes.size(); i++)
+            moveZ = shapes.get(i).collideZ(boundingBox, moveZ);
+        if (clear) shapes.clear();
+        return moveZ;
+    }
+    // Blossom end
 
     public void move(double d0, double d1, double d2) {
         if (this.loadChunks) loadChunks(); // PaperSpigot - Load chunks
@@ -783,11 +897,11 @@ public abstract class Entity implements ICommandListener {
             Iterator iterator1;
 
             if(this.world.tacoSpigotConfig.fixEastWest && Math.abs(d0) > Math.abs(d2)) { //TacoSpigot - fix east/west cannoning by calculating the z movement before x if the x velocity is greater
-            if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(0, 0, d2)); // TacoSpigot - get z axis blocks
+                if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(0, 0, d2)); // TacoSpigot - get z axis blocks
 
-            for (iterator1 = list.iterator(); iterator1.hasNext(); d2 = axisalignedbb2.c(this.getBoundingBox(), d2)) {
-                axisalignedbb2 = (AxisAlignedBB) iterator1.next();
-            }
+                for (iterator1 = list.iterator(); iterator1.hasNext(); d2 = axisalignedbb2.c(this.getBoundingBox(), d2)) {
+                    axisalignedbb2 = (AxisAlignedBB) iterator1.next();
+                }
 
                 this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
 
@@ -800,21 +914,21 @@ public abstract class Entity implements ICommandListener {
                 this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
 
             } else {
-            if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(d0, 0, 0)); // TacoSpigot - get x axis blocks
+                if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(d0, 0, 0)); // TacoSpigot - get x axis blocks
 
-            for (iterator1 = list.iterator(); iterator1.hasNext(); d0 = axisalignedbb2.a(this.getBoundingBox(), d0)) {
-                axisalignedbb2 = (AxisAlignedBB) iterator1.next();
-            }
+                for (iterator1 = list.iterator(); iterator1.hasNext(); d0 = axisalignedbb2.a(this.getBoundingBox(), d0)) {
+                    axisalignedbb2 = (AxisAlignedBB) iterator1.next();
+                }
 
-            this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
+                this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
 
-            if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(0, 0, d2)); // TacoSpigot - get z axis blocks
+                if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(0, 0, d2)); // TacoSpigot - get z axis blocks
 
-            for (iterator1 = list.iterator(); iterator1.hasNext(); d2 = axisalignedbb2.c(this.getBoundingBox(), d2)) {
-                axisalignedbb2 = (AxisAlignedBB) iterator1.next();
-            }
+                for (iterator1 = list.iterator(); iterator1.hasNext(); d2 = axisalignedbb2.c(this.getBoundingBox(), d2)) {
+                    axisalignedbb2 = (AxisAlignedBB) iterator1.next();
+                }
 
-            this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
+                this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
             }
 
             if (this.S > 0.0F && flag1 && (d6 != d0 || d8 != d2)) {
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index f0e3a96e3..34b6f6bd3 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -108,7 +108,7 @@ public class EntityFallingBlock extends Entity {
             }
 
             this.motY -= 0.03999999910593033D;
-            this.move(this.motX, this.motY, this.motZ);
+            this.move_cannon(this.motX, this.motY, this.motZ); // Blossom
 
             // PaperSpigot start - Remove entities in unloaded chunks
             if (this.inUnloadedChunk && world.paperSpigotConfig.removeUnloadedFallingBlocks) {
diff --git a/src/main/java/net/minecraft/server/EntityTNTPrimed.java b/src/main/java/net/minecraft/server/EntityTNTPrimed.java
index 0e1319f47..307b337be 100644
--- a/src/main/java/net/minecraft/server/EntityTNTPrimed.java
+++ b/src/main/java/net/minecraft/server/EntityTNTPrimed.java
@@ -107,7 +107,7 @@ public class EntityTNTPrimed extends Entity {
         this.lastY = this.locY;
         this.lastZ = this.locZ;
         this.motY -= 0.03999999910593033D;
-        this.move(this.motX, this.motY, this.motZ);
+        this.move_cannon(this.motX, this.motY, this.motZ); // Blossom
 
         // PaperSpigot start - Drop TNT entities above the specified height
         if (this.world.paperSpigotConfig.tntEntityHeightNerf != 0 && this.locY > this.world.paperSpigotConfig.tntEntityHeightNerf) {
diff --git a/src/main/java/net/minecraft/server/IBlockData.java b/src/main/java/net/minecraft/server/IBlockData.java
index 3c3ab0c59..b002875c5 100644
--- a/src/main/java/net/minecraft/server/IBlockData.java
+++ b/src/main/java/net/minecraft/server/IBlockData.java
@@ -16,4 +16,16 @@ public interface IBlockData {
     ImmutableMap<IBlockState, Comparable> b();
 
     Block getBlock();
+
+    // Blossom start
+    default int legacyData() {
+        return getBlock().toLegacyData(this);
+    }
+
+    boolean isShapeDynamic();
+
+    java.util.List<AxisAlignedBB> shape();
+
+    boolean collideAsFullBlock();
+    // Blossom end
 }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index e90a247ce..2b00efb82 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -4,6 +4,7 @@ import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import me.samsuik.blossom.utils.SectionChunkCache;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.CraftServer;
@@ -1357,6 +1358,154 @@ public abstract class World implements IBlockAccess {
         this.u.add(iworldaccess);
     }
 
+    // Blossom start - rewrite and optimise block collisions
+    private static final double EPSILON = 1.0e-7;
+
+    public void testShapesOnX(List<AxisAlignedBB> list, AxisAlignedBB bb, AxisAlignedBB scan, Entity entity, double dir) {
+        int minY = Math.max(MathHelper.floor(bb.b - (me.samsuik.blossom.configuration.BlossomConfig.extendedCollisionSearch ? 0.5 : 0)), 0);
+        int maxY = Math.min(MathHelper.floor(bb.e), 255) + 1;
+        int minZ = MathHelper.floor(bb.c);
+        int maxZ = MathHelper.floor(bb.f) + 1;
+        SectionChunkCache cache = new SectionChunkCache(this, scan);
+
+        if (dir > 0.0) {
+            int minX = MathHelper.floor(bb.d + EPSILON);
+            int maxX = MathHelper.floor(bb.d + dir) + 1;
+            for (int x = minX; x < maxX; ++x) {
+                if (traverseChunkX(entity, list, scan, cache, x, minY, maxY, minZ, maxZ)) {
+                    break;
+                }
+            }
+        } else if (dir < 0.0) {
+            int minX = MathHelper.floor(bb.a + dir);
+            int maxX = MathHelper.floor(bb.a - EPSILON);
+            for (int x = maxX; x >= minX; --x) {
+                if (traverseChunkX(entity, list, scan, cache, x, minY, maxY, minZ, maxZ)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    public void testShapesOnY(List<AxisAlignedBB> list, AxisAlignedBB bb, AxisAlignedBB scan, Entity entity, double dir) {
+        int minX = MathHelper.floor(bb.a);
+        int maxX = MathHelper.floor(bb.d) + 1;
+        int minZ = MathHelper.floor(bb.c);
+        int maxZ = MathHelper.floor(bb.f) + 1;
+        SectionChunkCache cache = new SectionChunkCache(this, scan);
+
+        if (dir > 0.0) {
+            int minY = Math.max(MathHelper.floor(bb.e + EPSILON), 0);
+            int maxY = Math.min(MathHelper.floor(bb.e + dir), 255) + 1;
+            for (int y = minY; y < maxY; ++y) {
+                if (traverseChunkY(entity, list, scan, cache, y, minX, maxX, minZ, maxZ)) {
+                    break;
+                }
+            }
+        } else if (dir < 0.0) {
+            int minY = Math.max(MathHelper.floor(bb.b + dir - (me.samsuik.blossom.configuration.BlossomConfig.extendedCollisionSearch ? 0.5 : 0)), 0);
+            int maxY = Math.min(MathHelper.floor(bb.b - EPSILON), 255);
+            for (int y = maxY; y >= minY; --y) {
+                if (traverseChunkY(entity, list, scan, cache, y, minX, maxX, minZ, maxZ)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    public void testShapesOnZ(List<AxisAlignedBB> list, AxisAlignedBB bb, AxisAlignedBB scan, Entity entity, double dir) {
+        int minX = MathHelper.floor(bb.a);
+        int maxX = MathHelper.floor(bb.d) + 1;
+        int minY = Math.max(MathHelper.floor(bb.b - (me.samsuik.blossom.configuration.BlossomConfig.extendedCollisionSearch ? 0.5 : 0)), 0);
+        int maxY = Math.min(MathHelper.floor(bb.e), 255) + 1;
+        SectionChunkCache cache = new SectionChunkCache(this, scan);
+
+        if (dir > 0.0) {
+            int minZ = MathHelper.floor(bb.f + EPSILON);
+            int maxZ = MathHelper.floor(bb.f + dir) + 1;
+            for (int z = minZ; z < maxZ; ++z) {
+                if (traverseChunkZ(entity, list, scan, cache, z, minX, maxX, minY, maxY)) {
+                    break;
+                }
+            }
+        } else if (dir < 0.0) {
+            int minZ = MathHelper.floor(bb.c + dir);
+            int maxZ = MathHelper.floor(bb.c - EPSILON);
+            for (int z = maxZ; z >= minZ; --z) {
+                if (traverseChunkZ(entity, list, scan, cache, z, minX, maxX, minY, maxY)) {
+                    break;
+                }
+            }
+        }
+    }
+
+    private boolean traverseChunkX(Entity entity, List<AxisAlignedBB> shapes, AxisAlignedBB scan, SectionChunkCache cache, int x, int minY, int maxY, int minZ, int maxZ) {
+        for (int z = minZ; z < maxZ; ++z) {
+            for (int y = minY; y < maxY; ++y) {
+                collideWithBlock(entity, shapes, scan, cache, x, y, z);
+            }
+        }
+
+        return !shapes.isEmpty();
+    }
+
+    private boolean traverseChunkY(Entity entity, List<AxisAlignedBB> shapes, AxisAlignedBB scan, SectionChunkCache cache, int y, int minX, int maxX, int minZ, int maxZ) {
+        for (int x = minX; x < maxX; ++x) {
+            for (int z = minZ; z < maxZ; ++z) {
+                collideWithBlock(entity, shapes, scan, cache, x, y, z);
+            }
+        }
+
+        return !shapes.isEmpty();
+    }
+
+    private boolean traverseChunkZ(Entity entity, List<AxisAlignedBB> shapes, AxisAlignedBB scan, SectionChunkCache cache, int z, int minX, int maxX, int minY, int maxY) {
+        for (int x = minX; x < maxX; ++x) {
+            for (int y = minY; y < maxY; ++y) {
+                collideWithBlock(entity, shapes, scan, cache, x, y, z);
+            }
+        }
+
+        return !shapes.isEmpty();
+    }
+
+    private void collideWithBlock(Entity entity, List<AxisAlignedBB> shapes, AxisAlignedBB scan, SectionChunkCache cache, int x, int y, int z) {
+        IBlockData iblockdata = cache.getType(x, y, z);
+
+        if (iblockdata != null) {
+            AxisAlignedBB entityBB = entity.getBoundingBox();
+            if (paper_isForcedFullBlock(entity, iblockdata)) {
+                AxisAlignedBB bb = AxisAlignedBB.a(x, y, z, x + 1.0, y + 1.0, z + 1.0);
+                if (scan.b(bb) && !entityBB.b(bb)) {
+                    shapes.add(bb);
+                    return;
+                }
+            }
+
+            if (iblockdata.isShapeDynamic()) {
+                iblockdata.getBlock().a(this, new BlockPosition(x, y, z), iblockdata, scan, shapes, entity);
+                // inserted bbs may be inside the entity bb which would cause the collision to fail
+                for (int i = 0; i < shapes.size(); i++) {
+                    AxisAlignedBB bb = shapes.get(i);
+                    if (entityBB.b(bb)) shapes.remove(i--);
+                }
+            } else {
+                List<AxisAlignedBB> shape = iblockdata.shape();
+                //noinspection ForLoopReplaceableByForEach
+                for (int i = 0, shapeSize = shape.size(); i < shapeSize; i++) {
+                    final AxisAlignedBB moved = shape.get(i).c(x, y, z);
+                    if (scan.b(moved) && !entityBB.b(moved)) shapes.add(moved);
+                }
+            }
+        }
+    }
+
+    private boolean paper_isForcedFullBlock(Entity entity, IBlockData iblockdata) {
+        // entity.world.paperSpigotConfig.fallingBlocksCollideWithSigns && (entity instanceof EntityTNTPrimed || entity instanceof EntityFallingBlock) && (b instanceof BlockSign || b instanceof BlockFenceGate || b instanceof BlockTorch || b instanceof BlockButtonAbstract || b instanceof BlockLever || b instanceof BlockTripwireHook || b instanceof BlockTripwire || b instanceof BlockChest || b instanceof BlockSlowSand || b instanceof BlockBed || b instanceof BlockEnderChest || b instanceof BlockEnchantmentTable || b instanceof BlockBrewingStand);
+        return entity.world.paperSpigotConfig.fallingBlocksCollideWithSigns && entity.isCannoningEntity && iblockdata.collideAsFullBlock();
+    }
+    // Blossom end - rewrite and optimise block collisions
+
     public List<AxisAlignedBB> getCubes(Entity entity, AxisAlignedBB axisalignedbb) {
         ArrayList arraylist = Lists.newArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
@@ -1372,7 +1521,7 @@ public abstract class World implements IBlockAccess {
         BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
 
         // Spigot start
-        int ystart = ( ( k - 1 ) < 0 ) ? 0 : ( k - 1 );
+        int ystart = Math.max(k - (me.samsuik.blossom.configuration.BlossomConfig.extendedCollisionSearch ? 1 : 0), 0); // Blossom
         for ( int chunkx = ( i >> 4 ); chunkx <= ( ( j - 1 ) >> 4 ); chunkx++ )
         {
             int cx = chunkx << 4;
@@ -1403,7 +1552,7 @@ public abstract class World implements IBlockAccess {
                     {
                         for ( int y = ystart; y < l; y++ )
                         {
-                            BlockPosition blockposition = new BlockPosition( x, y, z );
+                            blockposition_mutableblockposition.setValues(x, y, z); // Blossom
 
                             if (flag && flag1) {
                                 entity.h(false);
@@ -1412,21 +1561,21 @@ public abstract class World implements IBlockAccess {
                             }
 
                             IBlockData block;
-                            if (!this.getWorldBorder().a(blockposition) && flag1) {
+                            if (!this.getWorldBorder().a(blockposition_mutableblockposition) && flag1) { // Blossom
                                 block = Blocks.STONE.getBlockData();
                             } else
                             {
-                                block = chunk.getBlockData( blockposition );
+                                block = chunk.getBlockData( blockposition_mutableblockposition ); // Blossom
                             }
                             if ( block != null )
                             {
                                 // PaperSpigot start - FallingBlocks and TNT collide with specific non-collidable blocks
                                 Block b = block.getBlock();
-                                if (entity.world.paperSpigotConfig.fallingBlocksCollideWithSigns && (entity instanceof EntityTNTPrimed || entity instanceof EntityFallingBlock) && (b instanceof BlockSign || b instanceof BlockFenceGate || b instanceof BlockTorch || b instanceof BlockButtonAbstract || b instanceof BlockLever || b instanceof BlockTripwireHook || b instanceof BlockTripwire || b instanceof BlockChest || b instanceof BlockSlowSand || b instanceof BlockBed || b instanceof BlockEnderChest || b instanceof BlockEnchantmentTable || b instanceof BlockBrewingStand)) {
+                                if (this.paper_isForcedFullBlock(entity, block)) { // Blossom - rewrite and optimise block collisions
                                     AxisAlignedBB aabb = AxisAlignedBB.a(x, y, z, x + 1.0, y + 1.0, z + 1.0);
                                     if (axisalignedbb.b(aabb)) arraylist.add(aabb);
                                 } else {
-                                    b.a(this, blockposition, block, axisalignedbb, arraylist, entity);
+                                    b.testShape(this, blockposition_mutableblockposition, block, axisalignedbb, arraylist, entity); // Blossom
                                 }
                                 // PaperSpigot end
                             }
-- 
2.50.1

