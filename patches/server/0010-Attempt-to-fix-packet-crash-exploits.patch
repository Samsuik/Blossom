From 9455ab7aa94f40fa925e20db0da0cd7ab93585cd Mon Sep 17 00:00:00 2001
From: Samsuik <40902469+Samsuik@users.noreply.github.com>
Date: Tue, 9 May 2023 18:23:37 +0100
Subject: [PATCH] Attempt to fix packet crash exploits


diff --git a/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java b/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
index 29335ea37..ec560c0ad 100644
--- a/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
+++ b/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
@@ -15,6 +15,7 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -129,5 +130,56 @@ public class BlossomConfig {
         ppsViolations = getInt("packet-limiter.violations", 7);
         ppsMax = getInt("packet-limiter.max-pps", 400);
     }
+
+    public static me.samsuik.blossom.utils.items.ItemValidationLevel itemValidation;
+    private static void ItemValidation() {
+        try {
+            String value = getString("item-validation", "lenient");
+            String upperCase = value.toUpperCase(Locale.ROOT);
+            itemValidation = me.samsuik.blossom.utils.items.ItemValidationLevel.valueOf(upperCase);
+        } catch (Exception ex) {
+            itemValidation = me.samsuik.blossom.utils.items.ItemValidationLevel.LENIENT;
+            LOGGER.info("malformed \"item-validation\" defaulting to \"lenient\"");
+        }
+    }
+
+    public static long nbtByteLimit = 2097152L;
+    public static Map<String, Long> itemNbtByteLimits = new HashMap<>();
+    private static void NBTReaderLimits() {
+        if (!config.contains("nbt-reader-byte-limits")) {
+            set("nbt-reader-byte-limits.writable_book", 10240L);
+            set("nbt-reader-byte-limits.written_book", 10240L);
+            set("nbt-reader-byte-limits.fireworks", 3072L); // ~2048
+            set("nbt-reader-byte-limits.firework_charge", 512L); // ~350
+            set("nbt-reader-byte-limits.skull", 8096L); // ~4200
+            set("nbt-reader-byte-limits.enchanted_book", 16192L); // ~200*24 that is excluding clients to create books of unnecessary enchants, stupid
+            set("nbt-reader-byte-limits.banner", 16192L); // :pray: considering the above this won't go down well
+            set("nbt-reader-byte-limits.map", 1024L);
+            set("nbt-reader-byte-limits.filled_map", 1024L);
+            set("nbt-reader-byte-limits.global", 2097152L);
+        }
+
+        itemNbtByteLimits.clear(); // reloading
+        collectNbtByteLimits("nbt-reader-byte-limits", itemNbtByteLimits);
+        nbtByteLimit = itemNbtByteLimits.get("global");
+    }
+
+    public static boolean hasNbtByteLimit(net.minecraft.server.Item item) {
+        return item != null && itemNbtByteLimits.containsKey(net.minecraft.server.Item.REGISTRY.c(item).a());
+    }
+
+    public static long getNbtByteLimit(net.minecraft.server.Item item) {
+        if (item == null) return nbtByteLimit;
+        return itemNbtByteLimits.getOrDefault(net.minecraft.server.Item.REGISTRY.c(item).a(), nbtByteLimit);
+    }
+
+    @SuppressWarnings("SameParameterValue")
+    private static void collectNbtByteLimits(String path, Map<String, Long> limits) {
+        org.bukkit.configuration.ConfigurationSection section = config.getConfigurationSection(path);
+
+        section.getValues(false).forEach((key, value) -> {
+            limits.put(key, ((Number) value).longValue());
+        });
+    }
     
 }
diff --git a/src/main/java/me/samsuik/blossom/utils/items/ComponentUtil.java b/src/main/java/me/samsuik/blossom/utils/items/ComponentUtil.java
new file mode 100644
index 000000000..80c919b6e
--- /dev/null
+++ b/src/main/java/me/samsuik/blossom/utils/items/ComponentUtil.java
@@ -0,0 +1,92 @@
+package me.samsuik.blossom.utils.items;
+
+import net.minecraft.server.ChatComponentText;
+import net.minecraft.server.IChatBaseComponent;
+
+import java.util.regex.Pattern;
+
+public class ComponentUtil {
+
+    private final static Pattern DISALLOWED_CHARACTERS = Pattern.compile("[^ -Ã¿\\n]");
+
+    public static String stripDisallowedCharacters(String string) {
+        return DISALLOWED_CHARACTERS.matcher(string).replaceAll("");
+    }
+
+    public static boolean hasDisallowedCharacter(String string) {
+        return DISALLOWED_CHARACTERS.matcher(string).find();
+    }
+
+    public static boolean hasBadComponents(String string, boolean written) {
+        if (hasDisallowedCharacter(string)) {
+            return true;
+        }
+
+        IChatBaseComponent ichatbasecomponent = fromString(string, written);
+
+        if (ichatbasecomponent.a().size() > 1 || isInvalidOrSuspicious(ichatbasecomponent)) {
+            return true;
+        }
+
+        for (IChatBaseComponent base : ichatbasecomponent.a()) {
+            if (!base.a().isEmpty() || isInvalidOrSuspicious(ichatbasecomponent)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private static IChatBaseComponent fromString(String string, boolean written) {
+        // this is pain, erase my existence please
+        if (!written) {
+            return new ChatComponentText(string);
+        }
+
+        IChatBaseComponent component;
+
+        try {
+            component = IChatBaseComponent.ChatSerializer.a(string);
+        } catch (Exception exception) {
+            // malformed json!
+            component = new ChatComponentText(string);
+        }
+
+        return component;
+    }
+
+    private static boolean isInvalidOrSuspicious(IChatBaseComponent component) {
+        return isSeeminglyRandom(component.getText());
+    }
+
+    private static boolean isSeeminglyRandom(String string) {
+        // Not enough data for us to make a decision
+        if (string.length() < 16) {
+            return false;
+        }
+
+        int[] distribution = new int[256];
+        char[] chars = string.toCharArray();
+
+        float average = 0.0f;
+        int highest = 0, hits = 0;
+
+        for (char character : chars) {
+            distribution[character & 255]++;
+        }
+
+        for (int dist : distribution) {
+            if (dist != 0) {
+                average += dist;
+                hits++;
+            }
+
+            highest = Math.max(dist, highest);
+        }
+
+        average /= hits;
+
+        return average / (float) highest > 0.4;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/me/samsuik/blossom/utils/items/ItemValidation.java b/src/main/java/me/samsuik/blossom/utils/items/ItemValidation.java
new file mode 100644
index 000000000..9b67dac25
--- /dev/null
+++ b/src/main/java/me/samsuik/blossom/utils/items/ItemValidation.java
@@ -0,0 +1,365 @@
+package me.samsuik.blossom.utils.items;
+
+import me.samsuik.blossom.configuration.BlossomConfig;
+import net.minecraft.server.*;
+
+import java.util.Collection;
+import java.util.function.Predicate;
+
+public class ItemValidation {
+
+    private static final Predicate<NBTTagCompound> DISPLAY_TEST = (tag) -> {
+        if (!tag.hasKeyOfType("display", 10)) {
+            return true;
+        }
+
+        NBTTagCompound display = tag.getCompound("display");
+
+        if (display.hasKeyOfType("Name", 8) && display.getString("Name").length() > 128) { // vanilla max is 48?
+            return false;
+        } else if (!display.hasKeyOfType("Lore", 9)) {
+            return true;
+        }
+
+        NBTTagList lore = display.getList("Lore", 8);
+        // todo: reduce the max lines to 64 or 48 and max characters to 256
+        // The current limits are ridiculously high
+        if (lore.size() > 128) {
+            return false;
+        }
+
+        for (int i = 0; i < lore.size(); ++i) {
+            if (lore.getString(i).length() > 1024) {
+                return false;
+            }
+        }
+
+        return true;
+    };
+
+    private static final Predicate<NBTTagCompound> ATTRIBUTE_TEST = (tag) -> {
+        if (!tag.hasKeyOfType("AttributeModifiers", 9)) {
+            return true;
+        }
+
+        NBTTagList attributes = tag.getList("AttributeModifiers", 10);
+
+        if (attributes.size() > 8) {
+            return false; // there's only 8 attributes in the game!
+        }
+
+        for (int i = 0; i < attributes.size(); ++i) {
+            NBTTagCompound compound = attributes.get(i);
+
+            if (!validateDouble(compound, "Amount", -1024, 1024)) {
+                return false;
+            }
+
+            if (!validateInt(compound, "Operation", 0, 2)) {
+                return false;
+            }
+
+            if (validateString(compound, "Name", 0, 0, false)) {
+                return false;
+            }
+        }
+
+        return true;
+    };
+
+    private static final Predicate<NBTTagCompound> ENCHANTMENT_TEST = (tag) -> {
+        if (!tag.hasKeyOfType("ench", 9)) {
+            return true;
+        }
+
+        NBTTagList enchants = tag.getList("ench", 10);
+
+        if (enchants.size() > 24) {
+            return false; // *sigh*
+        }
+
+        for (int i = 0; i < enchants.size(); ++i) {
+            NBTTagCompound enchant = enchants.get(i);
+            int max = 32767;
+
+            if (enchant.hasKeyOfType("id", 99)) {
+                max = getMaxEnchantmentLevel(enchant.getInt("id"));
+            }
+
+            if (!validateInt(enchant, "lvl", 0, max)) {
+                return false;
+            }
+        }
+
+        return true;
+    };
+
+    private static final Predicate<NBTTagCompound> BOOK_PAGE_TEST = tag -> !tag.hasKeyOfType("pages", 9) || ItemBookAndQuill.b(tag);
+
+    private static final Predicate<NBTTagCompound> BOOK_TEST = (tag) -> {
+        // The vanilla limit is 32
+        if (!validateString(tag, "title", 0, 64, true)) {
+            return false;
+        } else if (!validateString(tag, "author", 0, 64, true)) {
+            return false;
+        }
+
+        return BOOK_PAGE_TEST.test(tag);
+    };
+
+    private static final Predicate<NBTTagCompound> FIREWORK_TEST = (tag) -> {
+        if (!tag.hasKeyOfType("Fireworks", 10)) {
+            return true;
+        }
+
+        NBTTagCompound fireworks = tag.getCompound("Fireworks");
+
+        if (!validateInt(fireworks, "Flight", 0, 8)) {
+            return false;
+        }
+
+        return !fireworks.hasKeyOfType("Explosions", 9) || fireworks.getList("Explosions", 10).size() <= 16;
+    };
+
+    private static final Predicate<NBTTagCompound> DECORATION_TEST = (tag) -> {
+        if (!tag.hasKeyOfType("Decorations", 9)) {
+            return true;
+        }
+
+        NBTTagList decorations = tag.getList("Decorations", 10);
+
+        if (decorations.size() > 16) {
+            return false; // is this value sane? maybe too low or high
+        }
+
+        for (int i = 0; i < decorations.size(); ++i) {
+            NBTTagCompound decoration = decorations.get(i);
+
+            if (!validateInt(decoration, "type", 0, 15)) {
+                return false;
+            }
+
+            if (!validateString(decoration, "id", 0, 32, false)) {
+                return false;
+            }
+
+            // map paranoia, it's like that monster hiding under your bed. you never know when it'll come out...
+            if (!validateDouble(decoration, "x", 0, 128)) {
+                return false;
+            }
+
+            if (!validateDouble(decoration, "z", 0, 128)) {
+                return false;
+            }
+
+            if (!validateDouble(decoration, "rot", -8.0, 8.0)) {
+                return false;
+            }
+        }
+
+        return true;
+    };
+
+    private static final Predicate<NBTTagCompound> CUSTOM_POTION_EFFECTS_TEST = (tag) -> {
+        if (!tag.hasKeyOfType("CustomPotionEffects", 9)) {
+            return true;
+        }
+
+        NBTTagList effects = tag.getList("CustomPotionEffects", 10);
+
+        if (effects.size() > 23) {
+            return false;
+        }
+
+        for (int i = 0; i < effects.size(); ++i) {
+            NBTTagCompound effect = effects.get(i);
+
+            // clamp this for effects that should only be 1
+            int max = 127;
+
+            if (effect.hasKeyOfType("Id", 99)) {
+                int id = effect.getInt("Id");
+
+                if (id == 9 || id >= 12 && id <= 16) {
+                    max = 1;
+                }
+            }
+
+            if (!validateInt(effect, "Amplifier", 0, max)) {
+                return false;
+            }
+        }
+
+        return true;
+    };
+
+    private static final int GARBAGE_THRESHOLD = 768;
+    private static final int DEPTH_LIMIT = 12;
+
+    private static final Predicate<NBTTagCompound> NBT_GARBAGE_TEST = (tag) -> !isHotGarbage(tag, new int[] {0}, 0);
+
+    private static boolean isHotGarbage(NBTBase tag, int[] count, int depth) {
+        if (count[0] >= GARBAGE_THRESHOLD || ++depth >= DEPTH_LIMIT) {
+            return true;
+        } else if (tag.getTypeId() == 10) {
+            NBTTagCompound compound = (NBTTagCompound) tag;
+            Collection<NBTBase> collection = compound.getStoredNBT();
+            count[0] += collection.size();
+
+            for (NBTBase base : collection) {
+                if (isHotGarbage(base, count, depth)) {
+                    return true;
+                }
+            }
+        } else if (tag.getTypeId() == 9) {
+            NBTTagList list = (NBTTagList) tag;
+            count[0] += list.size();
+
+            for (int i = 0; i < list.size(); ++i) {
+                if (isHotGarbage(list.get(i), count, depth)) {
+                    return true;
+                }
+            }
+        } else if (tag.getTypeId() == 7) {
+            NBTTagByteArray byteArray = (NBTTagByteArray) tag;
+            count[0] += (byteArray.c().length / 8) + 1;
+            return byteArray.c().length > 128;
+        } else if (tag.getTypeId() == 11) {
+            NBTTagIntArray intArray = (NBTTagIntArray) tag;
+            count[0] += (intArray.c().length / 2) + 1;
+            return intArray.c().length > 32;
+        } else if (tag.getTypeId() == 8) {
+            NBTTagString string = (NBTTagString) tag;
+            count[0] += (string.a_().length() / 4) + 1;
+            return string.a_().length() > 1024;
+        }
+
+        return false;
+    }
+
+    private static final Predicate<NBTTagCompound> GENERIC_ITEM_TEST = DISPLAY_TEST.and(ENCHANTMENT_TEST).and(ATTRIBUTE_TEST).and(NBT_GARBAGE_TEST);
+
+    private static boolean compareItemType(ItemStack serverItemStack, ItemStack clientItemStack) {
+        if (serverItemStack == null && clientItemStack == null) {
+            return true;
+        }
+
+        return serverItemStack != null   && clientItemStack != null
+            && serverItemStack.getItem() == clientItemStack.getItem();
+    }
+
+    public static boolean validateItemStacks(ItemStack serverItemStack, ItemStack clientItemStack) {
+        if (clientItemStack == null || clientItemStack.getItem() == null) {
+            return true;
+        }
+
+        // Filter out players attempting to use invalid/oversized items
+        if (compareItemType(serverItemStack, clientItemStack) && isValidItemStack(clientItemStack)) {
+            return true;
+        }
+
+        Item clientItem = clientItemStack.getItem();
+        if (clientItem instanceof ItemBlock) {
+            return true;
+        }
+
+        return BlossomConfig.getNbtByteLimit(clientItem) < BlossomConfig.nbtByteLimit;
+    }
+
+    public static boolean isValidItemStack(ItemStack itemstack) {
+        if (BlossomConfig.itemValidation == ItemValidationLevel.OFF) {
+            return true;
+        }
+
+        // empty or item with no nbt
+        if (itemstack == null || itemstack.getItem() == null || !itemstack.hasTag()) {
+            return true;
+        }
+
+        Predicate<NBTTagCompound> test;
+        if (BlossomConfig.itemValidation == ItemValidationLevel.LENIENT) {
+            test = getRelaxedTestForItem(itemstack.getItem());
+        } else {
+            test = getTestForItem(itemstack.getItem());
+        }
+
+        return test == null || test.test(itemstack.getTag());
+    }
+
+    private static Predicate<NBTTagCompound> getRelaxedTestForItem(Item item) {
+        Predicate<NBTTagCompound> special = null;
+
+        if (item instanceof ItemBookAndQuill || item instanceof ItemWrittenBook) {
+            special = BOOK_PAGE_TEST;
+        }
+
+        return special;
+    }
+
+    private static Predicate<NBTTagCompound> getTestForItem(Item item) {
+        Predicate<NBTTagCompound> special = null;
+
+        if (item instanceof ItemBookAndQuill || item instanceof ItemWrittenBook) {
+            special = BOOK_TEST;
+        } else if (item instanceof ItemFireworks || item instanceof ItemFireworksCharge) {
+            special = FIREWORK_TEST;
+        } else if (item instanceof ItemPotion) {
+            special = CUSTOM_POTION_EFFECTS_TEST;
+        } else if (item instanceof ItemWorldMapBase) {
+            special = DECORATION_TEST;
+        }
+
+        Predicate<NBTTagCompound> base = GENERIC_ITEM_TEST;
+
+        if (special != null) {
+            base = base.and(special);
+        }
+
+        return base;
+    }
+
+    private static int getMaxEnchantmentLevel(int id) {
+        int lvl = 32767;
+
+        // This is mainly to annoy people trying to use a modified client to create silly enchantments
+        // enchant 50 (flame) is a special case, it's a common misconception that it can go higher than lvl 1.
+        if (id == 19 || id == 21 || id == 35 || id == 49 || id == 50) {
+            lvl = 255;
+        } else if (id == 8) {
+            lvl = 3;
+        } else if (id == 5 || id == 6 || id == 51) {
+            lvl = 1;
+        }
+
+        return lvl;
+    }
+
+    private static boolean validateDouble(NBTTagCompound compound, String id, double min, double max) {
+        if (!compound.hasKeyOfType(id, 99)) {
+            return true;
+        }
+
+        double val = compound.getDouble(id);
+        return !Double.isNaN(val) && val >= min && val <= max;
+    }
+
+    private static boolean validateInt(NBTTagCompound compound, String id, int min, int max) {
+        if (!compound.hasKeyOfType(id, 99)) {
+            return true;
+        }
+
+        int val = compound.getInt(id);
+        return val >= min && val <= max;
+    }
+
+    private static boolean validateString(NBTTagCompound compound, String id, int min, int length, boolean characters) {
+        if (!compound.hasKeyOfType(id, 8)) {
+            return true;
+        }
+
+        String str = compound.getString(id);
+        int len = str.length();
+        return len >= min && len <= length && (!characters || !ComponentUtil.hasDisallowedCharacter(str));
+    }
+
+}
diff --git a/src/main/java/me/samsuik/blossom/utils/items/ItemValidationLevel.java b/src/main/java/me/samsuik/blossom/utils/items/ItemValidationLevel.java
new file mode 100644
index 000000000..326b38362
--- /dev/null
+++ b/src/main/java/me/samsuik/blossom/utils/items/ItemValidationLevel.java
@@ -0,0 +1,7 @@
+package me.samsuik.blossom.utils.items;
+
+public enum ItemValidationLevel {
+    OFF,
+    LENIENT,
+    STRICT
+}
diff --git a/src/main/java/net/minecraft/server/Container.java b/src/main/java/net/minecraft/server/Container.java
index c2f7ccd75..05e60dce6 100644
--- a/src/main/java/net/minecraft/server/Container.java
+++ b/src/main/java/net/minecraft/server/Container.java
@@ -72,11 +72,15 @@ public abstract class Container {
     }
 
     public void b() {
+        // Blossom start
+        broadcastDirtyItemUpdates(false);
+    }
+    public void broadcastDirtyItemUpdates(boolean flag) {
         for (int i = 0; i < this.c.size(); ++i) {
             ItemStack itemstack = ((Slot) this.c.get(i)).getItem();
             ItemStack itemstack1 = (ItemStack) this.b.get(i);
 
-            if (!ItemStack.fastMatches(itemstack1, itemstack) || (tickCount % 20 == 0 && !ItemStack.matches(itemstack1, itemstack))) { // Spigot
+            if (!ItemStack.fastMatches(itemstack1, itemstack) || flag && (tickCount % 20 == 0 && !ItemStack.matches(itemstack1, itemstack))) { // Spigot
                 itemstack1 = itemstack == null ? null : itemstack.cloneItemStack();
                 this.b.set(i, itemstack1);
 
@@ -85,7 +89,8 @@ public abstract class Container {
                 }
             }
         }
-        tickCount++; // Spigot
+        if (flag) tickCount++; // Spigot
+        // Blossom end
 
     }
 
@@ -140,7 +145,7 @@ public abstract class Container {
             } else if (this.g == 1) {
                 Slot slot = i < this.c.size() ? this.c.get(i) : null; // Paper - Ensure drag in bounds
 
-                if (slot != null && a(slot, playerinventory.getCarried(), true) && slot.isAllowed(playerinventory.getCarried()) && playerinventory.getCarried().count > this.h.size() && this.b(slot)) {
+                if (slot != null && (!slot.hasItem() && playerinventory.getCarried() != null || slot.getItem().doMaterialsMatch(playerinventory.getCarried())) && slot.isAllowed(playerinventory.getCarried()) && playerinventory.getCarried().count > this.h.size() && this.b(slot)) { // Blossom - do not validate item while dragging
                     this.h.add(slot);
                 }
             } else if (this.g == 2) {
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index dc1ce7797..e144f7c9e 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -201,7 +201,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         
         // PaperSpigot start - Configurable container update tick rate
         if (--containerUpdateDelay <= 0) {
-            this.activeContainer.b();
+            this.activeContainer.broadcastDirtyItemUpdates(true); // Blossom
             containerUpdateDelay = world.paperSpigotConfig.containerUpdateTickRate;
         }
         // PaperSpigot end
diff --git a/src/main/java/net/minecraft/server/LoginListener.java b/src/main/java/net/minecraft/server/LoginListener.java
index 6e8d4d327..fca199853 100644
--- a/src/main/java/net/minecraft/server/LoginListener.java
+++ b/src/main/java/net/minecraft/server/LoginListener.java
@@ -164,7 +164,10 @@ public class LoginListener implements PacketLoginInListener, IUpdatePlayerListBo
     }
 
     public String d() {
-        return this.i != null ? this.i.toString() + " (" + this.networkManager.getSocketAddress().toString() + ")" : String.valueOf(this.networkManager.getSocketAddress());
+        // Blossom start
+        String socketAddress = networkManager == null ? null : (networkManager.getSocketAddress() == null ? null : networkManager.getSocketAddress().toString());
+        return this.i != null ? this.i.toString() + " (" + socketAddress + ")" : socketAddress;
+        // Blossom end
     }
 
     public void a(PacketLoginInStart packetlogininstart) {
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
index 22d7c2ab3..39486edc7 100644
--- a/src/main/java/net/minecraft/server/NBTTagCompound.java
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -52,6 +52,12 @@ public class NBTTagCompound extends NBTBase {
         }
     }
 
+    // Blossom start
+    public java.util.Collection<NBTBase> getStoredNBT() {
+        return map.values();
+    }
+    // Blossom end
+
     public Set<String> c() {
         return this.map.keySet();
     }
diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 56c6b77de..a85ea24e5 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -160,7 +160,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
             try {
                 this.i.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener[]) null));
             } finally {
-                this.j.writeLock().unlock();
+                this.j.writeLock().uPlnlock();
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/PacketDataSerializer.java b/src/main/java/net/minecraft/server/PacketDataSerializer.java
index 21ab829a6..a8926fb7a 100644
--- a/src/main/java/net/minecraft/server/PacketDataSerializer.java
+++ b/src/main/java/net/minecraft/server/PacketDataSerializer.java
@@ -32,6 +32,7 @@ public class PacketDataSerializer extends ByteBuf {
 
     // TacoSpigot start
     private final boolean allowLargePackets;
+    private long nbtByteLimit = me.samsuik.blossom.configuration.BlossomConfig.nbtByteLimit; // Blossom
     public PacketDataSerializer(ByteBuf bytebuf) {
         /*
          * By default, we limit the size of the received byte array to Short.MAX_VALUE, which is 31 KB.
@@ -185,7 +186,7 @@ public class PacketDataSerializer extends ByteBuf {
             return null;
         } else {
             this.readerIndex(i);
-            return NBTCompressedStreamTools.a((DataInput) (new ByteBufInputStream(this)), new NBTReadLimiter(2097152L));
+            return NBTCompressedStreamTools.a((DataInput) (new ByteBufInputStream(this)), new NBTReadLimiter(this.nbtByteLimit)); // Blossom - nbt byte limit
         }
     }
 
@@ -220,7 +221,11 @@ public class PacketDataSerializer extends ByteBuf {
             short short1 = this.readShort();
 
             itemstack = new ItemStack(Item.getById(short0), b0, short1);
+            // Blossom start - nbt tag byte limit
+            this.nbtByteLimit = me.samsuik.blossom.configuration.BlossomConfig.getNbtByteLimit(itemstack.getItem());
             itemstack.setTag(this.h());
+            this.nbtByteLimit = me.samsuik.blossom.configuration.BlossomConfig.nbtByteLimit;
+            // Blossom end
             // CraftBukkit start
             if (itemstack.getTag() != null) {
                 CraftItemStack.setItemMeta(itemstack, CraftItemStack.getItemMeta(itemstack));
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 2aa3efcda..8dbb11b0d 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -89,6 +89,7 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
     private double q;
     private boolean checkMovement = true;
     private boolean processedDisconnect; // CraftBukkit - added
+    private int lastInteractedSlot; // Blossom - prevent packet based crash exploits
 
     public PlayerConnection(MinecraftServer minecraftserver, NetworkManager networkmanager, EntityPlayer entityplayer) {
         this.minecraftServer = minecraftserver;
@@ -684,6 +685,18 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
         // CraftBukkit end
 
         ItemStack itemstack = this.player.inventory.getItemInHand();
+        // Blossom start - item verification
+        ItemStack clientItemStack = packetplayinblockplace.getItemStack();
+        if (!me.samsuik.blossom.utils.items.ItemValidation.validateItemStacks(itemstack, clientItemStack)) {
+            return;
+        }
+
+        // Keep track of the slot of the last book opened
+        if (itemstack != null) {
+            this.lastInteractedSlot = this.player.inventory.itemInHandIndex;
+        }
+        // Blossom end
+
         boolean flag = false;
         BlockPosition blockposition = packetplayinblockplace.a();
         EnumDirection enumdirection = EnumDirection.fromType1(packetplayinblockplace.getFace());
@@ -779,13 +792,13 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
 
         if (itemstack == null || itemstack.l() == 0) {
             this.player.g = true;
-            this.player.inventory.items[this.player.inventory.itemInHandIndex] = ItemStack.b(this.player.inventory.items[this.player.inventory.itemInHandIndex]);
+            // Blossom - unnecessary item clone?
             Slot slot = this.player.activeContainer.getSlot(this.player.inventory, this.player.inventory.itemInHandIndex);
 
             this.player.activeContainer.b();
             this.player.g = false;
             // CraftBukkit - TODO CHECK IF NEEDED -- new if structure might not need 'always'. Kept it in for now, but may be able to remove in future
-            if (!ItemStack.matches(this.player.inventory.getItemInHand(), packetplayinblockplace.getItemStack()) || always) {
+            if (!ItemStack.fastMatches(this.player.inventory.getItemInHand(), packetplayinblockplace.getItemStack()) || always) { // Blossom
                 this.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, slot.rawSlotIndex, this.player.inventory.getItemInHand()));
             }
         }
@@ -1440,6 +1453,7 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
         if (this.player.dead) return; // CraftBukkit
         PlayerConnectionUtils.ensureMainThread(packetplayinclosewindow, this, this.player.u());
 
+        // todo: is it possible to call this in vanilla with just your default inventory?
         CraftEventFactory.handleInventoryCloseEvent(this.player); // CraftBukkit
 
         this.player.p();
@@ -1448,6 +1462,11 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
     public void a(PacketPlayInWindowClick packetplayinwindowclick) {
         if (this.player.dead) return; // CraftBukkit
         PlayerConnectionUtils.ensureMainThread(packetplayinwindowclick, this, this.player.u());
+        // Blossom start - block window click in creative mode
+        if (player.activeContainer == player.defaultContainer && player.playerInteractManager.isCreative()) {
+            return;
+        }
+        // Blossom end
         this.player.resetIdleTimer();
         if (this.player.activeContainer.windowId == packetplayinwindowclick.a() && this.player.activeContainer.c(this.player)) {
             boolean cancelled = this.player.isSpectator(); // CraftBukkit - see below if
@@ -1466,6 +1485,12 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
                     return;
                 }
 
+                // Blossom start
+                if (!me.samsuik.blossom.utils.items.ItemValidation.isValidItemStack(packetplayinwindowclick.e())) {
+                    return;
+                }
+                // Blossom end
+
                 InventoryView inventory = this.player.activeContainer.getBukkitView();
                 SlotType type = CraftInventoryView.getSlotType(inventory, packetplayinwindowclick.b());
 
@@ -1582,7 +1607,7 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
                 } else if (packetplayinwindowclick.f() == 3) {
                     if (packetplayinwindowclick.c() == 2) {
                         click = ClickType.MIDDLE;
-                        if (packetplayinwindowclick.b() == -999) {
+                        if (packetplayinwindowclick.b() < 0) { // Blossom
                             action = InventoryAction.NOTHING;
                         } else {
                             Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
@@ -1796,12 +1821,18 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
                 }
             }
 
+            // Blossom start
+            if (!me.samsuik.blossom.utils.items.ItemValidation.isValidItemStack(itemstack)) {
+                return;
+            }
+            // Blossom end
+
             boolean flag1 = packetplayinsetcreativeslot.a() >= 1 && packetplayinsetcreativeslot.a() < 36 + PlayerInventory.getHotbarSize();
             // CraftBukkit - Add invalidItems check
             boolean flag2 = itemstack == null || itemstack.getItem() != null && (!invalidItems.contains(Item.getId(itemstack.getItem())) || !org.spigotmc.SpigotConfig.filterCreativeItems); // Spigot
             boolean flag3 = itemstack == null || itemstack.getData() >= 0 && itemstack.count <= 64 && itemstack.count > 0;
             // CraftBukkit start - Call click event
-            if (flag || (flag1 && !ItemStack.matches(this.player.defaultContainer.getSlot(packetplayinsetcreativeslot.a()).getItem(), packetplayinsetcreativeslot.getItemStack()))) { // Insist on valid slot
+            if (flag || (flag1 && !ItemStack.fastMatches(this.player.defaultContainer.getSlot(packetplayinsetcreativeslot.a()).getItem(), packetplayinsetcreativeslot.getItemStack()))) { // Blossom - use fast matches to avoid comparing nbt // Insist on valid slot
 
                 org.bukkit.entity.HumanEntity player = this.player.getBukkitEntity();
                 InventoryView inventory = new CraftInventoryView(player, player.getInventory(), this.player.defaultContainer);
@@ -1981,6 +2012,12 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
 
         try { // CraftBukkit
         if ("MC|BEdit".equals(packetplayincustompayload.a())) {
+            // Blossom start - item verification
+            ItemStack heldItem = player.inventory.getItemInHand();
+            if (heldItem != null && heldItem.getItem() != Items.WRITABLE_BOOK || lastInteractedSlot != player.inventory.itemInHandIndex) {
+                return;
+            }
+            // Blossom end
             packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.b()));
 
             try {
@@ -2013,6 +2050,12 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
 
             return;
         } else if ("MC|BSign".equals(packetplayincustompayload.a())) {
+            // Blossom start - item verification
+            ItemStack heldItem = player.inventory.getItemInHand();
+            if (heldItem != null && heldItem.getItem() != Items.WRITABLE_BOOK || lastInteractedSlot != player.inventory.itemInHandIndex) {
+                return;
+            }
+            // Blossom end
             packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.b()));
 
             try {
@@ -2144,10 +2187,17 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
         }
         // CraftBukkit start
         else if (packetplayincustompayload.a().equals("REGISTER")) {
+            // Blossom start - catch!
+            try {
             String channels = packetplayincustompayload.b().toString(com.google.common.base.Charsets.UTF_8);
             for (String channel : channels.split("\0")) {
                 getPlayer().addChannel(channel);
             }
+            } catch (Exception exception4) {
+                PlayerConnection.c.error("Registered too many channels", exception4);
+                this.disconnect("Registered too many channels!");
+            }
+            // Blossom end
         } else if (packetplayincustompayload.a().equals("UNREGISTER")) {
             String channels = packetplayincustompayload.b().toString(com.google.common.base.Charsets.UTF_8);
             for (String channel : channels.split("\0")) {
-- 
2.50.1

