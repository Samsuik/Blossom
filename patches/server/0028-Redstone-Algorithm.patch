From 011986096ae48cfa1ca9647ed38fc4aa454eb678 Mon Sep 17 00:00:00 2001
From: Samsuik <40902469+Samsuik@users.noreply.github.com>
Date: Sun, 25 Oct 2020 01:54:44 +0100
Subject: [PATCH] Redstone Algorithm


diff --git a/src/main/java/me/samsuik/blossom/blocks/redstone/ExtPandaRedstoneWire.java b/src/main/java/me/samsuik/blossom/blocks/redstone/ExtPandaRedstoneWire.java
new file mode 100644
index 000000000..348693892
--- /dev/null
+++ b/src/main/java/me/samsuik/blossom/blocks/redstone/ExtPandaRedstoneWire.java
@@ -0,0 +1,499 @@
+package me.samsuik.blossom.blocks.redstone;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import me.samsuik.blossom.configuration.BlossomConfig;
+import net.minecraft.server.*;
+import org.apache.commons.lang3.ArrayUtils;
+import org.bukkit.event.block.BlockRedstoneEvent;
+
+import java.util.*;
+
+/*
+ * Based on https://gist.github.com/Panda4994/70ed6d39c89396570e062e4404a8d518
+ *          https://www.spigotmc.org/resources/pandawire-1-8-8-1-15-2.41991/
+ * From: https://github.com/Samsuik/IonSpigot/blob/master/TacoSpigot-Server-Patches/0013-Implement-PandaWire.patch
+ *
+ * This is an optimised version of IonSpigot's port of PandaWire, the block update order may differ from the original.
+ */
+public class ExtPandaRedstoneWire extends BlockRedstoneWire {
+    /*
+    * I considered replacing the lists with LinkedHashSets for faster lookup,
+    * but an artificial test showed barely any difference in performance
+    */
+    /** Positions that need to be turned off **/
+    private final ArrayDeque<BlockPosition> turnOff = new ArrayDeque<>();
+    /** Positions that need to be checked to be turned on **/
+    private final ArrayDeque<BlockPosition> turnOn = new ArrayDeque<>();
+    /** Positions of wire that was updated already (Ordering determines update order and is therefore required!) **/
+    private final Set<BlockPosition> updatedRedstoneWire = Sets.newLinkedHashSet();
+
+    /** Ordered arrays of the facings; Needed for the update order.
+     *  I went with a vertical-first order here, but vertical last would work to.
+     *  However it should be avoided to update the vertical axis between the horizontal ones as this would cause unneeded directional behavior. **/
+    private static final EnumDirection[] facingsHorizontal = {EnumDirection.WEST, EnumDirection.EAST, EnumDirection.NORTH, EnumDirection.SOUTH};
+    private static final EnumDirection[] facingsVertical = {EnumDirection.DOWN, EnumDirection.UP};
+    private static final EnumDirection[] facings = ArrayUtils.addAll(facingsVertical, facingsHorizontal);
+
+    /** Offsets for all surrounding blocks that need to receive updates **/
+    private static final BaseBlockPosition[] surroundingBlocksOffset;
+    static {
+        Set<BaseBlockPosition> set = Sets.newLinkedHashSet();
+        for (EnumDirection facing : facings) {
+            set.add(facing.getPositionOffset());
+        }
+
+        Set<BaseBlockPosition> offsets = Sets.newLinkedHashSet(set);
+        for (BaseBlockPosition neighborPosition : offsets) {
+            for (BaseBlockPosition adjacentPosition : offsets) {
+                set.add(new BlockPosition(
+                        neighborPosition.getX() + adjacentPosition.getX(),
+                        neighborPosition.getY() + adjacentPosition.getY(),
+                        neighborPosition.getZ() + adjacentPosition.getZ()
+                ));
+            }
+        }
+
+        set.remove(BlockPosition.ZERO);
+        surroundingBlocksOffset = set.toArray(new BaseBlockPosition[0]);
+    }
+
+    private boolean canProvidePower = true;
+
+    public ExtPandaRedstoneWire() {
+        super();
+    }
+
+    private void updateSurroundingRedstone(World worldIn, BlockPosition pos, IBlockData iblockdata) {
+        // Recalculate the connected wires
+        calculateCurrentChanges(worldIn, pos, iblockdata);
+
+        // Set to collect all the updates, to only execute them once. Ordering required.
+        Set<BlockPosition> blocksNeedingUpdate = Sets.newLinkedHashSet();
+
+        // Add the needed updates
+        for (BlockPosition posi : updatedRedstoneWire) {
+            addBlocksNeedingUpdate(worldIn, posi, blocksNeedingUpdate);
+        }
+        // Add all other updates to keep known behaviors
+        // They are added in a backwards order because it preserves a commonly used behavior with the update order
+        Iterator<BlockPosition> it = Lists.newLinkedList(updatedRedstoneWire).descendingIterator();
+        while (it.hasNext()) {
+            addAllSurroundingBlocks(it.next(), blocksNeedingUpdate);
+        }
+        // Remove updates on the wires as they just were updated
+        blocksNeedingUpdate.removeAll(updatedRedstoneWire);
+        /* Avoid unnecessary updates on the just updated wires
+         * A huge scale test showed about 40% more ticks per second
+         * It's probably less in normal usage but likely still worth it
+         */
+        updatedRedstoneWire.clear();
+
+        // Execute updates
+        for (BlockPosition posi : blocksNeedingUpdate) {
+            worldIn.d(posi, this);
+        }
+    }
+
+    /**
+     * Turns on or off all connected wires
+     *
+     * @param worldIn	World
+     * @param position	Position of the wire that received the update
+     * @param state     Current state of this block
+     */
+    protected void calculateCurrentChanges(World worldIn, BlockPosition position, IBlockData state) {
+        // Turn off all connected wires first if needed
+        if (state.getBlock() == this) {
+            this.turnOff.add(position);
+        } else {
+            // In case this wire was removed, check the surrounding wires
+            checkSurroundingWires(worldIn, position, 0);
+        }
+
+        int blocksUnpowered = 0;
+        while (!turnOff.isEmpty()) {
+            BlockPosition pos = turnOff.poll();
+            state = worldIn.getType(pos);
+            int oldPower = state.get(POWER);
+            int blockPower = pos == position ? getConnectedBlockPower(worldIn, pos) : 0;
+            int wirePower = getSurroundingWirePower(worldIn, pos);
+            // Lower the strength as it moved a block
+            --wirePower;
+            int newPower = Math.max(blockPower, wirePower);
+
+            // Power lowered?
+            if (newPower < oldPower) {
+                // After unpowering try to reactivate this block
+                turnOn.addFirst(pos);
+                blocksUnpowered++;
+                // Set all the way to off for now, because wires that were powered by this need to update first
+                setWireState(worldIn, pos, state, 0);
+                // Power rose?
+            } else if (newPower > oldPower) {
+                // Set new Power
+                setWireState(worldIn, pos, state, newPower);
+            }
+
+            // Check if surrounding wires need to change based on the current/new state and add them to the lists
+            if (newPower != oldPower) {
+                checkSurroundingWires(worldIn, pos, wirePower);
+            }
+        }
+
+        while (!turnOn.isEmpty()) {
+            BlockPosition pos = turnOn.poll();
+            state = worldIn.getType(pos);
+            int oldPower = state.get(POWER);
+            int blockPower = blocksUnpowered-- > 0 || pos == position ? getConnectedBlockPower(worldIn, pos) : 0;
+            int wirePower = getSurroundingWirePower(worldIn, pos);
+            // Lower the strength as it moved a block
+            wirePower--;
+            int newPower = Math.max(blockPower, wirePower);
+
+            if (oldPower != newPower) {
+                BlockRedstoneEvent event = new BlockRedstoneEvent(
+                        worldIn.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()),
+                        oldPower,
+                        newPower);
+                worldIn.getServer().getPluginManager().callEvent(event);
+                newPower = event.getNewCurrent();
+            }
+
+            if (newPower > oldPower) {
+                setWireState(worldIn, pos, state, newPower);
+            }
+
+            // Check if surrounding wires need to change based on the current/new state and add them to the lists
+            if (newPower != oldPower) {
+                checkSurroundingWires(worldIn, pos, wirePower + 1);
+            }
+        }
+
+        turnOff.clear();
+    }
+    
+    protected int getConnectedBlockPower(World world, BlockPosition pos) {
+        this.canProvidePower = false;
+        int blockPower = 0;
+
+        for (EnumDirection facing : facings) {
+            BlockPosition offsetPos = pos.shift(facing);
+            IBlockData state = world.getType(offsetPos);
+            Block block = state.getBlock();
+
+            if (block.isOccluding()) {
+                blockPower = Math.max(getBlockPower(world, offsetPos, facing), blockPower);
+            } else {
+                blockPower = Math.max(block.a(world, offsetPos, state, facing), blockPower);
+            }
+
+            if (blockPower == 15) {
+                break;
+            }
+        }
+
+        this.canProvidePower = true;
+        return blockPower;
+    }
+
+    protected int getBlockPower(World world, BlockPosition blockposition, EnumDirection from) {
+        EnumDirection opposite = from.opposite();
+
+        int blockPower = 0;
+        for (int i1 = 0; i1 < facings.length && blockPower < 15; i1++) {
+            EnumDirection facing = facings[i1];
+            if (facing != opposite && (facing != EnumDirection.UP || from == EnumDirection.UP) && (facing != EnumDirection.DOWN || from != EnumDirection.UP)) {
+                blockPower = Math.max(world.getBlockPower(blockposition.shift(facing), facing), blockPower);
+            }
+        }
+
+        return blockPower;
+    }
+
+    /**
+     * Checks if an wire needs to be marked for update depending on the power next to it
+     *
+     * @author panda
+     *
+     * @param worldIn       World
+     * @param pos		    Position of the wire that might need to change
+     * @param otherPower	Power of the wire next to it
+     */
+    protected void addWireToList(World worldIn, BlockPosition pos, int otherPower) {
+        addWireToList(worldIn.getType(pos), pos, otherPower);
+    }
+    protected void addWireToList(IBlockData state, BlockPosition pos, int otherPower) {
+        if (state.getBlock() == this) {
+            int power = state.get(POWER);
+            // Could get powered stronger by the neighbor?
+            if (power < otherPower - 1 && !turnOn.contains(pos)) {
+                // Mark for turn on check.
+                turnOn.add(pos);
+            }
+            // Should have powered the neighbor? Probably was powered by it and is in turn off phase.
+            if (power >= otherPower && power != 15 && !turnOff.contains(pos)) {
+                // Mark for turn off check.
+                turnOff.add(pos);
+            }
+        }
+    }
+
+    /**
+     * Checks if the wires around need to get updated depending on this wires state.
+     * Checks all wires below before the same layer before on top to keep
+     * some more rotational symmetry around the y-axis.
+     *
+     * @author panda
+     *
+     * @param worldIn		World
+     * @param pos			Position of the wire
+     */
+    protected void checkSurroundingWires(World worldIn, BlockPosition pos, int wirePower) {
+        IBlockData state = worldIn.getType(pos);
+        int ownPower = wirePower;
+        if (state.getBlock() == Blocks.REDSTONE_WIRE) {
+            ownPower = Math.max(state.get(POWER), wirePower);
+        }
+
+        Block above = worldIn.getType(pos.up()).getBlock();
+        Block below = worldIn.getType(pos.down()).getBlock();
+        boolean solidAbove = above.isOccluding();
+        boolean solidBelow = below.isOccluding();
+
+        for (EnumDirection facingHorizontal : facingsHorizontal) {
+            BlockPosition posShifted = pos.shift(facingHorizontal);
+            state = worldIn.getType(posShifted);
+            this.addWireToList(state, posShifted, ownPower);
+
+            if (!solidAbove && (state.getBlock().u() || BlossomConfig.optimisedGlowstone && state.getBlock() == Blocks.GLOWSTONE)) {
+                this.addWireToList(worldIn, posShifted.up(), ownPower);
+            }
+            if (solidBelow && !state.getBlock().isOccluding()) {
+                this.addWireToList(worldIn, posShifted.down(), ownPower);
+            }
+        }
+    }
+
+    /**
+     * Gets the maximum power of the surrounding wires
+     *
+     * @author panda
+     *
+     * @param worldIn	World
+     * @param pos		Position of the asking wire
+     * @return			The maximum power of the wires that could power the wire at pos
+     */
+    private int getSurroundingWirePower(World worldIn, BlockPosition pos) {
+        int wirePower = 0;
+        for (EnumDirection enumfacing : EnumDirection.EnumDirectionLimit.HORIZONTAL) {
+            BlockPosition offsetPos = pos.shift(enumfacing);
+            IBlockData iblockdata = worldIn.getType(offsetPos);
+            boolean occluding = iblockdata.getBlock().isOccluding();
+            // Wires on the same layer
+            wirePower = this.getPower(iblockdata, wirePower);
+
+            // Block below the wire need to be solid (Upwards diode of slabs/stairs/glowstone) and no block should cut the wire
+            if (occluding && !worldIn.getType(pos.up()).getBlock().isOccluding()) {
+                wirePower = this.getPower(worldIn, offsetPos.up(), wirePower);
+            // Only get from power below if no block is cutting the wire
+            } else if (!occluding) {
+                wirePower = this.getPower(worldIn, offsetPos.down(), wirePower);
+            }
+        }
+        return wirePower;
+    }
+
+    /**
+     * Adds all blocks that need to receive an update from a redstone change in this position.
+     * This means only blocks that actually could change.
+     *
+     * @author panda
+     *
+     * @param worldIn	World
+     * @param pos		Position of the wire
+     * @param set		Set to add the update positions too
+     */
+    private void addBlocksNeedingUpdate(World worldIn, BlockPosition pos, Set<BlockPosition> set) {
+        Set<EnumDirection> connectedSides = getSidesToPower(worldIn, pos);
+        // Add the blocks next to the wire first (closest first order)
+        for (EnumDirection facing : facings) {
+            BlockPosition offsetPos = pos.shift(facing);
+            IBlockData state = worldIn.getType(offsetPos);
+            // canConnectTo() is not the nicest solution here as it returns true for e.g. the front of a repeater
+            // canBlockBePowereFromSide catches these cases
+            boolean flag = connectedSides.contains(facing.opposite()) || facing == EnumDirection.DOWN;
+            if (flag || (facing.k().c() && a(state, facing))) {
+                if (canBlockBePoweredFromSide(state, facing, true)) set.add(offsetPos);
+            }
+
+            // Later add blocks around the surrounding blocks that get powered
+            if (flag && state.getBlock().isOccluding()) {
+                for (EnumDirection facing1 : facings) {
+                    if (canBlockBePoweredFromSide(worldIn.getType(offsetPos.shift(facing1)), facing1, false)) set.add(offsetPos.shift(facing1));
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks if a block can get powered from a side.
+     * This behavior would better be implemented per block type as follows:
+     *  - return false as default. (blocks that are not affected by redstone don't need to be updated, it doesn't really hurt if they are either)
+     *  - return true for all blocks that can get powered from all side and change based on it (doors, fence gates, trap doors, note blocks, lamps, dropper, hopper, TNT, rails, possibly more)
+     *  - implement own logic for pistons, repeaters, comparators and redstone torches
+     *  The current implementation was chosen to keep everything in one class.
+     *
+     *  Why is this extra check needed?
+     *  1. It makes sure that many old behaviors still work (QC + Pistons).
+     *  2. It prevents updates from "jumping".
+     *     Or rather it prevents this wire to update a block that would get powered by the next one of the same line.
+     *     This is to prefer as it makes understanding the update order of the wire really easy. The signal "travels" from the power source.
+     *
+     * @author panda
+     *
+     * @param state		State of the block
+     * @param side		Side from which it gets powered
+     * @param isWire		True if it's powered by a wire directly, False if through a block
+     * @return			True if the block can change based on the power level it gets on the given side, false otherwise
+     */
+    private boolean canBlockBePoweredFromSide(IBlockData state, EnumDirection side, boolean isWire) {
+        Block block = state.getBlock();
+        if (block == Blocks.AIR) return false;
+        if (block instanceof BlockPiston && state.get(BlockPiston.FACING) == side.opposite()) return false;
+        if (block instanceof BlockDiodeAbstract && state.get(BlockDiodeAbstract.FACING) != side.opposite())
+            return isWire && block instanceof BlockRedstoneComparator && state.get(BlockRedstoneComparator.FACING).k() != side.k() && side.k().c();
+        return !(state.getBlock() instanceof BlockRedstoneTorch) || (!isWire && state.get(BlockRedstoneTorch.FACING) == side);
+    }
+
+    /**
+     * Creates a list of all horizontal sides that can get powered by a wire.
+     * The list is ordered the same as the facingsHorizontal.
+     *
+     * @param worldIn	World
+     * @param pos		Position of the wire
+     * @return			List of all facings that can get powered by this wire
+     */
+    private Set<EnumDirection> getSidesToPower(World worldIn, BlockPosition pos) {
+        Set<EnumDirection> retval = Sets.newHashSet();
+        for (EnumDirection facing : facingsHorizontal) {
+            if (this.isPowerSourceAt(worldIn, pos, facing)) {
+                retval.add(facing);
+            }
+        }
+        if (retval.isEmpty()) return Sets.newHashSet(facingsHorizontal);
+        boolean northsouth = retval.contains(EnumDirection.NORTH) || retval.contains(EnumDirection.SOUTH);
+        boolean eastwest = retval.contains(EnumDirection.EAST) || retval.contains(EnumDirection.WEST);
+        if (northsouth) {
+            retval.remove(EnumDirection.EAST);
+            retval.remove(EnumDirection.WEST);
+        }
+        if (eastwest) {
+            retval.remove(EnumDirection.NORTH);
+            retval.remove(EnumDirection.SOUTH);
+        }
+        return retval;
+    }
+
+    private boolean canSidePower(World worldIn, BlockPosition pos, EnumDirection side) {
+        EnumDirection.EnumAxis axis = side.e().k();
+        for (EnumDirection facing : facingsHorizontal) {
+            if (facing.k() == axis && this.isPowerSourceAt(worldIn, pos, facing)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Adds all surrounding positions to a set.
+     * This is the neighbor blocks, as well as their neighbors
+     *
+     * @param pos
+     * @param set
+     */
+    private void addAllSurroundingBlocks(BlockPosition pos, Set<BlockPosition> set) {
+        for (BaseBlockPosition vect : surroundingBlocksOffset) {
+            set.add(pos.a(vect));
+        }
+    }
+
+    /**
+     * Sets the block state of a wire with a new power level and marks for updates
+     *
+     * @author panda
+     *
+     * @param worldIn	World
+     * @param pos		Position at which the state needs to be set
+     * @param state		Old state
+     * @param power		Power it should get set to
+     */
+    private void setWireState(World worldIn, BlockPosition pos, IBlockData state, int power) {
+        state = state.set(POWER, power);
+        worldIn.setTypeAndData(pos, state, 2);
+        updatedRedstoneWire.add(pos);
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.updateSurroundingRedstone(world, blockposition, world.getType(blockposition));
+
+        for (EnumDirection enumdirection : EnumDirection.values()) {
+            world.applyPhysics(blockposition.shift(enumdirection), this);
+        }
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        for (EnumDirection enumdirection : EnumDirection.values()) {
+            world.applyPhysics(blockposition.shift(enumdirection), this);
+        }
+
+        this.updateSurroundingRedstone(world, blockposition, world.getType(blockposition));
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        if (this.canPlace(world, blockposition)) {
+            this.updateSurroundingRedstone(world, blockposition, iblockdata);
+        } else {
+            this.b(world, blockposition, iblockdata, 0);
+            world.setAir(blockposition);
+        }
+    }
+
+    @Override
+    public int getPower(World world, BlockPosition blockposition, int i) {
+        return getPower(world.getType(blockposition), i);
+    }
+
+    protected final int getPower(IBlockData state, int power) {
+        if (state.getBlock() != Blocks.REDSTONE_WIRE) {
+            return power;
+        }
+        int j = state.get(BlockRedstoneWire.POWER);
+        return Math.max(j, power);
+    }
+
+    public int a(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata, EnumDirection enumdirection) {
+        if (!this.canProvidePower) {
+            return 0;
+        } else {
+            int i = iblockdata.get(BlockRedstoneWire.POWER);
+            if (i == 0 || enumdirection == EnumDirection.DOWN) { // md_5 change? This isn't in the original.
+                return 0;
+            } else if (enumdirection == EnumDirection.UP) {
+                return i;
+            } else {
+                return this.canSidePower((World) iblockaccess, blockposition, enumdirection) ? i : 0;
+            }
+        }
+    }
+
+    private boolean isPowerSourceAt(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        BlockPosition blockpos = blockposition.shift(enumdirection);
+        IBlockData iblockdata = iblockaccess.getType(blockpos);
+        Block block = iblockdata.getBlock();
+        boolean flag = block.isOccluding();
+        boolean flag1 = iblockaccess.getType(blockposition.up()).getBlock().isOccluding();
+        return !flag1 && flag && e(iblockaccess, blockpos.up()) || (a(iblockdata, enumdirection) || (block == Blocks.POWERED_REPEATER && iblockdata.get(BlockDiodeAbstract.FACING) == enumdirection || !flag && e(iblockaccess, blockpos.down())));
+    }
+
+}
diff --git a/src/main/java/me/samsuik/blossom/blocks/redstone/PandaRedstoneWire.java b/src/main/java/me/samsuik/blossom/blocks/redstone/PandaRedstoneWire.java
new file mode 100644
index 000000000..e2e52762d
--- /dev/null
+++ b/src/main/java/me/samsuik/blossom/blocks/redstone/PandaRedstoneWire.java
@@ -0,0 +1,442 @@
+package me.samsuik.blossom.blocks.redstone;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import me.samsuik.blossom.configuration.BlossomConfig;
+import net.minecraft.server.*;
+import org.apache.commons.lang3.ArrayUtils;
+import org.bukkit.event.block.BlockRedstoneEvent;
+
+import java.util.*;
+
+/*
+ * Based on https://gist.github.com/Panda4994/70ed6d39c89396570e062e4404a8d518
+ *          https://www.spigotmc.org/resources/pandawire-1-8-8-1-15-2.41991/
+ *
+ * Mainly based on a decompiled version of PandaWire, with comments and structure
+ * from the original copied over. This get rid of any errors the decompiler made.
+ *
+ * On top of that theres additional optimisations in places.
+ */
+public class PandaRedstoneWire extends BlockRedstoneWire {
+    /*
+    * I considered replacing the lists with LinkedHashSets for faster lookup,
+    * but an artificial test showed barely any difference in performance
+    */
+    /** Positions that need to be turned off **/
+    private ArrayDeque<BlockPosition> turnOff = new ArrayDeque<>();
+    /** Positions that need to be checked to be turned on **/
+    private ArrayDeque<BlockPosition> turnOn = new ArrayDeque<>();
+    /** Positions of wire that was updated already (Ordering determines update order and is therefore required!) **/
+    private final Set<BlockPosition> updatedRedstoneWire = Sets.newLinkedHashSet();
+
+    /** Ordered arrays of the facings; Needed for the update order.
+     *  I went with a vertical-first order here, but vertical last would work to.
+     *  However it should be avoided to update the vertical axis between the horizontal ones as this would cause unneeded directional behavior. **/
+    private static final EnumDirection[] facingsHorizontal = {EnumDirection.WEST, EnumDirection.EAST, EnumDirection.NORTH, EnumDirection.SOUTH};
+    private static final EnumDirection[] facingsVertical = {EnumDirection.DOWN, EnumDirection.UP};
+    private static final EnumDirection[] facings = ArrayUtils.addAll(facingsVertical, facingsHorizontal);
+
+    /** Offsets for all surrounding blocks that need to receive updates **/
+    private static final BaseBlockPosition[] surroundingBlocksOffset;
+    static {
+        Set<BaseBlockPosition> set = Sets.newLinkedHashSet();
+        for (EnumDirection facing : facings) {
+            set.add(facing.getPositionOffset());
+        }
+
+        Set<BaseBlockPosition> offsets = Sets.newLinkedHashSet(set);
+        for (BaseBlockPosition neighborPosition : offsets) {
+            for (BaseBlockPosition adjacentPosition : offsets) {
+                set.add(new BlockPosition(
+                        neighborPosition.getX() + adjacentPosition.getX(),
+                        neighborPosition.getY() + adjacentPosition.getY(),
+                        neighborPosition.getZ() + adjacentPosition.getZ()
+                ));
+            }
+        }
+
+        set.remove(BlockPosition.ZERO);
+        surroundingBlocksOffset = set.toArray(new BaseBlockPosition[0]);
+    }
+
+    private boolean canProvidePower = true;
+
+    public PandaRedstoneWire() {
+        super();
+    }
+
+    private void updateSurroundingRedstone(World worldIn, BlockPosition pos, IBlockData iblockdata) {
+        // Recalculate the connected wires
+        calculateCurrentChanges(worldIn, pos, iblockdata);
+
+        // Set to collect all the updates, to only execute them once. Ordering required.
+        Set<BlockPosition> blocksNeedingUpdate = Sets.newLinkedHashSet();
+
+        // Add the needed updates
+        for (BlockPosition posi : updatedRedstoneWire) {
+            addBlocksNeedingUpdate(worldIn, posi, blocksNeedingUpdate);
+        }
+        // Add all other updates to keep known behaviors
+        // They are added in a backwards order because it preserves a commonly used behavior with the update order
+        Iterator<BlockPosition> it = Lists.newLinkedList(updatedRedstoneWire).descendingIterator();
+        while (it.hasNext()) {
+            addAllSurroundingBlocks(it.next(), blocksNeedingUpdate);
+        }
+        // Remove updates on the wires as they just were updated
+        blocksNeedingUpdate.removeAll(updatedRedstoneWire);
+        /* Avoid unnecessary updates on the just updated wires
+         * A huge scale test showed about 40% more ticks per second
+         * It's probably less in normal usage but likely still worth it
+         */
+        updatedRedstoneWire.clear();
+
+        // Execute updates
+        for (BlockPosition posi : blocksNeedingUpdate) {
+            worldIn.d(posi, this);
+        }
+    }
+
+    /**
+     * Turns on or off all connected wires
+     *
+     * @param worldIn	World
+     * @param position	Position of the wire that received the update
+     * @param state     Current state of this block
+     */
+    protected void calculateCurrentChanges(World worldIn, BlockPosition position, IBlockData state) {
+        // Turn off all connected wires first if needed
+        if (state.getBlock() == this) {
+            this.turnOff.add(position);
+        } else {
+            // In case this wire was removed, check the surrounding wires
+            checkSurroundingWires(worldIn, position);
+        }
+
+        while (!turnOff.isEmpty()) {
+            BlockPosition pos = turnOff.poll();
+            state = worldIn.getType(pos);
+            int oldPower = state.get(POWER);
+            this.canProvidePower = false;
+            int blockPower = worldIn.A(pos);
+            this.canProvidePower = true;
+            int wirePower = getSurroundingWirePower(worldIn, pos);
+            // Lower the strength as it moved a block
+            --wirePower;
+            int newPower = Math.max(blockPower, wirePower);
+
+            // Power lowered?
+            if (newPower < oldPower) {
+                // If it's still powered by a direct source (but weaker) mark for turn on
+                if (blockPower > 0 && !turnOn.contains(pos)) {
+                    turnOn.add(pos);
+                }
+                // Set all the way to off for now, because wires that were powered by this need to update first
+                setWireState(worldIn, pos, state, 0);
+                // Power rose?
+            } else if (newPower > oldPower) {
+                // Set new Power
+                setWireState(worldIn, pos, state, newPower);
+            }
+            // Check if surrounding wires need to change based on the current/new state and add them to the lists
+            checkSurroundingWires(worldIn, pos);
+        }
+
+        while (!turnOn.isEmpty()) {
+            BlockPosition pos = turnOn.poll();
+            state = worldIn.getType(pos);
+            int oldPower = state.get(POWER);
+            this.canProvidePower = false;
+            int blockPower = worldIn.A(pos);
+            this.canProvidePower = true;
+            int wirePower = getSurroundingWirePower(worldIn, pos);
+            // Lower the strength as it moved a block
+            wirePower--;
+            int newPower = Math.max(blockPower, wirePower);
+
+            if (oldPower != newPower) {
+                BlockRedstoneEvent event = new BlockRedstoneEvent(
+                        worldIn.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()),
+                        oldPower,
+                        newPower);
+                worldIn.getServer().getPluginManager().callEvent(event);
+                newPower = event.getNewCurrent();
+            }
+
+            if (newPower > oldPower) {
+                setWireState(worldIn, pos, state, newPower);
+            }
+            // Check if surrounding wires need to change based on the current/new state and add them to the lists
+            checkSurroundingWires(worldIn, pos);
+        }
+
+        turnOff.clear();
+    }
+
+    /**
+     * Checks if an wire needs to be marked for update depending on the power next to it
+     *
+     * @author panda
+     *
+     * @param worldIn       World
+     * @param pos		    Position of the wire that might need to change
+     * @param otherPower	Power of the wire next to it
+     */
+    protected void addWireToList(World worldIn, BlockPosition pos, int otherPower) {
+        IBlockData state = worldIn.getType(pos);
+        if (state.getBlock() == this) {
+            int power = state.get(POWER);
+            // Could get powered stronger by the neighbor?
+            if (power < otherPower - 1 && !turnOn.contains(pos)) {
+                // Mark for turn on check.
+                turnOn.add(pos);
+            }
+            // Should have powered the neighbor? Probably was powered by it and is in turn off phase.
+            if (power > otherPower && !turnOff.contains(pos)) {
+                // Mark for turn off check.
+                turnOff.add(pos);
+            }
+        }
+    }
+
+    /**
+     * Checks if the wires around need to get updated depending on this wires state.
+     * Checks all wires below before the same layer before on top to keep
+     * some more rotational symmetry around the y-axis.
+     *
+     * @author panda
+     *
+     * @param worldIn		World
+     * @param pos			Position of the wire
+     */
+    protected void checkSurroundingWires(World worldIn, BlockPosition pos) {
+        IBlockData state = worldIn.getType(pos);
+        int ownPower = 0;
+        if (state.getBlock() == Blocks.REDSTONE_WIRE) {
+            ownPower = state.get(POWER);
+        }
+        // Check wires on the same layer first as they appear closer to the wire
+        for (EnumDirection facingHorizontal : facingsHorizontal) {
+            this.addWireToList(worldIn, pos.shift(facingHorizontal), ownPower);
+        }
+        for (EnumDirection facingVertical : facingsVertical) {
+            BlockPosition offsetPos = pos.shift(facingVertical);
+            Block block = worldIn.getType(offsetPos).getBlock();
+            boolean solidBlock = block.u();
+            for (EnumDirection facingHorizontal : facingsHorizontal) {
+                // wire can travel upwards if the block on top doesn't cut the wire (is non-solid)
+                // it can travel down if the block below is solid and the block "diagonal" doesn't cut off the wire (is non-solid)
+                if (facingVertical == EnumDirection.UP && (!solidBlock || /* This can improve glowstone wiring up to 2.5x but can change the update order */ BlossomConfig.optimisedGlowstone && block == Blocks.GLOWSTONE) || facingVertical == EnumDirection.DOWN && solidBlock && !worldIn.getType(offsetPos.shift(facingHorizontal)).getBlock().isOccluding()) {
+                    this.addWireToList(worldIn, offsetPos.shift(facingHorizontal), ownPower);
+                }
+            }
+        }
+    }
+
+    /**
+     * Gets the maximum power of the surrounding wires
+     *
+     * @author panda
+     *
+     * @param worldIn	World
+     * @param pos		Position of the asking wire
+     * @return			The maximum power of the wires that could power the wire at pos
+     */
+    private int getSurroundingWirePower(World worldIn, BlockPosition pos) {
+        int wirePower = 0;
+        for (EnumDirection enumfacing : EnumDirection.EnumDirectionLimit.HORIZONTAL) {
+            BlockPosition offsetPos = pos.shift(enumfacing);
+            IBlockData iblockdata = worldIn.getType(offsetPos);
+            boolean occluding = iblockdata.getBlock().isOccluding();
+            // Wires on the same layer
+            wirePower = this.getPower(iblockdata, wirePower);
+
+            // Block below the wire need to be solid (Upwards diode of slabs/stairs/glowstone) and no block should cut the wire
+            if (occluding && !worldIn.getType(pos.up()).getBlock().isOccluding()) {
+                wirePower = this.getPower(worldIn, offsetPos.up(), wirePower);
+            // Only get from power below if no block is cutting the wire
+            } else if (!occluding) {
+                wirePower = this.getPower(worldIn, offsetPos.down(), wirePower);
+            }
+        }
+        return wirePower;
+    }
+
+    /**
+     * Adds all blocks that need to receive an update from a redstone change in this position.
+     * This means only blocks that actually could change.
+     *
+     * @author panda
+     *
+     * @param worldIn	World
+     * @param pos		Position of the wire
+     * @param set		Set to add the update positions too
+     */
+    private void addBlocksNeedingUpdate(World worldIn, BlockPosition pos, Set<BlockPosition> set) {
+        Set<EnumDirection> connectedSides = getSidesToPower(worldIn, pos);
+        // Add the blocks next to the wire first (closest first order)
+        for (EnumDirection facing : facings) {
+            BlockPosition offsetPos = pos.shift(facing);
+            IBlockData state = worldIn.getType(offsetPos);
+            // canConnectTo() is not the nicest solution here as it returns true for e.g. the front of a repeater
+            // canBlockBePowereFromSide catches these cases
+            boolean flag = connectedSides.contains(facing.opposite()) || facing == EnumDirection.DOWN;
+            if (flag || (facing.k().c() && a(state, facing))) {
+                if (canBlockBePoweredFromSide(state, facing, true)) set.add(offsetPos);
+            }
+
+            // Later add blocks around the surrounding blocks that get powered
+            if (flag && state.getBlock().isOccluding()) {
+                for (EnumDirection facing1 : facings) {
+                    if (canBlockBePoweredFromSide(worldIn.getType(offsetPos.shift(facing1)), facing1, false)) set.add(offsetPos.shift(facing1));
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks if a block can get powered from a side.
+     * This behavior would better be implemented per block type as follows:
+     *  - return false as default. (blocks that are not affected by redstone don't need to be updated, it doesn't really hurt if they are either)
+     *  - return true for all blocks that can get powered from all side and change based on it (doors, fence gates, trap doors, note blocks, lamps, dropper, hopper, TNT, rails, possibly more)
+     *  - implement own logic for pistons, repeaters, comparators and redstone torches
+     *  The current implementation was chosen to keep everything in one class.
+     *
+     *  Why is this extra check needed?
+     *  1. It makes sure that many old behaviors still work (QC + Pistons).
+     *  2. It prevents updates from "jumping".
+     *     Or rather it prevents this wire to update a block that would get powered by the next one of the same line.
+     *     This is to prefer as it makes understanding the update order of the wire really easy. The signal "travels" from the power source.
+     *
+     * @author panda
+     *
+     * @param state		State of the block
+     * @param side		Side from which it gets powered
+     * @param isWire		True if it's powered by a wire directly, False if through a block
+     * @return			True if the block can change based on the power level it gets on the given side, false otherwise
+     */
+    private boolean canBlockBePoweredFromSide(IBlockData state, EnumDirection side, boolean isWire) {
+        Block block = state.getBlock();
+        if (block == Blocks.AIR) return false;
+        if (block instanceof BlockPiston && state.get(BlockPiston.FACING) == side.opposite()) return false;
+        if (block instanceof BlockDiodeAbstract && state.get(BlockDiodeAbstract.FACING) != side.opposite())
+            return isWire && block instanceof BlockRedstoneComparator && state.get(BlockRedstoneComparator.FACING).k() != side.k() && side.k().c();
+        return !(state.getBlock() instanceof BlockRedstoneTorch) || (!isWire && state.get(BlockRedstoneTorch.FACING) == side);
+    }
+
+    /**
+     * Creates a list of all horizontal sides that can get powered by a wire.
+     * The list is ordered the same as the facingsHorizontal.
+     *
+     * @param worldIn	World
+     * @param pos		Position of the wire
+     * @return			List of all facings that can get powered by this wire
+     */
+    private Set<EnumDirection> getSidesToPower(World worldIn, BlockPosition pos) {
+        Set<EnumDirection> retval = Sets.newHashSet();
+        for (EnumDirection facing : facingsHorizontal) {
+            if (this.isPowerSourceAt(worldIn, pos, facing)) {
+                retval.add(facing);
+            }
+        }
+        if (retval.isEmpty()) return Sets.newHashSet(facingsHorizontal);
+        boolean northsouth = retval.contains(EnumDirection.NORTH) || retval.contains(EnumDirection.SOUTH);
+        boolean eastwest = retval.contains(EnumDirection.EAST) || retval.contains(EnumDirection.WEST);
+        if (northsouth) {
+            retval.remove(EnumDirection.EAST);
+            retval.remove(EnumDirection.WEST);
+        }
+        if (eastwest) {
+            retval.remove(EnumDirection.NORTH);
+            retval.remove(EnumDirection.SOUTH);
+        }
+        return retval;
+    }
+
+    /**
+     * Adds all surrounding positions to a set.
+     * This is the neighbor blocks, as well as their neighbors
+     *
+     * @param pos
+     * @param set
+     */
+    private void addAllSurroundingBlocks(BlockPosition pos, Set<BlockPosition> set) {
+        for (BaseBlockPosition vect : surroundingBlocksOffset) {
+            set.add(pos.a(vect));
+        }
+    }
+
+    /**
+     * Sets the block state of a wire with a new power level and marks for updates
+     *
+     * @author panda
+     *
+     * @param worldIn	World
+     * @param pos		Position at which the state needs to be set
+     * @param state		Old state
+     * @param power		Power it should get set to
+     */
+    private void setWireState(World worldIn, BlockPosition pos, IBlockData state, int power) {
+        state = state.set(POWER, power);
+        worldIn.setTypeAndData(pos, state, 2);
+        updatedRedstoneWire.add(pos);
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.updateSurroundingRedstone(world, blockposition, world.getType(blockposition));
+
+        for (EnumDirection enumdirection : EnumDirection.values()) {
+            world.applyPhysics(blockposition.shift(enumdirection), this);
+        }
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        for (EnumDirection enumdirection : EnumDirection.values()) {
+            world.applyPhysics(blockposition.shift(enumdirection), this);
+        }
+
+        this.updateSurroundingRedstone(world, blockposition, world.getType(blockposition));
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        if (this.canPlace(world, blockposition)) {
+            this.updateSurroundingRedstone(world, blockposition, iblockdata);
+        } else {
+            this.b(world, blockposition, iblockdata, 0);
+            world.setAir(blockposition);
+        }
+    }
+
+    protected final int getPower(IBlockData state, int power) {
+        if (state.getBlock() != Blocks.REDSTONE_WIRE) {
+            return power;
+        }
+        int j = state.get(BlockRedstoneWire.POWER);
+        return Math.max(j, power);
+    }
+
+    public int a(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata, EnumDirection enumdirection) {
+        if (!this.canProvidePower) {
+            return 0;
+        } else {
+            int i = iblockdata.get(BlockRedstoneWire.POWER);
+            if (i == 0) { // md_5 change? This isn't in the original.
+                return 0;
+            } else if (enumdirection == EnumDirection.UP) {
+                return i;
+            } else {
+                return this.getSidesToPower((World) iblockaccess, blockposition).contains(enumdirection) ? i : 0;
+            }
+        }
+    }
+
+    private boolean isPowerSourceAt(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        BlockPosition blockpos = blockposition.shift(enumdirection);
+        IBlockData iblockdata = iblockaccess.getType(blockpos);
+        Block block = iblockdata.getBlock();
+        boolean flag = block.isOccluding();
+        boolean flag1 = iblockaccess.getType(blockposition.up()).getBlock().isOccluding();
+        return !flag1 && flag && e(iblockaccess, blockpos.up()) || (a(iblockdata, enumdirection) || (block == Blocks.POWERED_REPEATER && iblockdata.get(BlockDiodeAbstract.FACING) == enumdirection || !flag && e(iblockaccess, blockpos.down())));
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/me/samsuik/blossom/blocks/redstone/RedstoneAlgorithm.java b/src/main/java/me/samsuik/blossom/blocks/redstone/RedstoneAlgorithm.java
new file mode 100644
index 000000000..8e73701e6
--- /dev/null
+++ b/src/main/java/me/samsuik/blossom/blocks/redstone/RedstoneAlgorithm.java
@@ -0,0 +1,7 @@
+package me.samsuik.blossom.blocks.redstone;
+
+public enum RedstoneAlgorithm {
+    VANILLA,
+    PANDAWIRE,
+    PANDAWIRE_EX,
+}
diff --git a/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java b/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
index f6115a88a..0f75f45ad 100644
--- a/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
+++ b/src/main/java/me/samsuik/blossom/configuration/BlossomConfig.java
@@ -212,4 +212,30 @@ public class BlossomConfig {
         allowInstantBlockFallingInLazyChunks = getBoolean("sand.instant-falling-in-lazy-chunks", false);
     }
 
+    public static boolean optimisedGlowstone;
+    public static me.samsuik.blossom.blocks.redstone.RedstoneAlgorithm redstoneAlgorithm;
+    private static void RedstoneAlgorithm() {
+        try {
+            String value = getString("redstone.algorithm", "pandawire");
+            String upperCase = value.toUpperCase(Locale.ROOT);
+            redstoneAlgorithm = me.samsuik.blossom.blocks.redstone.RedstoneAlgorithm.valueOf(upperCase);
+        } catch (Exception e) {
+            redstoneAlgorithm = me.samsuik.blossom.blocks.redstone.RedstoneAlgorithm.PANDAWIRE;
+            LOGGER.info("malformed \"redstone.algorithm\" defaulting to \"pandawire\"");
+        }
+        optimisedGlowstone = getBoolean("redstone.panda-wire.optimise-glowstone-wiring", false);
+    }
+
+    public static net.minecraft.server.BlockRedstoneWire redstoneAlgorithm() {
+        switch (redstoneAlgorithm) {
+            case PANDAWIRE_EX:
+                return new me.samsuik.blossom.blocks.redstone.ExtPandaRedstoneWire();
+            case PANDAWIRE:
+                return new me.samsuik.blossom.blocks.redstone.PandaRedstoneWire();
+            default:
+            case VANILLA:
+                return new net.minecraft.server.BlockRedstoneWire();
+        }
+    }
+
 }
diff --git a/src/main/java/net/minecraft/server/Block.java b/src/main/java/net/minecraft/server/Block.java
index 0911ae12a..2dc3b1755 100644
--- a/src/main/java/net/minecraft/server/Block.java
+++ b/src/main/java/net/minecraft/server/Block.java
@@ -848,7 +848,7 @@ public class Block {
         a(52, "mob_spawner", (new BlockMobSpawner()).c(5.0F).a(Block.j).c("mobSpawner").K());
         a(53, "oak_stairs", (new BlockStairs(block1.getBlockData().set(BlockWood.VARIANT, BlockWood.EnumLogVariant.OAK))).c("stairsWood"));
         a(54, "chest", (new BlockChest(0)).c(2.5F).a(Block.f).c("chest"));
-        a(55, "redstone_wire", (new BlockRedstoneWire()).c(0.0F).a(Block.e).c("redstoneDust").K());
+        a(55, "redstone_wire", (me.samsuik.blossom.configuration.BlossomConfig.redstoneAlgorithm()).c(0.0F).a(Block.e).c("redstoneDust").K()); // Blossom - implement pandawire
         a(56, "diamond_ore", (new BlockOre()).c(3.0F).b(5.0F).a(Block.i).c("oreDiamond"));
         a(57, "diamond_block", (new Block(Material.ORE, MaterialMapColor.G)).c(5.0F).b(10.0F).a(Block.j).c("blockDiamond").a(CreativeModeTab.b));
         a(58, "crafting_table", (new BlockWorkbench()).c(2.5F).a(Block.f).c("workbench"));
diff --git a/src/main/java/net/minecraft/server/EnumDirection.java b/src/main/java/net/minecraft/server/EnumDirection.java
index f31a184bb..d155bc4ff 100644
--- a/src/main/java/net/minecraft/server/EnumDirection.java
+++ b/src/main/java/net/minecraft/server/EnumDirection.java
@@ -17,7 +17,7 @@ public enum EnumDirection implements INamable {
     private final String j;
     private final EnumAxis k;
     private final EnumAxisDirection l;
-    private final BaseBlockPosition m;
+    private final BaseBlockPosition m; public final BaseBlockPosition getPositionOffset() { return this.m; } // Blossom - OBFHELPER
     private static final EnumDirection[] n = new EnumDirection[6];
     private static final EnumDirection[] o = new EnumDirection[4];
     private static final Map<String, EnumDirection> p = Maps.newHashMap();
-- 
2.50.1

