From de64d8953204c4ee41ecad5d6f1e1bb5f36a8587 Mon Sep 17 00:00:00 2001
From: Samsuik <40902469+Samsuik@users.noreply.github.com>
Date: Tue, 9 May 2023 16:10:11 +0100
Subject: [PATCH] mc dev imports


diff --git a/src/main/java/net/minecraft/server/AttributeBase.java b/src/main/java/net/minecraft/server/AttributeBase.java
new file mode 100644
index 000000000..9ef9bfec0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/AttributeBase.java
@@ -0,0 +1,47 @@
+package net.minecraft.server;
+
+public abstract class AttributeBase implements IAttribute {
+
+    private final IAttribute a;
+    private final String b;
+    private final double c;
+    private boolean d;
+
+    protected AttributeBase(IAttribute iattribute, String s, double d0) {
+        this.a = iattribute;
+        this.b = s;
+        this.c = d0;
+        if (s == null) {
+            throw new IllegalArgumentException("Name cannot be null!");
+        }
+    }
+
+    public String getName() {
+        return this.b;
+    }
+
+    public double b() {
+        return this.c;
+    }
+
+    public boolean c() {
+        return this.d;
+    }
+
+    public AttributeBase a(boolean flag) {
+        this.d = flag;
+        return this;
+    }
+
+    public IAttribute d() {
+        return this.a;
+    }
+
+    public int hashCode() {
+        return this.b.hashCode();
+    }
+
+    public boolean equals(Object object) {
+        return object instanceof IAttribute && this.b.equals(((IAttribute) object).getName());
+    }
+}
diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
new file mode 100644
index 000000000..88b6fe532
--- /dev/null
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -0,0 +1,285 @@
+package net.minecraft.server;
+
+public class AxisAlignedBB {
+
+    public final double a;
+    public final double b;
+    public final double c;
+    public final double d;
+    public final double e;
+    public final double f;
+
+    public AxisAlignedBB(double d0, double d1, double d2, double d3, double d4, double d5) {
+        this.a = Math.min(d0, d3);
+        this.b = Math.min(d1, d4);
+        this.c = Math.min(d2, d5);
+        this.d = Math.max(d0, d3);
+        this.e = Math.max(d1, d4);
+        this.f = Math.max(d2, d5);
+    }
+
+    public AxisAlignedBB(BlockPosition blockposition, BlockPosition blockposition1) {
+        this.a = (double) blockposition.getX();
+        this.b = (double) blockposition.getY();
+        this.c = (double) blockposition.getZ();
+        this.d = (double) blockposition1.getX();
+        this.e = (double) blockposition1.getY();
+        this.f = (double) blockposition1.getZ();
+    }
+
+    public AxisAlignedBB a(double d0, double d1, double d2) {
+        double d3 = this.a;
+        double d4 = this.b;
+        double d5 = this.c;
+        double d6 = this.d;
+        double d7 = this.e;
+        double d8 = this.f;
+
+        if (d0 < 0.0D) {
+            d3 += d0;
+        } else if (d0 > 0.0D) {
+            d6 += d0;
+        }
+
+        if (d1 < 0.0D) {
+            d4 += d1;
+        } else if (d1 > 0.0D) {
+            d7 += d1;
+        }
+
+        if (d2 < 0.0D) {
+            d5 += d2;
+        } else if (d2 > 0.0D) {
+            d8 += d2;
+        }
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public AxisAlignedBB grow(double d0, double d1, double d2) {
+        double d3 = this.a - d0;
+        double d4 = this.b - d1;
+        double d5 = this.c - d2;
+        double d6 = this.d + d0;
+        double d7 = this.e + d1;
+        double d8 = this.f + d2;
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public AxisAlignedBB a(AxisAlignedBB axisalignedbb) {
+        double d0 = Math.min(this.a, axisalignedbb.a);
+        double d1 = Math.min(this.b, axisalignedbb.b);
+        double d2 = Math.min(this.c, axisalignedbb.c);
+        double d3 = Math.max(this.d, axisalignedbb.d);
+        double d4 = Math.max(this.e, axisalignedbb.e);
+        double d5 = Math.max(this.f, axisalignedbb.f);
+
+        return new AxisAlignedBB(d0, d1, d2, d3, d4, d5);
+    }
+
+    public static AxisAlignedBB a(double d0, double d1, double d2, double d3, double d4, double d5) {
+        double d6 = Math.min(d0, d3);
+        double d7 = Math.min(d1, d4);
+        double d8 = Math.min(d2, d5);
+        double d9 = Math.max(d0, d3);
+        double d10 = Math.max(d1, d4);
+        double d11 = Math.max(d2, d5);
+
+        return new AxisAlignedBB(d6, d7, d8, d9, d10, d11);
+    }
+
+    public AxisAlignedBB c(double d0, double d1, double d2) {
+        return new AxisAlignedBB(this.a + d0, this.b + d1, this.c + d2, this.d + d0, this.e + d1, this.f + d2);
+    }
+
+    public double a(AxisAlignedBB axisalignedbb, double d0) {
+        if (axisalignedbb.e > this.b && axisalignedbb.b < this.e && axisalignedbb.f > this.c && axisalignedbb.c < this.f) {
+            double d1;
+
+            if (d0 > 0.0D && axisalignedbb.d <= this.a) {
+                d1 = this.a - axisalignedbb.d;
+                if (d1 < d0) {
+                    d0 = d1;
+                }
+            } else if (d0 < 0.0D && axisalignedbb.a >= this.d) {
+                d1 = this.d - axisalignedbb.a;
+                if (d1 > d0) {
+                    d0 = d1;
+                }
+            }
+
+            return d0;
+        } else {
+            return d0;
+        }
+    }
+
+    public double b(AxisAlignedBB axisalignedbb, double d0) {
+        if (axisalignedbb.d > this.a && axisalignedbb.a < this.d && axisalignedbb.f > this.c && axisalignedbb.c < this.f) {
+            double d1;
+
+            if (d0 > 0.0D && axisalignedbb.e <= this.b) {
+                d1 = this.b - axisalignedbb.e;
+                if (d1 < d0) {
+                    d0 = d1;
+                }
+            } else if (d0 < 0.0D && axisalignedbb.b >= this.e) {
+                d1 = this.e - axisalignedbb.b;
+                if (d1 > d0) {
+                    d0 = d1;
+                }
+            }
+
+            return d0;
+        } else {
+            return d0;
+        }
+    }
+
+    public double c(AxisAlignedBB axisalignedbb, double d0) {
+        if (axisalignedbb.d > this.a && axisalignedbb.a < this.d && axisalignedbb.e > this.b && axisalignedbb.b < this.e) {
+            double d1;
+
+            if (d0 > 0.0D && axisalignedbb.f <= this.c) {
+                d1 = this.c - axisalignedbb.f;
+                if (d1 < d0) {
+                    d0 = d1;
+                }
+            } else if (d0 < 0.0D && axisalignedbb.c >= this.f) {
+                d1 = this.f - axisalignedbb.c;
+                if (d1 > d0) {
+                    d0 = d1;
+                }
+            }
+
+            return d0;
+        } else {
+            return d0;
+        }
+    }
+
+    public boolean b(AxisAlignedBB axisalignedbb) {
+        return axisalignedbb.d > this.a && axisalignedbb.a < this.d ? (axisalignedbb.e > this.b && axisalignedbb.b < this.e ? axisalignedbb.f > this.c && axisalignedbb.c < this.f : false) : false;
+    }
+
+    public boolean a(Vec3D vec3d) {
+        return vec3d.a > this.a && vec3d.a < this.d ? (vec3d.b > this.b && vec3d.b < this.e ? vec3d.c > this.c && vec3d.c < this.f : false) : false;
+    }
+
+    public double a() {
+        double d0 = this.d - this.a;
+        double d1 = this.e - this.b;
+        double d2 = this.f - this.c;
+
+        return (d0 + d1 + d2) / 3.0D;
+    }
+
+    public AxisAlignedBB shrink(double d0, double d1, double d2) {
+        double d3 = this.a + d0;
+        double d4 = this.b + d1;
+        double d5 = this.c + d2;
+        double d6 = this.d - d0;
+        double d7 = this.e - d1;
+        double d8 = this.f - d2;
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public MovingObjectPosition a(Vec3D vec3d, Vec3D vec3d1) {
+        Vec3D vec3d2 = vec3d.a(vec3d1, this.a);
+        Vec3D vec3d3 = vec3d.a(vec3d1, this.d);
+        Vec3D vec3d4 = vec3d.b(vec3d1, this.b);
+        Vec3D vec3d5 = vec3d.b(vec3d1, this.e);
+        Vec3D vec3d6 = vec3d.c(vec3d1, this.c);
+        Vec3D vec3d7 = vec3d.c(vec3d1, this.f);
+
+        if (!this.b(vec3d2)) {
+            vec3d2 = null;
+        }
+
+        if (!this.b(vec3d3)) {
+            vec3d3 = null;
+        }
+
+        if (!this.c(vec3d4)) {
+            vec3d4 = null;
+        }
+
+        if (!this.c(vec3d5)) {
+            vec3d5 = null;
+        }
+
+        if (!this.d(vec3d6)) {
+            vec3d6 = null;
+        }
+
+        if (!this.d(vec3d7)) {
+            vec3d7 = null;
+        }
+
+        Vec3D vec3d8 = null;
+
+        if (vec3d2 != null) {
+            vec3d8 = vec3d2;
+        }
+
+        if (vec3d3 != null && (vec3d8 == null || vec3d.distanceSquared(vec3d3) < vec3d.distanceSquared(vec3d8))) {
+            vec3d8 = vec3d3;
+        }
+
+        if (vec3d4 != null && (vec3d8 == null || vec3d.distanceSquared(vec3d4) < vec3d.distanceSquared(vec3d8))) {
+            vec3d8 = vec3d4;
+        }
+
+        if (vec3d5 != null && (vec3d8 == null || vec3d.distanceSquared(vec3d5) < vec3d.distanceSquared(vec3d8))) {
+            vec3d8 = vec3d5;
+        }
+
+        if (vec3d6 != null && (vec3d8 == null || vec3d.distanceSquared(vec3d6) < vec3d.distanceSquared(vec3d8))) {
+            vec3d8 = vec3d6;
+        }
+
+        if (vec3d7 != null && (vec3d8 == null || vec3d.distanceSquared(vec3d7) < vec3d.distanceSquared(vec3d8))) {
+            vec3d8 = vec3d7;
+        }
+
+        if (vec3d8 == null) {
+            return null;
+        } else {
+            EnumDirection enumdirection = null;
+
+            if (vec3d8 == vec3d2) {
+                enumdirection = EnumDirection.WEST;
+            } else if (vec3d8 == vec3d3) {
+                enumdirection = EnumDirection.EAST;
+            } else if (vec3d8 == vec3d4) {
+                enumdirection = EnumDirection.DOWN;
+            } else if (vec3d8 == vec3d5) {
+                enumdirection = EnumDirection.UP;
+            } else if (vec3d8 == vec3d6) {
+                enumdirection = EnumDirection.NORTH;
+            } else {
+                enumdirection = EnumDirection.SOUTH;
+            }
+
+            return new MovingObjectPosition(vec3d8, enumdirection);
+        }
+    }
+
+    private boolean b(Vec3D vec3d) {
+        return vec3d == null ? false : vec3d.b >= this.b && vec3d.b <= this.e && vec3d.c >= this.c && vec3d.c <= this.f;
+    }
+
+    private boolean c(Vec3D vec3d) {
+        return vec3d == null ? false : vec3d.a >= this.a && vec3d.a <= this.d && vec3d.c >= this.c && vec3d.c <= this.f;
+    }
+
+    private boolean d(Vec3D vec3d) {
+        return vec3d == null ? false : vec3d.a >= this.a && vec3d.a <= this.d && vec3d.b >= this.b && vec3d.b <= this.e;
+    }
+
+    public String toString() {
+        return "box[" + this.a + ", " + this.b + ", " + this.c + " -> " + this.d + ", " + this.e + ", " + this.f + "]";
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockBanner.java b/src/main/java/net/minecraft/server/BlockBanner.java
new file mode 100644
index 000000000..2e9f0157c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockBanner.java
@@ -0,0 +1,214 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import java.util.Random;
+
+public class BlockBanner extends BlockContainer {
+
+    public static final BlockStateDirection FACING = BlockStateDirection.of("facing", (Predicate) EnumDirection.EnumDirectionLimit.HORIZONTAL);
+    public static final BlockStateInteger ROTATION = BlockStateInteger.of("rotation", 0, 15);
+
+    protected BlockBanner() {
+        super(Material.WOOD);
+        float f = 0.25F;
+        float f1 = 1.0F;
+
+        this.a(0.5F - f, 0.0F, 0.5F - f, 0.5F + f, f1, 0.5F + f);
+    }
+
+    public String getName() {
+        return LocaleI18n.get("item.banner.white.name");
+    }
+
+    public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        return null;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return true;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean g() {
+        return true;
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityBanner();
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return Items.BANNER;
+    }
+
+    public void dropNaturally(World world, BlockPosition blockposition, IBlockData iblockdata, float f, int i) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (tileentity instanceof TileEntityBanner) {
+            ItemStack itemstack = new ItemStack(Items.BANNER, 1, ((TileEntityBanner) tileentity).b());
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+            tileentity.b(nbttagcompound);
+            nbttagcompound.remove("x");
+            nbttagcompound.remove("y");
+            nbttagcompound.remove("z");
+            nbttagcompound.remove("id");
+            itemstack.a("BlockEntityTag", (NBTBase) nbttagcompound);
+            a(world, blockposition, itemstack);
+        } else {
+            super.dropNaturally(world, blockposition, iblockdata, f, i);
+        }
+
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return !this.e(world, blockposition) && super.canPlace(world, blockposition);
+    }
+
+    public void a(World world, EntityHuman entityhuman, BlockPosition blockposition, IBlockData iblockdata, TileEntity tileentity) {
+        if (tileentity instanceof TileEntityBanner) {
+            TileEntityBanner tileentitybanner = (TileEntityBanner) tileentity;
+            ItemStack itemstack = new ItemStack(Items.BANNER, 1, ((TileEntityBanner) tileentity).b());
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+            TileEntityBanner.a(nbttagcompound, tileentitybanner.b(), tileentitybanner.d());
+            itemstack.a("BlockEntityTag", (NBTBase) nbttagcompound);
+            a(world, blockposition, itemstack);
+        } else {
+            super.a(world, entityhuman, blockposition, iblockdata, (TileEntity) null);
+        }
+
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a = new int[EnumDirection.values().length];
+
+        static {
+            try {
+                BlockBanner.SyntheticClass_1.a[EnumDirection.NORTH.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                BlockBanner.SyntheticClass_1.a[EnumDirection.SOUTH.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                BlockBanner.SyntheticClass_1.a[EnumDirection.WEST.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                BlockBanner.SyntheticClass_1.a[EnumDirection.EAST.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+        }
+    }
+
+    public static class BlockStandingBanner extends BlockBanner {
+
+        public BlockStandingBanner() {
+            this.j(this.blockStateList.getBlockData().set(BlockBanner.BlockStandingBanner.ROTATION, Integer.valueOf(0)));
+        }
+
+        public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+            if (!world.getType(blockposition.down()).getBlock().getMaterial().isBuildable()) {
+                this.b(world, blockposition, iblockdata, 0);
+                world.setAir(blockposition);
+            }
+
+            super.doPhysics(world, blockposition, iblockdata, block);
+        }
+
+        public IBlockData fromLegacyData(int i) {
+            return this.getBlockData().set(BlockBanner.BlockStandingBanner.ROTATION, Integer.valueOf(i));
+        }
+
+        public int toLegacyData(IBlockData iblockdata) {
+            return ((Integer) iblockdata.get(BlockBanner.BlockStandingBanner.ROTATION)).intValue();
+        }
+
+        protected BlockStateList getStateList() {
+            return new BlockStateList(this, new IBlockState[] { BlockBanner.BlockStandingBanner.ROTATION});
+        }
+    }
+
+    public static class BlockWallBanner extends BlockBanner {
+
+        public BlockWallBanner() {
+            this.j(this.blockStateList.getBlockData().set(BlockBanner.BlockWallBanner.FACING, EnumDirection.NORTH));
+        }
+
+        public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+            EnumDirection enumdirection = (EnumDirection) iblockaccess.getType(blockposition).get(BlockBanner.BlockWallBanner.FACING);
+            float f = 0.0F;
+            float f1 = 0.78125F;
+            float f2 = 0.0F;
+            float f3 = 1.0F;
+            float f4 = 0.125F;
+
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+            switch (BlockBanner.SyntheticClass_1.a[enumdirection.ordinal()]) {
+                case 1:
+                default:
+                    this.a(f2, f, 1.0F - f4, f3, f1, 1.0F);
+                    break;
+
+                case 2:
+                    this.a(f2, f, 0.0F, f3, f1, f4);
+                    break;
+
+                case 3:
+                    this.a(1.0F - f4, f, f2, 1.0F, f1, f3);
+                    break;
+
+                case 4:
+                    this.a(0.0F, f, f2, f4, f1, f3);
+            }
+
+        }
+
+        public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+            EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockBanner.BlockWallBanner.FACING);
+
+            if (!world.getType(blockposition.shift(enumdirection.opposite())).getBlock().getMaterial().isBuildable()) {
+                this.b(world, blockposition, iblockdata, 0);
+                world.setAir(blockposition);
+            }
+
+            super.doPhysics(world, blockposition, iblockdata, block);
+        }
+
+        public IBlockData fromLegacyData(int i) {
+            EnumDirection enumdirection = EnumDirection.fromType1(i);
+
+            if (enumdirection.k() == EnumDirection.EnumAxis.Y) {
+                enumdirection = EnumDirection.NORTH;
+            }
+
+            return this.getBlockData().set(BlockBanner.BlockWallBanner.FACING, enumdirection);
+        }
+
+        public int toLegacyData(IBlockData iblockdata) {
+            return ((EnumDirection) iblockdata.get(BlockBanner.BlockWallBanner.FACING)).a();
+        }
+
+        protected BlockStateList getStateList() {
+            return new BlockStateList(this, new IBlockState[] { BlockBanner.BlockWallBanner.FACING});
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockCauldron.java b/src/main/java/net/minecraft/server/BlockCauldron.java
new file mode 100644
index 000000000..5a4d5f7c2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockCauldron.java
@@ -0,0 +1,185 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class BlockCauldron extends Block {
+
+    public static final BlockStateInteger LEVEL = BlockStateInteger.of("level", 0, 3);
+
+    public BlockCauldron() {
+        super(Material.ORE, MaterialMapColor.m);
+        this.j(this.blockStateList.getBlockData().set(BlockCauldron.LEVEL, Integer.valueOf(0)));
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.3125F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        float f = 0.125F;
+
+        this.a(0.0F, 0.0F, 0.0F, f, 1.0F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, f);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.a(1.0F - f, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.a(0.0F, 0.0F, 1.0F - f, 1.0F, 1.0F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.j();
+    }
+
+    public void j() {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
+        int i = ((Integer) iblockdata.get(BlockCauldron.LEVEL)).intValue();
+        float f = (float) blockposition.getY() + (6.0F + (float) (3 * i)) / 16.0F;
+
+        if (!world.isClientSide && entity.isBurning() && i > 0 && entity.getBoundingBox().b <= (double) f) {
+            entity.extinguish();
+            this.a(world, blockposition, iblockdata, i - 1);
+        }
+
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (world.isClientSide) {
+            return true;
+        } else {
+            ItemStack itemstack = entityhuman.inventory.getItemInHand();
+
+            if (itemstack == null) {
+                return true;
+            } else {
+                int i = ((Integer) iblockdata.get(BlockCauldron.LEVEL)).intValue();
+                Item item = itemstack.getItem();
+
+                if (item == Items.WATER_BUCKET) {
+                    if (i < 3) {
+                        if (!entityhuman.abilities.canInstantlyBuild) {
+                            entityhuman.inventory.setItem(entityhuman.inventory.itemInHandIndex, new ItemStack(Items.BUCKET));
+                        }
+
+                        entityhuman.b(StatisticList.I);
+                        this.a(world, blockposition, iblockdata, 3);
+                    }
+
+                    return true;
+                } else {
+                    ItemStack itemstack1;
+
+                    if (item == Items.GLASS_BOTTLE) {
+                        if (i > 0) {
+                            if (!entityhuman.abilities.canInstantlyBuild) {
+                                itemstack1 = new ItemStack(Items.POTION, 1, 0);
+                                if (!entityhuman.inventory.pickup(itemstack1)) {
+                                    world.addEntity(new EntityItem(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 1.5D, (double) blockposition.getZ() + 0.5D, itemstack1));
+                                } else if (entityhuman instanceof EntityPlayer) {
+                                    ((EntityPlayer) entityhuman).updateInventory(entityhuman.defaultContainer);
+                                }
+
+                                entityhuman.b(StatisticList.J);
+                                --itemstack.count;
+                                if (itemstack.count <= 0) {
+                                    entityhuman.inventory.setItem(entityhuman.inventory.itemInHandIndex, (ItemStack) null);
+                                }
+                            }
+
+                            this.a(world, blockposition, iblockdata, i - 1);
+                        }
+
+                        return true;
+                    } else {
+                        if (i > 0 && item instanceof ItemArmor) {
+                            ItemArmor itemarmor = (ItemArmor) item;
+
+                            if (itemarmor.x_() == ItemArmor.EnumArmorMaterial.LEATHER && itemarmor.d_(itemstack)) {
+                                itemarmor.c(itemstack);
+                                this.a(world, blockposition, iblockdata, i - 1);
+                                entityhuman.b(StatisticList.K);
+                                return true;
+                            }
+                        }
+
+                        if (i > 0 && item instanceof ItemBanner && TileEntityBanner.c(itemstack) > 0) {
+                            itemstack1 = itemstack.cloneItemStack();
+                            itemstack1.count = 1;
+                            TileEntityBanner.e(itemstack1);
+                            if (itemstack.count <= 1 && !entityhuman.abilities.canInstantlyBuild) {
+                                entityhuman.inventory.setItem(entityhuman.inventory.itemInHandIndex, itemstack1);
+                            } else {
+                                if (!entityhuman.inventory.pickup(itemstack1)) {
+                                    world.addEntity(new EntityItem(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 1.5D, (double) blockposition.getZ() + 0.5D, itemstack1));
+                                } else if (entityhuman instanceof EntityPlayer) {
+                                    ((EntityPlayer) entityhuman).updateInventory(entityhuman.defaultContainer);
+                                }
+
+                                entityhuman.b(StatisticList.L);
+                                if (!entityhuman.abilities.canInstantlyBuild) {
+                                    --itemstack.count;
+                                }
+                            }
+
+                            if (!entityhuman.abilities.canInstantlyBuild) {
+                                this.a(world, blockposition, iblockdata, i - 1);
+                            }
+
+                            return true;
+                        } else {
+                            return false;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, int i) {
+        world.setTypeAndData(blockposition, iblockdata.set(BlockCauldron.LEVEL, Integer.valueOf(MathHelper.clamp(i, 0, 3))), 2);
+        world.updateAdjacentComparators(blockposition, this);
+    }
+
+    public void k(World world, BlockPosition blockposition) {
+        if (world.random.nextInt(20) == 1) {
+            IBlockData iblockdata = world.getType(blockposition);
+
+            if (((Integer) iblockdata.get(BlockCauldron.LEVEL)).intValue() < 3) {
+                world.setTypeAndData(blockposition, iblockdata.a(BlockCauldron.LEVEL), 2);
+            }
+
+        }
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return Items.CAULDRON;
+    }
+
+    public boolean isComplexRedstone() {
+        return true;
+    }
+
+    public int l(World world, BlockPosition blockposition) {
+        return ((Integer) world.getType(blockposition).get(BlockCauldron.LEVEL)).intValue();
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockCauldron.LEVEL, Integer.valueOf(i));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((Integer) iblockdata.get(BlockCauldron.LEVEL)).intValue();
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockCauldron.LEVEL});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockCobbleWall.java b/src/main/java/net/minecraft/server/BlockCobbleWall.java
new file mode 100644
index 000000000..08f8b5e29
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockCobbleWall.java
@@ -0,0 +1,160 @@
+package net.minecraft.server;
+
+public class BlockCobbleWall extends Block {
+
+    public static final BlockStateBoolean UP = BlockStateBoolean.of("up");
+    public static final BlockStateBoolean NORTH = BlockStateBoolean.of("north");
+    public static final BlockStateBoolean EAST = BlockStateBoolean.of("east");
+    public static final BlockStateBoolean SOUTH = BlockStateBoolean.of("south");
+    public static final BlockStateBoolean WEST = BlockStateBoolean.of("west");
+    public static final BlockStateEnum<BlockCobbleWall.EnumCobbleVariant> VARIANT = BlockStateEnum.of("variant", BlockCobbleWall.EnumCobbleVariant.class);
+
+    public BlockCobbleWall(Block block) {
+        super(block.material);
+        this.j(this.blockStateList.getBlockData().set(BlockCobbleWall.UP, Boolean.valueOf(false)).set(BlockCobbleWall.NORTH, Boolean.valueOf(false)).set(BlockCobbleWall.EAST, Boolean.valueOf(false)).set(BlockCobbleWall.SOUTH, Boolean.valueOf(false)).set(BlockCobbleWall.WEST, Boolean.valueOf(false)).set(BlockCobbleWall.VARIANT, BlockCobbleWall.EnumCobbleVariant.NORMAL));
+        this.c(block.strength);
+        this.b(block.durability / 3.0F);
+        this.a(block.stepSound);
+        this.a(CreativeModeTab.b);
+    }
+
+    public String getName() {
+        return LocaleI18n.get(this.a() + "." + BlockCobbleWall.EnumCobbleVariant.NORMAL.c() + ".name");
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        boolean flag = this.e(iblockaccess, blockposition.north());
+        boolean flag1 = this.e(iblockaccess, blockposition.south());
+        boolean flag2 = this.e(iblockaccess, blockposition.west());
+        boolean flag3 = this.e(iblockaccess, blockposition.east());
+        float f = 0.25F;
+        float f1 = 0.75F;
+        float f2 = 0.25F;
+        float f3 = 0.75F;
+        float f4 = 1.0F;
+
+        if (flag) {
+            f2 = 0.0F;
+        }
+
+        if (flag1) {
+            f3 = 1.0F;
+        }
+
+        if (flag2) {
+            f = 0.0F;
+        }
+
+        if (flag3) {
+            f1 = 1.0F;
+        }
+
+        if (flag && flag1 && !flag2 && !flag3) {
+            f4 = 0.8125F;
+            f = 0.3125F;
+            f1 = 0.6875F;
+        } else if (!flag && !flag1 && flag2 && flag3) {
+            f4 = 0.8125F;
+            f2 = 0.3125F;
+            f3 = 0.6875F;
+        }
+
+        this.a(f, 0.0F, f2, f1, f4, f3);
+    }
+
+    public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.updateShape(world, blockposition);
+        this.maxY = 1.5D;
+        return super.a(world, blockposition, iblockdata);
+    }
+
+    public boolean e(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        Block block = iblockaccess.getType(blockposition).getBlock();
+
+        return block == Blocks.BARRIER ? false : (block != this && !(block instanceof BlockFenceGate) ? (block.material.k() && block.d() ? block.material != Material.PUMPKIN : false) : true);
+    }
+
+    public int getDropData(IBlockData iblockdata) {
+        return ((BlockCobbleWall.EnumCobbleVariant) iblockdata.get(BlockCobbleWall.VARIANT)).a();
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockCobbleWall.VARIANT, BlockCobbleWall.EnumCobbleVariant.a(i));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((BlockCobbleWall.EnumCobbleVariant) iblockdata.get(BlockCobbleWall.VARIANT)).a();
+    }
+
+    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return iblockdata.set(BlockCobbleWall.UP, Boolean.valueOf(!iblockaccess.isEmpty(blockposition.up()))).set(BlockCobbleWall.NORTH, Boolean.valueOf(this.e(iblockaccess, blockposition.north()))).set(BlockCobbleWall.EAST, Boolean.valueOf(this.e(iblockaccess, blockposition.east()))).set(BlockCobbleWall.SOUTH, Boolean.valueOf(this.e(iblockaccess, blockposition.south()))).set(BlockCobbleWall.WEST, Boolean.valueOf(this.e(iblockaccess, blockposition.west())));
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockCobbleWall.UP, BlockCobbleWall.NORTH, BlockCobbleWall.EAST, BlockCobbleWall.WEST, BlockCobbleWall.SOUTH, BlockCobbleWall.VARIANT});
+    }
+
+    public static enum EnumCobbleVariant implements INamable {
+
+        NORMAL(0, "cobblestone", "normal"), MOSSY(1, "mossy_cobblestone", "mossy");
+
+        private static final BlockCobbleWall.EnumCobbleVariant[] c = new BlockCobbleWall.EnumCobbleVariant[values().length];
+        private final int d;
+        private final String e;
+        private String f;
+
+        private EnumCobbleVariant(int i, String s, String s1) {
+            this.d = i;
+            this.e = s;
+            this.f = s1;
+        }
+
+        public int a() {
+            return this.d;
+        }
+
+        public String toString() {
+            return this.e;
+        }
+
+        public static BlockCobbleWall.EnumCobbleVariant a(int i) {
+            if (i < 0 || i >= BlockCobbleWall.EnumCobbleVariant.c.length) {
+                i = 0;
+            }
+
+            return BlockCobbleWall.EnumCobbleVariant.c[i];
+        }
+
+        public String getName() {
+            return this.e;
+        }
+
+        public String c() {
+            return this.f;
+        }
+
+        static {
+            BlockCobbleWall.EnumCobbleVariant[] ablockcobblewall_enumcobblevariant = values();
+            int i = ablockcobblewall_enumcobblevariant.length;
+
+            for (int j = 0; j < i; ++j) {
+                BlockCobbleWall.EnumCobbleVariant blockcobblewall_enumcobblevariant = ablockcobblewall_enumcobblevariant[j];
+
+                BlockCobbleWall.EnumCobbleVariant.c[blockcobblewall_enumcobblevariant.a()] = blockcobblewall_enumcobblevariant;
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockEnderPortalFrame.java b/src/main/java/net/minecraft/server/BlockEnderPortalFrame.java
new file mode 100644
index 000000000..43e1da0ee
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockEnderPortalFrame.java
@@ -0,0 +1,70 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import java.util.List;
+import java.util.Random;
+
+public class BlockEnderPortalFrame extends Block {
+
+    public static final BlockStateDirection FACING = BlockStateDirection.of("facing", (Predicate) EnumDirection.EnumDirectionLimit.HORIZONTAL);
+    public static final BlockStateBoolean EYE = BlockStateBoolean.of("eye");
+
+    public BlockEnderPortalFrame() {
+        super(Material.STONE, MaterialMapColor.C);
+        this.j(this.blockStateList.getBlockData().set(BlockEnderPortalFrame.FACING, EnumDirection.NORTH).set(BlockEnderPortalFrame.EYE, Boolean.valueOf(false)));
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public void j() {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.8125F, 1.0F);
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.8125F, 1.0F);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        if (((Boolean) world.getType(blockposition).get(BlockEnderPortalFrame.EYE)).booleanValue()) {
+            this.a(0.3125F, 0.8125F, 0.3125F, 0.6875F, 1.0F, 0.6875F);
+            super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        }
+
+        this.j();
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return null;
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        return this.getBlockData().set(BlockEnderPortalFrame.FACING, entityliving.getDirection().opposite()).set(BlockEnderPortalFrame.EYE, Boolean.valueOf(false));
+    }
+
+    public boolean isComplexRedstone() {
+        return true;
+    }
+
+    public int l(World world, BlockPosition blockposition) {
+        return ((Boolean) world.getType(blockposition).get(BlockEnderPortalFrame.EYE)).booleanValue() ? 15 : 0;
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockEnderPortalFrame.EYE, Boolean.valueOf((i & 4) != 0)).set(BlockEnderPortalFrame.FACING, EnumDirection.fromType2(i & 3));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((EnumDirection) iblockdata.get(BlockEnderPortalFrame.FACING)).b();
+
+        if (((Boolean) iblockdata.get(BlockEnderPortalFrame.EYE)).booleanValue()) {
+            i |= 4;
+        }
+
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockEnderPortalFrame.FACING, BlockEnderPortalFrame.EYE});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockFence.java b/src/main/java/net/minecraft/server/BlockFence.java
new file mode 100644
index 000000000..1d500553b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFence.java
@@ -0,0 +1,133 @@
+package net.minecraft.server;
+
+import java.util.List;
+
+public class BlockFence extends Block {
+
+    public static final BlockStateBoolean NORTH = BlockStateBoolean.of("north");
+    public static final BlockStateBoolean EAST = BlockStateBoolean.of("east");
+    public static final BlockStateBoolean SOUTH = BlockStateBoolean.of("south");
+    public static final BlockStateBoolean WEST = BlockStateBoolean.of("west");
+
+    public BlockFence(Material material) {
+        this(material, material.r());
+    }
+
+    public BlockFence(Material material, MaterialMapColor materialmapcolor) {
+        super(material, materialmapcolor);
+        this.j(this.blockStateList.getBlockData().set(BlockFence.NORTH, Boolean.valueOf(false)).set(BlockFence.EAST, Boolean.valueOf(false)).set(BlockFence.SOUTH, Boolean.valueOf(false)).set(BlockFence.WEST, Boolean.valueOf(false)));
+        this.a(CreativeModeTab.c);
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        boolean flag = this.e(world, blockposition.north());
+        boolean flag1 = this.e(world, blockposition.south());
+        boolean flag2 = this.e(world, blockposition.west());
+        boolean flag3 = this.e(world, blockposition.east());
+        float f = 0.375F;
+        float f1 = 0.625F;
+        float f2 = 0.375F;
+        float f3 = 0.625F;
+
+        if (flag) {
+            f2 = 0.0F;
+        }
+
+        if (flag1) {
+            f3 = 1.0F;
+        }
+
+        if (flag || flag1) {
+            this.a(f, 0.0F, f2, f1, 1.5F, f3);
+            super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        }
+
+        f2 = 0.375F;
+        f3 = 0.625F;
+        if (flag2) {
+            f = 0.0F;
+        }
+
+        if (flag3) {
+            f1 = 1.0F;
+        }
+
+        if (flag2 || flag3 || !flag && !flag1) {
+            this.a(f, 0.0F, f2, f1, 1.5F, f3);
+            super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        }
+
+        if (flag) {
+            f2 = 0.0F;
+        }
+
+        if (flag1) {
+            f3 = 1.0F;
+        }
+
+        this.a(f, 0.0F, f2, f1, 1.0F, f3);
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        boolean flag = this.e(iblockaccess, blockposition.north());
+        boolean flag1 = this.e(iblockaccess, blockposition.south());
+        boolean flag2 = this.e(iblockaccess, blockposition.west());
+        boolean flag3 = this.e(iblockaccess, blockposition.east());
+        float f = 0.375F;
+        float f1 = 0.625F;
+        float f2 = 0.375F;
+        float f3 = 0.625F;
+
+        if (flag) {
+            f2 = 0.0F;
+        }
+
+        if (flag1) {
+            f3 = 1.0F;
+        }
+
+        if (flag2) {
+            f = 0.0F;
+        }
+
+        if (flag3) {
+            f1 = 1.0F;
+        }
+
+        this.a(f, 0.0F, f2, f1, 1.0F, f3);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return false;
+    }
+
+    public boolean e(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        Block block = iblockaccess.getType(blockposition).getBlock();
+
+        return block == Blocks.BARRIER ? false : ((!(block instanceof BlockFence) || block.material != this.material) && !(block instanceof BlockFenceGate) ? (block.material.k() && block.d() ? block.material != Material.PUMPKIN : false) : true);
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        return world.isClientSide ? true : ItemLeash.a(entityhuman, world, blockposition);
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return 0;
+    }
+
+    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return iblockdata.set(BlockFence.NORTH, Boolean.valueOf(this.e(iblockaccess, blockposition.north()))).set(BlockFence.EAST, Boolean.valueOf(this.e(iblockaccess, blockposition.east()))).set(BlockFence.SOUTH, Boolean.valueOf(this.e(iblockaccess, blockposition.south()))).set(BlockFence.WEST, Boolean.valueOf(this.e(iblockaccess, blockposition.west())));
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockFence.NORTH, BlockFence.EAST, BlockFence.WEST, BlockFence.SOUTH});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockFenceGate.java b/src/main/java/net/minecraft/server/BlockFenceGate.java
new file mode 100644
index 000000000..c02281293
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFenceGate.java
@@ -0,0 +1,126 @@
+package net.minecraft.server;
+
+public class BlockFenceGate extends BlockDirectional {
+
+    public static final BlockStateBoolean OPEN = BlockStateBoolean.of("open");
+    public static final BlockStateBoolean POWERED = BlockStateBoolean.of("powered");
+    public static final BlockStateBoolean IN_WALL = BlockStateBoolean.of("in_wall");
+
+    public BlockFenceGate(BlockWood.EnumLogVariant blockwood_enumlogvariant) {
+        super(Material.WOOD, blockwood_enumlogvariant.c());
+        this.j(this.blockStateList.getBlockData().set(BlockFenceGate.OPEN, Boolean.valueOf(false)).set(BlockFenceGate.POWERED, Boolean.valueOf(false)).set(BlockFenceGate.IN_WALL, Boolean.valueOf(false)));
+        this.a(CreativeModeTab.d);
+    }
+
+    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        EnumDirection.EnumAxis enumdirection_enumaxis = ((EnumDirection) iblockdata.get(BlockFenceGate.FACING)).k();
+
+        if (enumdirection_enumaxis == EnumDirection.EnumAxis.Z && (iblockaccess.getType(blockposition.west()).getBlock() == Blocks.COBBLESTONE_WALL || iblockaccess.getType(blockposition.east()).getBlock() == Blocks.COBBLESTONE_WALL) || enumdirection_enumaxis == EnumDirection.EnumAxis.X && (iblockaccess.getType(blockposition.north()).getBlock() == Blocks.COBBLESTONE_WALL || iblockaccess.getType(blockposition.south()).getBlock() == Blocks.COBBLESTONE_WALL)) {
+            iblockdata = iblockdata.set(BlockFenceGate.IN_WALL, Boolean.valueOf(true));
+        }
+
+        return iblockdata;
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return world.getType(blockposition.down()).getBlock().getMaterial().isBuildable() ? super.canPlace(world, blockposition) : false;
+    }
+
+    public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (((Boolean) iblockdata.get(BlockFenceGate.OPEN)).booleanValue()) {
+            return null;
+        } else {
+            EnumDirection.EnumAxis enumdirection_enumaxis = ((EnumDirection) iblockdata.get(BlockFenceGate.FACING)).k();
+
+            return enumdirection_enumaxis == EnumDirection.EnumAxis.Z ? new AxisAlignedBB((double) blockposition.getX(), (double) blockposition.getY(), (double) ((float) blockposition.getZ() + 0.375F), (double) (blockposition.getX() + 1), (double) ((float) blockposition.getY() + 1.5F), (double) ((float) blockposition.getZ() + 0.625F)) : new AxisAlignedBB((double) ((float) blockposition.getX() + 0.375F), (double) blockposition.getY(), (double) blockposition.getZ(), (double) ((float) blockposition.getX() + 0.625F), (double) ((float) blockposition.getY() + 1.5F), (double) (blockposition.getZ() + 1));
+        }
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        EnumDirection.EnumAxis enumdirection_enumaxis = ((EnumDirection) iblockaccess.getType(blockposition).get(BlockFenceGate.FACING)).k();
+
+        if (enumdirection_enumaxis == EnumDirection.EnumAxis.Z) {
+            this.a(0.0F, 0.0F, 0.375F, 1.0F, 1.0F, 0.625F);
+        } else {
+            this.a(0.375F, 0.0F, 0.0F, 0.625F, 1.0F, 1.0F);
+        }
+
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return ((Boolean) iblockaccess.getType(blockposition).get(BlockFenceGate.OPEN)).booleanValue();
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        return this.getBlockData().set(BlockFenceGate.FACING, entityliving.getDirection()).set(BlockFenceGate.OPEN, Boolean.valueOf(false)).set(BlockFenceGate.POWERED, Boolean.valueOf(false)).set(BlockFenceGate.IN_WALL, Boolean.valueOf(false));
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (((Boolean) iblockdata.get(BlockFenceGate.OPEN)).booleanValue()) {
+            iblockdata = iblockdata.set(BlockFenceGate.OPEN, Boolean.valueOf(false));
+            world.setTypeAndData(blockposition, iblockdata, 2);
+        } else {
+            EnumDirection enumdirection1 = EnumDirection.fromAngle((double) entityhuman.yaw);
+
+            if (iblockdata.get(BlockFenceGate.FACING) == enumdirection1.opposite()) {
+                iblockdata = iblockdata.set(BlockFenceGate.FACING, enumdirection1);
+            }
+
+            iblockdata = iblockdata.set(BlockFenceGate.OPEN, Boolean.valueOf(true));
+            world.setTypeAndData(blockposition, iblockdata, 2);
+        }
+
+        world.a(entityhuman, ((Boolean) iblockdata.get(BlockFenceGate.OPEN)).booleanValue() ? 1003 : 1006, blockposition, 0);
+        return true;
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        if (!world.isClientSide) {
+            boolean flag = world.isBlockIndirectlyPowered(blockposition);
+
+            if (flag || block.isPowerSource()) {
+                if (flag && !((Boolean) iblockdata.get(BlockFenceGate.OPEN)).booleanValue() && !((Boolean) iblockdata.get(BlockFenceGate.POWERED)).booleanValue()) {
+                    world.setTypeAndData(blockposition, iblockdata.set(BlockFenceGate.OPEN, Boolean.valueOf(true)).set(BlockFenceGate.POWERED, Boolean.valueOf(true)), 2);
+                    world.a((EntityHuman) null, 1003, blockposition, 0);
+                } else if (!flag && ((Boolean) iblockdata.get(BlockFenceGate.OPEN)).booleanValue() && ((Boolean) iblockdata.get(BlockFenceGate.POWERED)).booleanValue()) {
+                    world.setTypeAndData(blockposition, iblockdata.set(BlockFenceGate.OPEN, Boolean.valueOf(false)).set(BlockFenceGate.POWERED, Boolean.valueOf(false)), 2);
+                    world.a((EntityHuman) null, 1006, blockposition, 0);
+                } else if (flag != ((Boolean) iblockdata.get(BlockFenceGate.POWERED)).booleanValue()) {
+                    world.setTypeAndData(blockposition, iblockdata.set(BlockFenceGate.POWERED, Boolean.valueOf(flag)), 2);
+                }
+            }
+
+        }
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockFenceGate.FACING, EnumDirection.fromType2(i)).set(BlockFenceGate.OPEN, Boolean.valueOf((i & 4) != 0)).set(BlockFenceGate.POWERED, Boolean.valueOf((i & 8) != 0));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((EnumDirection) iblockdata.get(BlockFenceGate.FACING)).b();
+
+        if (((Boolean) iblockdata.get(BlockFenceGate.POWERED)).booleanValue()) {
+            i |= 8;
+        }
+
+        if (((Boolean) iblockdata.get(BlockFenceGate.OPEN)).booleanValue()) {
+            i |= 4;
+        }
+
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockFenceGate.FACING, BlockFenceGate.OPEN, BlockFenceGate.POWERED, BlockFenceGate.IN_WALL});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockFloorSign.java b/src/main/java/net/minecraft/server/BlockFloorSign.java
new file mode 100644
index 000000000..27bc09774
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFloorSign.java
@@ -0,0 +1,31 @@
+package net.minecraft.server;
+
+public class BlockFloorSign extends BlockSign {
+
+    public static final BlockStateInteger ROTATION = BlockStateInteger.of("rotation", 0, 15);
+
+    public BlockFloorSign() {
+        this.j(this.blockStateList.getBlockData().set(BlockFloorSign.ROTATION, Integer.valueOf(0)));
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        if (!world.getType(blockposition.down()).getBlock().getMaterial().isBuildable()) {
+            this.b(world, blockposition, iblockdata, 0);
+            world.setAir(blockposition);
+        }
+
+        super.doPhysics(world, blockposition, iblockdata, block);
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockFloorSign.ROTATION, Integer.valueOf(i));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((Integer) iblockdata.get(BlockFloorSign.ROTATION)).intValue();
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockFloorSign.ROTATION});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockLadder.java b/src/main/java/net/minecraft/server/BlockLadder.java
new file mode 100644
index 000000000..c12c43bb1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockLadder.java
@@ -0,0 +1,144 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import java.util.Iterator;
+
+public class BlockLadder extends Block {
+
+    public static final BlockStateDirection FACING = BlockStateDirection.of("facing", (Predicate) EnumDirection.EnumDirectionLimit.HORIZONTAL);
+
+    protected BlockLadder() {
+        super(Material.ORIENTABLE);
+        this.j(this.blockStateList.getBlockData().set(BlockLadder.FACING, EnumDirection.NORTH));
+        this.a(CreativeModeTab.c);
+    }
+
+    public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.updateShape(world, blockposition);
+        return super.a(world, blockposition, iblockdata);
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+
+        if (iblockdata.getBlock() == this) {
+            float f = 0.125F;
+
+            switch (SyntheticClass_1.a[((EnumDirection) iblockdata.get(BlockLadder.FACING)).ordinal()]) {
+            case 1:
+                this.a(0.0F, 0.0F, 1.0F - f, 1.0F, 1.0F, 1.0F);
+                break;
+
+            case 2:
+                this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, f);
+                break;
+
+            case 3:
+                this.a(1.0F - f, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+                break;
+
+            case 4:
+            default:
+                this.a(0.0F, 0.0F, 0.0F, f, 1.0F, 1.0F);
+            }
+
+        }
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return world.getType(blockposition.west()).getBlock().isOccluding() ? true : (world.getType(blockposition.east()).getBlock().isOccluding() ? true : (world.getType(blockposition.north()).getBlock().isOccluding() ? true : world.getType(blockposition.south()).getBlock().isOccluding()));
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        if (enumdirection.k().c() && this.a(world, blockposition, enumdirection)) {
+            return this.getBlockData().set(BlockLadder.FACING, enumdirection);
+        } else {
+            Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+            EnumDirection enumdirection1;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return this.getBlockData();
+                }
+
+                enumdirection1 = (EnumDirection) iterator.next();
+            } while (!this.a(world, blockposition, enumdirection1));
+
+            return this.getBlockData().set(BlockLadder.FACING, enumdirection1);
+        }
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockLadder.FACING);
+
+        if (!this.a(world, blockposition, enumdirection)) {
+            this.b(world, blockposition, iblockdata, 0);
+            world.setAir(blockposition);
+        }
+
+        super.doPhysics(world, blockposition, iblockdata, block);
+    }
+
+    protected boolean a(World world, BlockPosition blockposition, EnumDirection enumdirection) {
+        return world.getType(blockposition.shift(enumdirection.opposite())).getBlock().isOccluding();
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        EnumDirection enumdirection = EnumDirection.fromType1(i);
+
+        if (enumdirection.k() == EnumDirection.EnumAxis.Y) {
+            enumdirection = EnumDirection.NORTH;
+        }
+
+        return this.getBlockData().set(BlockLadder.FACING, enumdirection);
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((EnumDirection) iblockdata.get(BlockLadder.FACING)).a();
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockLadder.FACING});
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a = new int[EnumDirection.values().length];
+
+        static {
+            try {
+                SyntheticClass_1.a[EnumDirection.NORTH.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.a[EnumDirection.SOUTH.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.a[EnumDirection.WEST.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.a[EnumDirection.EAST.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockLeaves2.java b/src/main/java/net/minecraft/server/BlockLeaves2.java
new file mode 100644
index 000000000..944ce5b42
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockLeaves2.java
@@ -0,0 +1,77 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+
+public class BlockLeaves2 extends BlockLeaves {
+
+    public static final BlockStateEnum<BlockWood.EnumLogVariant> VARIANT = BlockStateEnum.a("variant", BlockWood.EnumLogVariant.class, new Predicate() {
+        public boolean a(BlockWood.EnumLogVariant blockwood_enumlogvariant) {
+            return blockwood_enumlogvariant.a() >= 4;
+        }
+
+        public boolean apply(Object object) {
+            return this.a((BlockWood.EnumLogVariant) object);
+        }
+    });
+
+    public BlockLeaves2() {
+        this.j(this.blockStateList.getBlockData().set(BlockLeaves2.VARIANT, BlockWood.EnumLogVariant.ACACIA).set(BlockLeaves2.CHECK_DECAY, Boolean.valueOf(true)).set(BlockLeaves2.DECAYABLE, Boolean.valueOf(true)));
+    }
+
+    protected void a(World world, BlockPosition blockposition, IBlockData iblockdata, int i) {
+        if (iblockdata.get(BlockLeaves2.VARIANT) == BlockWood.EnumLogVariant.DARK_OAK && world.random.nextInt(i) == 0) {
+            a(world, blockposition, new ItemStack(Items.APPLE, 1, 0));
+        }
+
+    }
+
+    public int getDropData(IBlockData iblockdata) {
+        return ((BlockWood.EnumLogVariant) iblockdata.get(BlockLeaves2.VARIANT)).a();
+    }
+
+    public int getDropData(World world, BlockPosition blockposition) {
+        IBlockData iblockdata = world.getType(blockposition);
+
+        return iblockdata.getBlock().toLegacyData(iblockdata) & 3;
+    }
+
+    protected ItemStack i(IBlockData iblockdata) {
+        return new ItemStack(Item.getItemOf(this), 1, ((BlockWood.EnumLogVariant) iblockdata.get(BlockLeaves2.VARIANT)).a() - 4);
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockLeaves2.VARIANT, this.b(i)).set(BlockLeaves2.DECAYABLE, Boolean.valueOf((i & 4) == 0)).set(BlockLeaves2.CHECK_DECAY, Boolean.valueOf((i & 8) > 0));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((BlockWood.EnumLogVariant) iblockdata.get(BlockLeaves2.VARIANT)).a() - 4;
+
+        if (!((Boolean) iblockdata.get(BlockLeaves2.DECAYABLE)).booleanValue()) {
+            i |= 4;
+        }
+
+        if (((Boolean) iblockdata.get(BlockLeaves2.CHECK_DECAY)).booleanValue()) {
+            i |= 8;
+        }
+
+        return i;
+    }
+
+    public BlockWood.EnumLogVariant b(int i) {
+        return BlockWood.EnumLogVariant.a((i & 3) + 4);
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockLeaves2.VARIANT, BlockLeaves2.CHECK_DECAY, BlockLeaves2.DECAYABLE});
+    }
+
+    public void a(World world, EntityHuman entityhuman, BlockPosition blockposition, IBlockData iblockdata, TileEntity tileentity) {
+        if (!world.isClientSide && entityhuman.bZ() != null && entityhuman.bZ().getItem() == Items.SHEARS) {
+            entityhuman.b(StatisticList.MINE_BLOCK_COUNT[Block.getId(this)]);
+            a(world, blockposition, new ItemStack(Item.getItemOf(this), 1, ((BlockWood.EnumLogVariant) iblockdata.get(BlockLeaves2.VARIANT)).a() - 4));
+        } else {
+            super.a(world, entityhuman, blockposition, iblockdata, tileentity);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockLog2.java b/src/main/java/net/minecraft/server/BlockLog2.java
new file mode 100644
index 000000000..d7508df9d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockLog2.java
@@ -0,0 +1,144 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+
+public class BlockLog2 extends BlockLogAbstract {
+
+    public static final BlockStateEnum<BlockWood.EnumLogVariant> VARIANT = BlockStateEnum.a("variant", BlockWood.EnumLogVariant.class, new Predicate() {
+        public boolean a(BlockWood.EnumLogVariant blockwood_enumlogvariant) {
+            return blockwood_enumlogvariant.a() >= 4;
+        }
+
+        public boolean apply(Object object) {
+            return this.a((BlockWood.EnumLogVariant) object);
+        }
+    });
+
+    public BlockLog2() {
+        this.j(this.blockStateList.getBlockData().set(BlockLog2.VARIANT, BlockWood.EnumLogVariant.ACACIA).set(BlockLog2.AXIS, BlockLogAbstract.EnumLogRotation.Y));
+    }
+
+    public MaterialMapColor g(IBlockData iblockdata) {
+        BlockWood.EnumLogVariant blockwood_enumlogvariant = (BlockWood.EnumLogVariant) iblockdata.get(BlockLog2.VARIANT);
+
+        switch (BlockLog2.SyntheticClass_1.b[((BlockLogAbstract.EnumLogRotation) iblockdata.get(BlockLog2.AXIS)).ordinal()]) {
+            case 1:
+            case 2:
+            case 3:
+            default:
+                switch (BlockLog2.SyntheticClass_1.a[blockwood_enumlogvariant.ordinal()]) {
+                    case 1:
+                    default:
+                        return MaterialMapColor.m;
+
+                    case 2:
+                        return BlockWood.EnumLogVariant.DARK_OAK.c();
+                }
+
+            case 4:
+                return blockwood_enumlogvariant.c();
+        }
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        IBlockData iblockdata = this.getBlockData().set(BlockLog2.VARIANT, BlockWood.EnumLogVariant.a((i & 3) + 4));
+
+        switch (i & 12) {
+            case 0:
+                iblockdata = iblockdata.set(BlockLog2.AXIS, BlockLogAbstract.EnumLogRotation.Y);
+                break;
+
+            case 4:
+                iblockdata = iblockdata.set(BlockLog2.AXIS, BlockLogAbstract.EnumLogRotation.X);
+                break;
+
+            case 8:
+                iblockdata = iblockdata.set(BlockLog2.AXIS, BlockLogAbstract.EnumLogRotation.Z);
+                break;
+
+            default:
+                iblockdata = iblockdata.set(BlockLog2.AXIS, BlockLogAbstract.EnumLogRotation.NONE);
+        }
+
+        return iblockdata;
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((BlockWood.EnumLogVariant) iblockdata.get(BlockLog2.VARIANT)).a() - 4;
+
+        switch (BlockLog2.SyntheticClass_1.b[((BlockLogAbstract.EnumLogRotation) iblockdata.get(BlockLog2.AXIS)).ordinal()]) {
+            case 1:
+                i |= 4;
+                break;
+
+            case 2:
+                i |= 8;
+                break;
+
+            case 3:
+                i |= 12;
+        }
+
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockLog2.VARIANT, BlockLog2.AXIS});
+    }
+
+    protected ItemStack i(IBlockData iblockdata) {
+        return new ItemStack(Item.getItemOf(this), 1, ((BlockWood.EnumLogVariant) iblockdata.get(BlockLog2.VARIANT)).a() - 4);
+    }
+
+    public int getDropData(IBlockData iblockdata) {
+        return ((BlockWood.EnumLogVariant) iblockdata.get(BlockLog2.VARIANT)).a() - 4;
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a;
+        static final int[] b = new int[BlockLogAbstract.EnumLogRotation.values().length];
+
+        static {
+            try {
+                BlockLog2.SyntheticClass_1.b[BlockLogAbstract.EnumLogRotation.X.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                BlockLog2.SyntheticClass_1.b[BlockLogAbstract.EnumLogRotation.Z.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                BlockLog2.SyntheticClass_1.b[BlockLogAbstract.EnumLogRotation.NONE.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                BlockLog2.SyntheticClass_1.b[BlockLogAbstract.EnumLogRotation.Y.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+            a = new int[BlockWood.EnumLogVariant.values().length];
+
+            try {
+                BlockLog2.SyntheticClass_1.a[BlockWood.EnumLogVariant.ACACIA.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror4) {
+                ;
+            }
+
+            try {
+                BlockLog2.SyntheticClass_1.a[BlockWood.EnumLogVariant.DARK_OAK.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror5) {
+                ;
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockLogAbstract.java b/src/main/java/net/minecraft/server/BlockLogAbstract.java
new file mode 100644
index 000000000..cfeaec6dd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockLogAbstract.java
@@ -0,0 +1,99 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+
+public abstract class BlockLogAbstract extends BlockRotatable {
+
+    public static final BlockStateEnum<BlockLogAbstract.EnumLogRotation> AXIS = BlockStateEnum.of("axis", BlockLogAbstract.EnumLogRotation.class);
+
+    public BlockLogAbstract() {
+        super(Material.WOOD);
+        this.a(CreativeModeTab.b);
+        this.c(2.0F);
+        this.a(BlockLogAbstract.f);
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        byte b0 = 4;
+        int i = b0 + 1;
+
+        if (world.areChunksLoadedBetween(blockposition.a(-i, -i, -i), blockposition.a(i, i, i))) {
+            Iterator iterator = BlockPosition.a(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0)).iterator();
+
+            while (iterator.hasNext()) {
+                BlockPosition blockposition1 = (BlockPosition) iterator.next();
+                IBlockData iblockdata1 = world.getType(blockposition1);
+
+                if (iblockdata1.getBlock().getMaterial() == Material.LEAVES && !((Boolean) iblockdata1.get(BlockLeaves.CHECK_DECAY)).booleanValue()) {
+                    world.setTypeAndData(blockposition1, iblockdata1.set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(true)), 4);
+                }
+            }
+
+        }
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        return super.getPlacedState(world, blockposition, enumdirection, f, f1, f2, i, entityliving).set(BlockLogAbstract.AXIS, BlockLogAbstract.EnumLogRotation.a(enumdirection.k()));
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a = new int[EnumDirection.EnumAxis.values().length];
+
+        static {
+            try {
+                BlockLogAbstract.SyntheticClass_1.a[EnumDirection.EnumAxis.X.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                BlockLogAbstract.SyntheticClass_1.a[EnumDirection.EnumAxis.Y.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                BlockLogAbstract.SyntheticClass_1.a[EnumDirection.EnumAxis.Z.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+        }
+    }
+
+    public static enum EnumLogRotation implements INamable {
+
+        X("x"), Y("y"), Z("z"), NONE("none");
+
+        private final String e;
+
+        private EnumLogRotation(String s) {
+            this.e = s;
+        }
+
+        public String toString() {
+            return this.e;
+        }
+
+        public static BlockLogAbstract.EnumLogRotation a(EnumDirection.EnumAxis enumdirection_enumaxis) {
+            switch (BlockLogAbstract.SyntheticClass_1.a[enumdirection_enumaxis.ordinal()]) {
+                case 1:
+                    return BlockLogAbstract.EnumLogRotation.X;
+
+                case 2:
+                    return BlockLogAbstract.EnumLogRotation.Y;
+
+                case 3:
+                    return BlockLogAbstract.EnumLogRotation.Z;
+
+                default:
+                    return BlockLogAbstract.EnumLogRotation.NONE;
+            }
+        }
+
+        public String getName() {
+            return this.e;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockPistonExtension.java b/src/main/java/net/minecraft/server/BlockPistonExtension.java
new file mode 100644
index 000000000..922893aed
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockPistonExtension.java
@@ -0,0 +1,249 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class BlockPistonExtension extends Block {
+
+    public static final BlockStateDirection FACING = BlockStateDirection.of("facing");
+    public static final BlockStateEnum<BlockPistonExtension.EnumPistonType> TYPE = BlockStateEnum.of("type", BlockPistonExtension.EnumPistonType.class);
+    public static final BlockStateBoolean SHORT = BlockStateBoolean.of("short");
+
+    public BlockPistonExtension() {
+        super(Material.PISTON);
+        this.j(this.blockStateList.getBlockData().set(BlockPistonExtension.FACING, EnumDirection.NORTH).set(BlockPistonExtension.TYPE, BlockPistonExtension.EnumPistonType.DEFAULT).set(BlockPistonExtension.SHORT, Boolean.valueOf(false)));
+        this.a(BlockPistonExtension.i);
+        this.c(0.5F);
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman) {
+        if (entityhuman.abilities.canInstantlyBuild) {
+            EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockPistonExtension.FACING);
+
+            if (enumdirection != null) {
+                BlockPosition blockposition1 = blockposition.shift(enumdirection.opposite());
+                Block block = world.getType(blockposition1).getBlock();
+
+                if (block == Blocks.PISTON || block == Blocks.STICKY_PISTON) {
+                    world.setAir(blockposition1);
+                }
+            }
+        }
+
+        super.a(world, blockposition, iblockdata, entityhuman);
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        super.remove(world, blockposition, iblockdata);
+        EnumDirection enumdirection = ((EnumDirection) iblockdata.get(BlockPistonExtension.FACING)).opposite();
+
+        blockposition = blockposition.shift(enumdirection);
+        IBlockData iblockdata1 = world.getType(blockposition);
+
+        if ((iblockdata1.getBlock() == Blocks.PISTON || iblockdata1.getBlock() == Blocks.STICKY_PISTON) && ((Boolean) iblockdata1.get(BlockPiston.EXTENDED)).booleanValue()) {
+            iblockdata1.getBlock().b(world, blockposition, iblockdata1, 0);
+            world.setAir(blockposition);
+        }
+
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return false;
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition, EnumDirection enumdirection) {
+        return false;
+    }
+
+    public int a(Random random) {
+        return 0;
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        this.d(iblockdata);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.e(iblockdata);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+    }
+
+    private void e(IBlockData iblockdata) {
+        float f = 0.25F;
+        float f1 = 0.375F;
+        float f2 = 0.625F;
+        float f3 = 0.25F;
+        float f4 = 0.75F;
+
+        switch (BlockPistonExtension.SyntheticClass_1.a[((EnumDirection) iblockdata.get(BlockPistonExtension.FACING)).ordinal()]) {
+            case 1:
+                this.a(0.375F, 0.25F, 0.375F, 0.625F, 1.0F, 0.625F);
+                break;
+
+            case 2:
+                this.a(0.375F, 0.0F, 0.375F, 0.625F, 0.75F, 0.625F);
+                break;
+
+            case 3:
+                this.a(0.25F, 0.375F, 0.25F, 0.75F, 0.625F, 1.0F);
+                break;
+
+            case 4:
+                this.a(0.25F, 0.375F, 0.0F, 0.75F, 0.625F, 0.75F);
+                break;
+
+            case 5:
+                this.a(0.375F, 0.25F, 0.25F, 0.625F, 0.75F, 1.0F);
+                break;
+
+            case 6:
+                this.a(0.0F, 0.375F, 0.25F, 0.75F, 0.625F, 0.75F);
+        }
+
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        this.d(iblockaccess.getType(blockposition));
+    }
+
+    public void d(IBlockData iblockdata) {
+        float f = 0.25F;
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockPistonExtension.FACING);
+
+        if (enumdirection != null) {
+            switch (BlockPistonExtension.SyntheticClass_1.a[enumdirection.ordinal()]) {
+                case 1:
+                    this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.25F, 1.0F);
+                    break;
+
+                case 2:
+                    this.a(0.0F, 0.75F, 0.0F, 1.0F, 1.0F, 1.0F);
+                    break;
+
+                case 3:
+                    this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 0.25F);
+                    break;
+
+                case 4:
+                    this.a(0.0F, 0.0F, 0.75F, 1.0F, 1.0F, 1.0F);
+                    break;
+
+                case 5:
+                    this.a(0.0F, 0.0F, 0.0F, 0.25F, 1.0F, 1.0F);
+                    break;
+
+                case 6:
+                    this.a(0.75F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+            }
+
+        }
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockPistonExtension.FACING);
+        BlockPosition blockposition1 = blockposition.shift(enumdirection.opposite());
+        IBlockData iblockdata1 = world.getType(blockposition1);
+
+        if (iblockdata1.getBlock() != Blocks.PISTON && iblockdata1.getBlock() != Blocks.STICKY_PISTON) {
+            world.setAir(blockposition);
+        } else {
+            iblockdata1.getBlock().doPhysics(world, blockposition1, iblockdata1, block);
+        }
+
+    }
+
+    public static EnumDirection b(int i) {
+        int j = i & 7;
+
+        return j > 5 ? null : EnumDirection.fromType1(j);
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockPistonExtension.FACING, b(i)).set(BlockPistonExtension.TYPE, (i & 8) > 0 ? BlockPistonExtension.EnumPistonType.STICKY : BlockPistonExtension.EnumPistonType.DEFAULT);
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((EnumDirection) iblockdata.get(BlockPistonExtension.FACING)).a();
+
+        if (iblockdata.get(BlockPistonExtension.TYPE) == BlockPistonExtension.EnumPistonType.STICKY) {
+            i |= 8;
+        }
+
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockPistonExtension.FACING, BlockPistonExtension.TYPE, BlockPistonExtension.SHORT});
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a = new int[EnumDirection.values().length];
+
+        static {
+            try {
+                BlockPistonExtension.SyntheticClass_1.a[EnumDirection.DOWN.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                BlockPistonExtension.SyntheticClass_1.a[EnumDirection.UP.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                BlockPistonExtension.SyntheticClass_1.a[EnumDirection.NORTH.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                BlockPistonExtension.SyntheticClass_1.a[EnumDirection.SOUTH.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+            try {
+                BlockPistonExtension.SyntheticClass_1.a[EnumDirection.WEST.ordinal()] = 5;
+            } catch (NoSuchFieldError nosuchfielderror4) {
+                ;
+            }
+
+            try {
+                BlockPistonExtension.SyntheticClass_1.a[EnumDirection.EAST.ordinal()] = 6;
+            } catch (NoSuchFieldError nosuchfielderror5) {
+                ;
+            }
+
+        }
+    }
+
+    public static enum EnumPistonType implements INamable {
+
+        DEFAULT("normal"), STICKY("sticky");
+
+        private final String c;
+
+        private EnumPistonType(String s) {
+            this.c = s;
+        }
+
+        public String toString() {
+            return this.c;
+        }
+
+        public String getName() {
+            return this.c;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockPistonMoving.java b/src/main/java/net/minecraft/server/BlockPistonMoving.java
new file mode 100644
index 000000000..3b3334365
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockPistonMoving.java
@@ -0,0 +1,210 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockPistonMoving extends BlockContainer {
+
+    public static final BlockStateDirection FACING = BlockPistonExtension.FACING;
+    public static final BlockStateEnum<BlockPistonExtension.EnumPistonType> TYPE = BlockPistonExtension.TYPE;
+
+    public BlockPistonMoving() {
+        super(Material.PISTON);
+        this.j(this.blockStateList.getBlockData().set(BlockPistonMoving.FACING, EnumDirection.NORTH).set(BlockPistonMoving.TYPE, BlockPistonExtension.EnumPistonType.DEFAULT));
+        this.c(-1.0F);
+    }
+
+    public TileEntity a(World world, int i) {
+        return null;
+    }
+
+    public static TileEntity a(IBlockData iblockdata, EnumDirection enumdirection, boolean flag, boolean flag1) {
+        return new TileEntityPiston(iblockdata, enumdirection, flag, flag1);
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (tileentity instanceof TileEntityPiston) {
+            ((TileEntityPiston) tileentity).h();
+        } else {
+            super.remove(world, blockposition, iblockdata);
+        }
+
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return false;
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition, EnumDirection enumdirection) {
+        return false;
+    }
+
+    public void postBreak(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        BlockPosition blockposition1 = blockposition.shift(((EnumDirection) iblockdata.get(BlockPistonMoving.FACING)).opposite());
+        IBlockData iblockdata1 = world.getType(blockposition1);
+
+        if (iblockdata1.getBlock() instanceof BlockPiston && ((Boolean) iblockdata1.get(BlockPiston.EXTENDED)).booleanValue()) {
+            world.setAir(blockposition1);
+        }
+
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (!world.isClientSide && world.getTileEntity(blockposition) == null) {
+            world.setAir(blockposition);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return null;
+    }
+
+    public void dropNaturally(World world, BlockPosition blockposition, IBlockData iblockdata, float f, int i) {
+        if (!world.isClientSide) {
+            TileEntityPiston tileentitypiston = this.e((IBlockAccess) world, blockposition);
+
+            if (tileentitypiston != null) {
+                IBlockData iblockdata1 = tileentitypiston.b();
+
+                iblockdata1.getBlock().b(world, blockposition, iblockdata1, 0);
+            }
+        }
+    }
+
+    public MovingObjectPosition a(World world, BlockPosition blockposition, Vec3D vec3d, Vec3D vec3d1) {
+        return null;
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        if (!world.isClientSide) {
+            world.getTileEntity(blockposition);
+        }
+
+    }
+
+    public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        TileEntityPiston tileentitypiston = this.e((IBlockAccess) world, blockposition);
+
+        if (tileentitypiston == null) {
+            return null;
+        } else {
+            float f = tileentitypiston.a(0.0F);
+
+            if (tileentitypiston.d()) {
+                f = 1.0F - f;
+            }
+
+            return this.a(world, blockposition, tileentitypiston.b(), f, tileentitypiston.e());
+        }
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        TileEntityPiston tileentitypiston = this.e(iblockaccess, blockposition);
+
+        if (tileentitypiston != null) {
+            IBlockData iblockdata = tileentitypiston.b();
+            Block block = iblockdata.getBlock();
+
+            if (block == this || block.getMaterial() == Material.AIR) {
+                return;
+            }
+
+            float f = tileentitypiston.a(0.0F);
+
+            if (tileentitypiston.d()) {
+                f = 1.0F - f;
+            }
+
+            block.updateShape(iblockaccess, blockposition);
+            if (block == Blocks.PISTON || block == Blocks.STICKY_PISTON) {
+                f = 0.0F;
+            }
+
+            EnumDirection enumdirection = tileentitypiston.e();
+
+            this.minX = block.B() - (double) ((float) enumdirection.getAdjacentX() * f);
+            this.minY = block.D() - (double) ((float) enumdirection.getAdjacentY() * f);
+            this.minZ = block.F() - (double) ((float) enumdirection.getAdjacentZ() * f);
+            this.maxX = block.C() - (double) ((float) enumdirection.getAdjacentX() * f);
+            this.maxY = block.E() - (double) ((float) enumdirection.getAdjacentY() * f);
+            this.maxZ = block.G() - (double) ((float) enumdirection.getAdjacentZ() * f);
+        }
+
+    }
+
+    public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata, float f, EnumDirection enumdirection) {
+        if (iblockdata.getBlock() != this && iblockdata.getBlock().getMaterial() != Material.AIR) {
+            AxisAlignedBB axisalignedbb = iblockdata.getBlock().a(world, blockposition, iblockdata);
+
+            if (axisalignedbb == null) {
+                return null;
+            } else {
+                double d0 = axisalignedbb.a;
+                double d1 = axisalignedbb.b;
+                double d2 = axisalignedbb.c;
+                double d3 = axisalignedbb.d;
+                double d4 = axisalignedbb.e;
+                double d5 = axisalignedbb.f;
+
+                if (enumdirection.getAdjacentX() < 0) {
+                    d0 -= (double) ((float) enumdirection.getAdjacentX() * f);
+                } else {
+                    d3 -= (double) ((float) enumdirection.getAdjacentX() * f);
+                }
+
+                if (enumdirection.getAdjacentY() < 0) {
+                    d1 -= (double) ((float) enumdirection.getAdjacentY() * f);
+                } else {
+                    d4 -= (double) ((float) enumdirection.getAdjacentY() * f);
+                }
+
+                if (enumdirection.getAdjacentZ() < 0) {
+                    d2 -= (double) ((float) enumdirection.getAdjacentZ() * f);
+                } else {
+                    d5 -= (double) ((float) enumdirection.getAdjacentZ() * f);
+                }
+
+                return new AxisAlignedBB(d0, d1, d2, d3, d4, d5);
+            }
+        } else {
+            return null;
+        }
+    }
+
+    private TileEntityPiston e(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        TileEntity tileentity = iblockaccess.getTileEntity(blockposition);
+
+        return tileentity instanceof TileEntityPiston ? (TileEntityPiston) tileentity : null;
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockPistonMoving.FACING, BlockPistonExtension.b(i)).set(BlockPistonMoving.TYPE, (i & 8) > 0 ? BlockPistonExtension.EnumPistonType.STICKY : BlockPistonExtension.EnumPistonType.DEFAULT);
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((EnumDirection) iblockdata.get(BlockPistonMoving.FACING)).a();
+
+        if (iblockdata.get(BlockPistonMoving.TYPE) == BlockPistonExtension.EnumPistonType.STICKY) {
+            i |= 8;
+        }
+
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockPistonMoving.FACING, BlockPistonMoving.TYPE});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockRepeater.java b/src/main/java/net/minecraft/server/BlockRepeater.java
new file mode 100644
index 000000000..29a242831
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockRepeater.java
@@ -0,0 +1,84 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockRepeater extends BlockDiodeAbstract {
+
+    public static final BlockStateBoolean LOCKED = BlockStateBoolean.of("locked");
+    public static final BlockStateInteger DELAY = BlockStateInteger.of("delay", 1, 4);
+
+    protected BlockRepeater(boolean flag) {
+        super(flag);
+        this.j(this.blockStateList.getBlockData().set(BlockRepeater.FACING, EnumDirection.NORTH).set(BlockRepeater.DELAY, Integer.valueOf(1)).set(BlockRepeater.LOCKED, Boolean.valueOf(false)));
+    }
+
+    public String getName() {
+        return LocaleI18n.get("item.diode.name");
+    }
+
+    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return iblockdata.set(BlockRepeater.LOCKED, Boolean.valueOf(this.b(iblockaccess, blockposition, iblockdata)));
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (!entityhuman.abilities.mayBuild) {
+            return false;
+        } else {
+            world.setTypeAndData(blockposition, iblockdata.a(BlockRepeater.DELAY), 3);
+            return true;
+        }
+    }
+
+    protected int d(IBlockData iblockdata) {
+        return ((Integer) iblockdata.get(BlockRepeater.DELAY)).intValue() * 2;
+    }
+
+    protected IBlockData e(IBlockData iblockdata) {
+        Integer integer = (Integer) iblockdata.get(BlockRepeater.DELAY);
+        Boolean obool = (Boolean) iblockdata.get(BlockRepeater.LOCKED);
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockRepeater.FACING);
+
+        return Blocks.POWERED_REPEATER.getBlockData().set(BlockRepeater.FACING, enumdirection).set(BlockRepeater.DELAY, integer).set(BlockRepeater.LOCKED, obool);
+    }
+
+    protected IBlockData k(IBlockData iblockdata) {
+        Integer integer = (Integer) iblockdata.get(BlockRepeater.DELAY);
+        Boolean obool = (Boolean) iblockdata.get(BlockRepeater.LOCKED);
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockRepeater.FACING);
+
+        return Blocks.UNPOWERED_REPEATER.getBlockData().set(BlockRepeater.FACING, enumdirection).set(BlockRepeater.DELAY, integer).set(BlockRepeater.LOCKED, obool);
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return Items.REPEATER;
+    }
+
+    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
+        return this.c(iblockaccess, blockposition, iblockdata) > 0;
+    }
+
+    protected boolean c(Block block) {
+        return d(block);
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        super.remove(world, blockposition, iblockdata);
+        this.h(world, blockposition, iblockdata);
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockRepeater.FACING, EnumDirection.fromType2(i)).set(BlockRepeater.LOCKED, Boolean.valueOf(false)).set(BlockRepeater.DELAY, Integer.valueOf(1 + (i >> 2)));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        byte b0 = 0;
+        int i = b0 | ((EnumDirection) iblockdata.get(BlockRepeater.FACING)).b();
+
+        i |= ((Integer) iblockdata.get(BlockRepeater.DELAY)).intValue() - 1 << 2;
+        return i;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockRepeater.FACING, BlockRepeater.DELAY, BlockRepeater.LOCKED});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockSlime.java b/src/main/java/net/minecraft/server/BlockSlime.java
new file mode 100644
index 000000000..331bafa03
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockSlime.java
@@ -0,0 +1,39 @@
+package net.minecraft.server;
+
+public class BlockSlime extends BlockHalfTransparent {
+
+    public BlockSlime() {
+        super(Material.CLAY, false, MaterialMapColor.c);
+        this.a(CreativeModeTab.c);
+        this.frictionFactor = 0.8F;
+    }
+
+    public void fallOn(World world, BlockPosition blockposition, Entity entity, float f) {
+        if (entity.isSneaking()) {
+            super.fallOn(world, blockposition, entity, f);
+        } else {
+            entity.e(f, 0.0F);
+        }
+
+    }
+
+    public void a(World world, Entity entity) {
+        if (entity.isSneaking()) {
+            super.a(world, entity);
+        } else if (entity.motY < 0.0D) {
+            entity.motY = -entity.motY;
+        }
+
+    }
+
+    public void a(World world, BlockPosition blockposition, Entity entity) {
+        if (Math.abs(entity.motY) < 0.1D && !entity.isSneaking()) {
+            double d0 = 0.4D + Math.abs(entity.motY) * 0.2D;
+
+            entity.motX *= d0;
+            entity.motZ *= d0;
+        }
+
+        super.a(world, blockposition, entity);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockSponge.java b/src/main/java/net/minecraft/server/BlockSponge.java
new file mode 100644
index 000000000..de7714ea5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockSponge.java
@@ -0,0 +1,100 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedList;
+
+public class BlockSponge extends Block {
+
+    public static final BlockStateBoolean WET = BlockStateBoolean.of("wet");
+
+    protected BlockSponge() {
+        super(Material.SPONGE);
+        this.j(this.blockStateList.getBlockData().set(BlockSponge.WET, Boolean.valueOf(false)));
+        this.a(CreativeModeTab.b);
+    }
+
+    public String getName() {
+        return LocaleI18n.get(this.a() + ".dry.name");
+    }
+
+    public int getDropData(IBlockData iblockdata) {
+        return ((Boolean) iblockdata.get(BlockSponge.WET)).booleanValue() ? 1 : 0;
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.e(world, blockposition, iblockdata);
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        this.e(world, blockposition, iblockdata);
+        super.doPhysics(world, blockposition, iblockdata, block);
+    }
+
+    protected void e(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (!((Boolean) iblockdata.get(BlockSponge.WET)).booleanValue() && this.e(world, blockposition)) {
+            world.setTypeAndData(blockposition, iblockdata.set(BlockSponge.WET, Boolean.valueOf(true)), 2);
+            world.triggerEffect(2001, blockposition, Block.getId(Blocks.WATER));
+        }
+
+    }
+
+    private boolean e(World world, BlockPosition blockposition) {
+        LinkedList linkedlist = Lists.newLinkedList();
+        ArrayList arraylist = Lists.newArrayList();
+
+        linkedlist.add(new Tuple(blockposition, Integer.valueOf(0)));
+        int i = 0;
+
+        BlockPosition blockposition1;
+
+        while (!linkedlist.isEmpty()) {
+            Tuple tuple = (Tuple) linkedlist.poll();
+
+            blockposition1 = (BlockPosition) tuple.a();
+            int j = ((Integer) tuple.b()).intValue();
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int k = aenumdirection.length;
+
+            for (int l = 0; l < k; ++l) {
+                EnumDirection enumdirection = aenumdirection[l];
+                BlockPosition blockposition2 = blockposition1.shift(enumdirection);
+
+                if (world.getType(blockposition2).getBlock().getMaterial() == Material.WATER) {
+                    world.setTypeAndData(blockposition2, Blocks.AIR.getBlockData(), 2);
+                    arraylist.add(blockposition2);
+                    ++i;
+                    if (j < 6) {
+                        linkedlist.add(new Tuple(blockposition2, Integer.valueOf(j + 1)));
+                    }
+                }
+            }
+
+            if (i > 64) {
+                break;
+            }
+        }
+
+        Iterator iterator = arraylist.iterator();
+
+        while (iterator.hasNext()) {
+            blockposition1 = (BlockPosition) iterator.next();
+            world.applyPhysics(blockposition1, Blocks.AIR);
+        }
+
+        return i > 0;
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockSponge.WET, Boolean.valueOf((i & 1) == 1));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((Boolean) iblockdata.get(BlockSponge.WET)).booleanValue() ? 1 : 0;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockSponge.WET});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStairs.java b/src/main/java/net/minecraft/server/BlockStairs.java
new file mode 100644
index 000000000..fb2ddf5b8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStairs.java
@@ -0,0 +1,595 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+
+public class BlockStairs extends Block {
+
+    public static final BlockStateDirection FACING = BlockStateDirection.of("facing", (Predicate) EnumDirection.EnumDirectionLimit.HORIZONTAL);
+    public static final BlockStateEnum<EnumHalf> HALF = BlockStateEnum.of("half", EnumHalf.class);
+    public static final BlockStateEnum<EnumStairShape> SHAPE = BlockStateEnum.of("shape", EnumStairShape.class);
+    private static final int[][] O = new int[][] { { 4, 5}, { 5, 7}, { 6, 7}, { 4, 6}, { 0, 1}, { 1, 3}, { 2, 3}, { 0, 2}};
+    private final Block P;
+    private final IBlockData Q;
+    private boolean R;
+    private int S;
+
+    protected BlockStairs(IBlockData iblockdata) {
+        super(iblockdata.getBlock().material);
+        this.j(this.blockStateList.getBlockData().set(BlockStairs.FACING, EnumDirection.NORTH).set(BlockStairs.HALF, EnumHalf.BOTTOM).set(BlockStairs.SHAPE, EnumStairShape.STRAIGHT));
+        this.P = iblockdata.getBlock();
+        this.Q = iblockdata;
+        this.c(this.P.strength);
+        this.b(this.P.durability / 3.0F);
+        this.a(this.P.stepSound);
+        this.e(255);
+        this.a(CreativeModeTab.b);
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        if (this.R) {
+            this.a(0.5F * (float) (this.S % 2), 0.5F * (float) (this.S / 4 % 2), 0.5F * (float) (this.S / 2 % 2), 0.5F + 0.5F * (float) (this.S % 2), 0.5F + 0.5F * (float) (this.S / 4 % 2), 0.5F + 0.5F * (float) (this.S / 2 % 2));
+        } else {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+        }
+
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public void e(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        if (iblockaccess.getType(blockposition).get(BlockStairs.HALF) == EnumHalf.TOP) {
+            this.a(0.0F, 0.5F, 0.0F, 1.0F, 1.0F, 1.0F);
+        } else {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+        }
+
+    }
+
+    public static boolean c(Block block) {
+        return block instanceof BlockStairs;
+    }
+
+    public static boolean a(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
+        IBlockData iblockdata1 = iblockaccess.getType(blockposition);
+        Block block = iblockdata1.getBlock();
+
+        return c(block) && iblockdata1.get(BlockStairs.HALF) == iblockdata.get(BlockStairs.HALF) && iblockdata1.get(BlockStairs.FACING) == iblockdata.get(BlockStairs.FACING);
+    }
+
+    public int f(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockStairs.FACING);
+        EnumHalf blockstairs_enumhalf = (EnumHalf) iblockdata.get(BlockStairs.HALF);
+        boolean flag = blockstairs_enumhalf == EnumHalf.TOP;
+        IBlockData iblockdata1;
+        Block block;
+        EnumDirection enumdirection1;
+
+        if (enumdirection == EnumDirection.EAST) {
+            iblockdata1 = iblockaccess.getType(blockposition.east());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.NORTH && !a(iblockaccess, blockposition.south(), iblockdata)) {
+                    return flag ? 1 : 2;
+                }
+
+                if (enumdirection1 == EnumDirection.SOUTH && !a(iblockaccess, blockposition.north(), iblockdata)) {
+                    return flag ? 2 : 1;
+                }
+            }
+        } else if (enumdirection == EnumDirection.WEST) {
+            iblockdata1 = iblockaccess.getType(blockposition.west());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.NORTH && !a(iblockaccess, blockposition.south(), iblockdata)) {
+                    return flag ? 2 : 1;
+                }
+
+                if (enumdirection1 == EnumDirection.SOUTH && !a(iblockaccess, blockposition.north(), iblockdata)) {
+                    return flag ? 1 : 2;
+                }
+            }
+        } else if (enumdirection == EnumDirection.SOUTH) {
+            iblockdata1 = iblockaccess.getType(blockposition.south());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.WEST && !a(iblockaccess, blockposition.east(), iblockdata)) {
+                    return flag ? 2 : 1;
+                }
+
+                if (enumdirection1 == EnumDirection.EAST && !a(iblockaccess, blockposition.west(), iblockdata)) {
+                    return flag ? 1 : 2;
+                }
+            }
+        } else if (enumdirection == EnumDirection.NORTH) {
+            iblockdata1 = iblockaccess.getType(blockposition.north());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.WEST && !a(iblockaccess, blockposition.east(), iblockdata)) {
+                    return flag ? 1 : 2;
+                }
+
+                if (enumdirection1 == EnumDirection.EAST && !a(iblockaccess, blockposition.west(), iblockdata)) {
+                    return flag ? 2 : 1;
+                }
+            }
+        }
+
+        return 0;
+    }
+
+    public int g(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockStairs.FACING);
+        EnumHalf blockstairs_enumhalf = (EnumHalf) iblockdata.get(BlockStairs.HALF);
+        boolean flag = blockstairs_enumhalf == EnumHalf.TOP;
+        IBlockData iblockdata1;
+        Block block;
+        EnumDirection enumdirection1;
+
+        if (enumdirection == EnumDirection.EAST) {
+            iblockdata1 = iblockaccess.getType(blockposition.west());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.NORTH && !a(iblockaccess, blockposition.north(), iblockdata)) {
+                    return flag ? 1 : 2;
+                }
+
+                if (enumdirection1 == EnumDirection.SOUTH && !a(iblockaccess, blockposition.south(), iblockdata)) {
+                    return flag ? 2 : 1;
+                }
+            }
+        } else if (enumdirection == EnumDirection.WEST) {
+            iblockdata1 = iblockaccess.getType(blockposition.east());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.NORTH && !a(iblockaccess, blockposition.north(), iblockdata)) {
+                    return flag ? 2 : 1;
+                }
+
+                if (enumdirection1 == EnumDirection.SOUTH && !a(iblockaccess, blockposition.south(), iblockdata)) {
+                    return flag ? 1 : 2;
+                }
+            }
+        } else if (enumdirection == EnumDirection.SOUTH) {
+            iblockdata1 = iblockaccess.getType(blockposition.north());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.WEST && !a(iblockaccess, blockposition.west(), iblockdata)) {
+                    return flag ? 2 : 1;
+                }
+
+                if (enumdirection1 == EnumDirection.EAST && !a(iblockaccess, blockposition.east(), iblockdata)) {
+                    return flag ? 1 : 2;
+                }
+            }
+        } else if (enumdirection == EnumDirection.NORTH) {
+            iblockdata1 = iblockaccess.getType(blockposition.south());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.WEST && !a(iblockaccess, blockposition.west(), iblockdata)) {
+                    return flag ? 1 : 2;
+                }
+
+                if (enumdirection1 == EnumDirection.EAST && !a(iblockaccess, blockposition.east(), iblockdata)) {
+                    return flag ? 2 : 1;
+                }
+            }
+        }
+
+        return 0;
+    }
+
+    public boolean h(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockStairs.FACING);
+        EnumHalf blockstairs_enumhalf = (EnumHalf) iblockdata.get(BlockStairs.HALF);
+        boolean flag = blockstairs_enumhalf == EnumHalf.TOP;
+        float f = 0.5F;
+        float f1 = 1.0F;
+
+        if (flag) {
+            f = 0.0F;
+            f1 = 0.5F;
+        }
+
+        float f2 = 0.0F;
+        float f3 = 1.0F;
+        float f4 = 0.0F;
+        float f5 = 0.5F;
+        boolean flag1 = true;
+        IBlockData iblockdata1;
+        Block block;
+        EnumDirection enumdirection1;
+
+        if (enumdirection == EnumDirection.EAST) {
+            f2 = 0.5F;
+            f5 = 1.0F;
+            iblockdata1 = iblockaccess.getType(blockposition.east());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.NORTH && !a(iblockaccess, blockposition.south(), iblockdata)) {
+                    f5 = 0.5F;
+                    flag1 = false;
+                } else if (enumdirection1 == EnumDirection.SOUTH && !a(iblockaccess, blockposition.north(), iblockdata)) {
+                    f4 = 0.5F;
+                    flag1 = false;
+                }
+            }
+        } else if (enumdirection == EnumDirection.WEST) {
+            f3 = 0.5F;
+            f5 = 1.0F;
+            iblockdata1 = iblockaccess.getType(blockposition.west());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.NORTH && !a(iblockaccess, blockposition.south(), iblockdata)) {
+                    f5 = 0.5F;
+                    flag1 = false;
+                } else if (enumdirection1 == EnumDirection.SOUTH && !a(iblockaccess, blockposition.north(), iblockdata)) {
+                    f4 = 0.5F;
+                    flag1 = false;
+                }
+            }
+        } else if (enumdirection == EnumDirection.SOUTH) {
+            f4 = 0.5F;
+            f5 = 1.0F;
+            iblockdata1 = iblockaccess.getType(blockposition.south());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.WEST && !a(iblockaccess, blockposition.east(), iblockdata)) {
+                    f3 = 0.5F;
+                    flag1 = false;
+                } else if (enumdirection1 == EnumDirection.EAST && !a(iblockaccess, blockposition.west(), iblockdata)) {
+                    f2 = 0.5F;
+                    flag1 = false;
+                }
+            }
+        } else if (enumdirection == EnumDirection.NORTH) {
+            iblockdata1 = iblockaccess.getType(blockposition.north());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.WEST && !a(iblockaccess, blockposition.east(), iblockdata)) {
+                    f3 = 0.5F;
+                    flag1 = false;
+                } else if (enumdirection1 == EnumDirection.EAST && !a(iblockaccess, blockposition.west(), iblockdata)) {
+                    f2 = 0.5F;
+                    flag1 = false;
+                }
+            }
+        }
+
+        this.a(f2, f, f4, f3, f1, f5);
+        return flag1;
+    }
+
+    public boolean i(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockStairs.FACING);
+        EnumHalf blockstairs_enumhalf = (EnumHalf) iblockdata.get(BlockStairs.HALF);
+        boolean flag = blockstairs_enumhalf == EnumHalf.TOP;
+        float f = 0.5F;
+        float f1 = 1.0F;
+
+        if (flag) {
+            f = 0.0F;
+            f1 = 0.5F;
+        }
+
+        float f2 = 0.0F;
+        float f3 = 0.5F;
+        float f4 = 0.5F;
+        float f5 = 1.0F;
+        boolean flag1 = false;
+        IBlockData iblockdata1;
+        Block block;
+        EnumDirection enumdirection1;
+
+        if (enumdirection == EnumDirection.EAST) {
+            iblockdata1 = iblockaccess.getType(blockposition.west());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.NORTH && !a(iblockaccess, blockposition.north(), iblockdata)) {
+                    f4 = 0.0F;
+                    f5 = 0.5F;
+                    flag1 = true;
+                } else if (enumdirection1 == EnumDirection.SOUTH && !a(iblockaccess, blockposition.south(), iblockdata)) {
+                    f4 = 0.5F;
+                    f5 = 1.0F;
+                    flag1 = true;
+                }
+            }
+        } else if (enumdirection == EnumDirection.WEST) {
+            iblockdata1 = iblockaccess.getType(blockposition.east());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                f2 = 0.5F;
+                f3 = 1.0F;
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.NORTH && !a(iblockaccess, blockposition.north(), iblockdata)) {
+                    f4 = 0.0F;
+                    f5 = 0.5F;
+                    flag1 = true;
+                } else if (enumdirection1 == EnumDirection.SOUTH && !a(iblockaccess, blockposition.south(), iblockdata)) {
+                    f4 = 0.5F;
+                    f5 = 1.0F;
+                    flag1 = true;
+                }
+            }
+        } else if (enumdirection == EnumDirection.SOUTH) {
+            iblockdata1 = iblockaccess.getType(blockposition.north());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                f4 = 0.0F;
+                f5 = 0.5F;
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.WEST && !a(iblockaccess, blockposition.west(), iblockdata)) {
+                    flag1 = true;
+                } else if (enumdirection1 == EnumDirection.EAST && !a(iblockaccess, blockposition.east(), iblockdata)) {
+                    f2 = 0.5F;
+                    f3 = 1.0F;
+                    flag1 = true;
+                }
+            }
+        } else if (enumdirection == EnumDirection.NORTH) {
+            iblockdata1 = iblockaccess.getType(blockposition.south());
+            block = iblockdata1.getBlock();
+            if (c(block) && blockstairs_enumhalf == iblockdata1.get(BlockStairs.HALF)) {
+                enumdirection1 = (EnumDirection) iblockdata1.get(BlockStairs.FACING);
+                if (enumdirection1 == EnumDirection.WEST && !a(iblockaccess, blockposition.west(), iblockdata)) {
+                    flag1 = true;
+                } else if (enumdirection1 == EnumDirection.EAST && !a(iblockaccess, blockposition.east(), iblockdata)) {
+                    f2 = 0.5F;
+                    f3 = 1.0F;
+                    flag1 = true;
+                }
+            }
+        }
+
+        if (flag1) {
+            this.a(f2, f, f4, f3, f1, f5);
+        }
+
+        return flag1;
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        this.e(world, blockposition);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        boolean flag = this.h(world, blockposition);
+
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        if (flag && this.i(world, blockposition)) {
+            super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        }
+
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+    }
+
+    public void attack(World world, BlockPosition blockposition, EntityHuman entityhuman) {
+        this.P.attack(world, blockposition, entityhuman);
+    }
+
+    public void postBreak(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.P.postBreak(world, blockposition, iblockdata);
+    }
+
+    public float a(Entity entity) {
+        return this.P.a(entity);
+    }
+
+    public int a(World world) {
+        return this.P.a(world);
+    }
+
+    public Vec3D a(World world, BlockPosition blockposition, Entity entity, Vec3D vec3d) {
+        return this.P.a(world, blockposition, entity, vec3d);
+    }
+
+    public boolean A() {
+        return this.P.A();
+    }
+
+    public boolean a(IBlockData iblockdata, boolean flag) {
+        return this.P.a(iblockdata, flag);
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return this.P.canPlace(world, blockposition);
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.doPhysics(world, blockposition, this.Q, Blocks.AIR);
+        this.P.onPlace(world, blockposition, this.Q);
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.P.remove(world, blockposition, this.Q);
+    }
+
+    public void a(World world, BlockPosition blockposition, Entity entity) {
+        this.P.a(world, blockposition, entity);
+    }
+
+    public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
+        this.P.b(world, blockposition, iblockdata, random);
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        return this.P.interact(world, blockposition, this.Q, entityhuman, EnumDirection.DOWN, 0.0F, 0.0F, 0.0F);
+    }
+
+    public void wasExploded(World world, BlockPosition blockposition, Explosion explosion) {
+        this.P.wasExploded(world, blockposition, explosion);
+    }
+
+    public MaterialMapColor g(IBlockData iblockdata) {
+        return this.P.g(this.Q);
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        IBlockData iblockdata = super.getPlacedState(world, blockposition, enumdirection, f, f1, f2, i, entityliving);
+
+        iblockdata = iblockdata.set(BlockStairs.FACING, entityliving.getDirection()).set(BlockStairs.SHAPE, EnumStairShape.STRAIGHT);
+        return enumdirection != EnumDirection.DOWN && (enumdirection == EnumDirection.UP || (double) f1 <= 0.5D) ? iblockdata.set(BlockStairs.HALF, EnumHalf.BOTTOM) : iblockdata.set(BlockStairs.HALF, EnumHalf.TOP);
+    }
+
+    public MovingObjectPosition a(World world, BlockPosition blockposition, Vec3D vec3d, Vec3D vec3d1) {
+        MovingObjectPosition[] amovingobjectposition = new MovingObjectPosition[8];
+        IBlockData iblockdata = world.getType(blockposition);
+        int i = ((EnumDirection) iblockdata.get(BlockStairs.FACING)).b();
+        boolean flag = iblockdata.get(BlockStairs.HALF) == EnumHalf.TOP;
+        int[] aint = BlockStairs.O[i + (flag ? 4 : 0)];
+
+        this.R = true;
+
+        for (int j = 0; j < 8; ++j) {
+            this.S = j;
+            if (Arrays.binarySearch(aint, j) < 0) {
+                amovingobjectposition[j] = super.a(world, blockposition, vec3d, vec3d1);
+            }
+        }
+
+        int[] aint1 = aint;
+        int k = aint.length;
+
+        for (int l = 0; l < k; ++l) {
+            int i1 = aint1[l];
+
+            amovingobjectposition[i1] = null;
+        }
+
+        MovingObjectPosition movingobjectposition = null;
+        double d0 = 0.0D;
+        MovingObjectPosition[] amovingobjectposition1 = amovingobjectposition;
+        int j1 = amovingobjectposition.length;
+
+        for (int k1 = 0; k1 < j1; ++k1) {
+            MovingObjectPosition movingobjectposition1 = amovingobjectposition1[k1];
+
+            if (movingobjectposition1 != null) {
+                double d1 = movingobjectposition1.pos.distanceSquared(vec3d1);
+
+                if (d1 > d0) {
+                    movingobjectposition = movingobjectposition1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return movingobjectposition;
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        IBlockData iblockdata = this.getBlockData().set(BlockStairs.HALF, (i & 4) > 0 ? EnumHalf.TOP : EnumHalf.BOTTOM);
+
+        iblockdata = iblockdata.set(BlockStairs.FACING, EnumDirection.fromType1(5 - (i & 3)));
+        return iblockdata;
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        int i = 0;
+
+        if (iblockdata.get(BlockStairs.HALF) == EnumHalf.TOP) {
+            i |= 4;
+        }
+
+        i |= 5 - ((EnumDirection) iblockdata.get(BlockStairs.FACING)).a();
+        return i;
+    }
+
+    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        if (this.h(iblockaccess, blockposition)) {
+            switch (this.g(iblockaccess, blockposition)) {
+            case 0:
+                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.STRAIGHT);
+                break;
+
+            case 1:
+                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.INNER_RIGHT);
+                break;
+
+            case 2:
+                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.INNER_LEFT);
+            }
+        } else {
+            switch (this.f(iblockaccess, blockposition)) {
+            case 0:
+                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.STRAIGHT);
+                break;
+
+            case 1:
+                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.OUTER_RIGHT);
+                break;
+
+            case 2:
+                iblockdata = iblockdata.set(BlockStairs.SHAPE, EnumStairShape.OUTER_LEFT);
+            }
+        }
+
+        return iblockdata;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockStairs.FACING, BlockStairs.HALF, BlockStairs.SHAPE});
+    }
+
+    public static enum EnumStairShape implements INamable {
+
+        STRAIGHT("straight"), INNER_LEFT("inner_left"), INNER_RIGHT("inner_right"), OUTER_LEFT("outer_left"), OUTER_RIGHT("outer_right");
+
+        private final String f;
+
+        private EnumStairShape(String s) {
+            this.f = s;
+        }
+
+        public String toString() {
+            return this.f;
+        }
+
+        public String getName() {
+            return this.f;
+        }
+    }
+
+    public static enum EnumHalf implements INamable {
+
+        TOP("top"), BOTTOM("bottom");
+
+        private final String c;
+
+        private EnumHalf(String s) {
+            this.c = s;
+        }
+
+        public String toString() {
+            return this.c;
+        }
+
+        public String getName() {
+            return this.c;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStep.java b/src/main/java/net/minecraft/server/BlockStep.java
new file mode 100644
index 000000000..e69bbe07d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStep.java
@@ -0,0 +1,10 @@
+package net.minecraft.server;
+
+public class BlockStep extends BlockDoubleStepAbstract {
+
+    public BlockStep() {}
+
+    public boolean l() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStepAbstract.java b/src/main/java/net/minecraft/server/BlockStepAbstract.java
new file mode 100644
index 000000000..70db05c40
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStepAbstract.java
@@ -0,0 +1,104 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public abstract class BlockStepAbstract extends Block {
+
+    public static final BlockStateEnum<EnumSlabHalf> HALF = BlockStateEnum.of("half", EnumSlabHalf.class);
+
+    public BlockStepAbstract(Material material) {
+        super(material);
+        if (this.l()) {
+            this.r = true;
+        } else {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+        }
+
+        this.e(255);
+    }
+
+    protected boolean I() {
+        return false;
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        if (this.l()) {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+        } else {
+            IBlockData iblockdata = iblockaccess.getType(blockposition);
+
+            if (iblockdata.getBlock() == this) {
+                if (iblockdata.get(BlockStepAbstract.HALF) == EnumSlabHalf.TOP) {
+                    this.a(0.0F, 0.5F, 0.0F, 1.0F, 1.0F, 1.0F);
+                } else {
+                    this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+                }
+            }
+
+        }
+    }
+
+    public void j() {
+        if (this.l()) {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+        } else {
+            this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
+        }
+
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        this.updateShape(world, blockposition);
+        super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+    }
+
+    public boolean c() {
+        return this.l();
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        IBlockData iblockdata = super.getPlacedState(world, blockposition, enumdirection, f, f1, f2, i, entityliving).set(BlockStepAbstract.HALF, EnumSlabHalf.BOTTOM);
+
+        return this.l() ? iblockdata : (enumdirection != EnumDirection.DOWN && (enumdirection == EnumDirection.UP || (double) f1 <= 0.5D) ? iblockdata : iblockdata.set(BlockStepAbstract.HALF, EnumSlabHalf.TOP));
+    }
+
+    public int a(Random random) {
+        return this.l() ? 2 : 1;
+    }
+
+    public boolean d() {
+        return this.l();
+    }
+
+    public abstract String b(int i);
+
+    public int getDropData(World world, BlockPosition blockposition) {
+        return super.getDropData(world, blockposition) & 7;
+    }
+
+    public abstract boolean l();
+
+    public abstract IBlockState<?> n();
+
+    public abstract Object a(ItemStack itemstack);
+
+    public static enum EnumSlabHalf implements INamable {
+
+        TOP("top"), BOTTOM("bottom");
+
+        private final String c;
+
+        private EnumSlabHalf(String s) {
+            this.c = s;
+        }
+
+        public String toString() {
+            return this.c;
+        }
+
+        public String getName() {
+            return this.c;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStoneStep2.java b/src/main/java/net/minecraft/server/BlockStoneStep2.java
new file mode 100644
index 000000000..e1e4081a1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStoneStep2.java
@@ -0,0 +1,10 @@
+package net.minecraft.server;
+
+public class BlockStoneStep2 extends BlockDoubleStoneStepAbstract {
+
+    public BlockStoneStep2() {}
+
+    public boolean l() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockThin.java b/src/main/java/net/minecraft/server/BlockThin.java
new file mode 100644
index 000000000..5a89a779c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockThin.java
@@ -0,0 +1,125 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class BlockThin extends Block {
+
+    public static final BlockStateBoolean NORTH = BlockStateBoolean.of("north");
+    public static final BlockStateBoolean EAST = BlockStateBoolean.of("east");
+    public static final BlockStateBoolean SOUTH = BlockStateBoolean.of("south");
+    public static final BlockStateBoolean WEST = BlockStateBoolean.of("west");
+    private final boolean a;
+
+    protected BlockThin(Material material, boolean flag) {
+        super(material);
+        this.j(this.blockStateList.getBlockData().set(BlockThin.NORTH, Boolean.valueOf(false)).set(BlockThin.EAST, Boolean.valueOf(false)).set(BlockThin.SOUTH, Boolean.valueOf(false)).set(BlockThin.WEST, Boolean.valueOf(false)));
+        this.a = flag;
+        this.a(CreativeModeTab.c);
+    }
+
+    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return iblockdata.set(BlockThin.NORTH, Boolean.valueOf(this.c(iblockaccess.getType(blockposition.north()).getBlock()))).set(BlockThin.SOUTH, Boolean.valueOf(this.c(iblockaccess.getType(blockposition.south()).getBlock()))).set(BlockThin.WEST, Boolean.valueOf(this.c(iblockaccess.getType(blockposition.west()).getBlock()))).set(BlockThin.EAST, Boolean.valueOf(this.c(iblockaccess.getType(blockposition.east()).getBlock())));
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return !this.a ? null : super.getDropType(iblockdata, random, i);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+        boolean flag = this.c(world.getType(blockposition.north()).getBlock());
+        boolean flag1 = this.c(world.getType(blockposition.south()).getBlock());
+        boolean flag2 = this.c(world.getType(blockposition.west()).getBlock());
+        boolean flag3 = this.c(world.getType(blockposition.east()).getBlock());
+
+        if ((!flag2 || !flag3) && (flag2 || flag3 || flag || flag1)) {
+            if (flag2) {
+                this.a(0.0F, 0.0F, 0.4375F, 0.5F, 1.0F, 0.5625F);
+                super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+            } else if (flag3) {
+                this.a(0.5F, 0.0F, 0.4375F, 1.0F, 1.0F, 0.5625F);
+                super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+            }
+        } else {
+            this.a(0.0F, 0.0F, 0.4375F, 1.0F, 1.0F, 0.5625F);
+            super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        }
+
+        if ((!flag || !flag1) && (flag2 || flag3 || flag || flag1)) {
+            if (flag) {
+                this.a(0.4375F, 0.0F, 0.0F, 0.5625F, 1.0F, 0.5F);
+                super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+            } else if (flag1) {
+                this.a(0.4375F, 0.0F, 0.5F, 0.5625F, 1.0F, 1.0F);
+                super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+            }
+        } else {
+            this.a(0.4375F, 0.0F, 0.0F, 0.5625F, 1.0F, 1.0F);
+            super.a(world, blockposition, iblockdata, axisalignedbb, list, entity);
+        }
+
+    }
+
+    public void j() {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        float f = 0.4375F;
+        float f1 = 0.5625F;
+        float f2 = 0.4375F;
+        float f3 = 0.5625F;
+        boolean flag = this.c(iblockaccess.getType(blockposition.north()).getBlock());
+        boolean flag1 = this.c(iblockaccess.getType(blockposition.south()).getBlock());
+        boolean flag2 = this.c(iblockaccess.getType(blockposition.west()).getBlock());
+        boolean flag3 = this.c(iblockaccess.getType(blockposition.east()).getBlock());
+
+        if ((!flag2 || !flag3) && (flag2 || flag3 || flag || flag1)) {
+            if (flag2) {
+                f = 0.0F;
+            } else if (flag3) {
+                f1 = 1.0F;
+            }
+        } else {
+            f = 0.0F;
+            f1 = 1.0F;
+        }
+
+        if ((!flag || !flag1) && (flag2 || flag3 || flag || flag1)) {
+            if (flag) {
+                f2 = 0.0F;
+            } else if (flag1) {
+                f3 = 1.0F;
+            }
+        } else {
+            f2 = 0.0F;
+            f3 = 1.0F;
+        }
+
+        this.a(f, 0.0F, f2, f1, 1.0F, f3);
+    }
+
+    public final boolean c(Block block) {
+        return block.o() || block == this || block == Blocks.GLASS || block == Blocks.STAINED_GLASS || block == Blocks.STAINED_GLASS_PANE || block instanceof BlockThin;
+    }
+
+    protected boolean I() {
+        return true;
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return 0;
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockThin.NORTH, BlockThin.EAST, BlockThin.WEST, BlockThin.SOUTH});
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityGolem.java b/src/main/java/net/minecraft/server/EntityGolem.java
new file mode 100644
index 000000000..795229512
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityGolem.java
@@ -0,0 +1,30 @@
+package net.minecraft.server;
+
+public abstract class EntityGolem extends EntityCreature implements IAnimal {
+
+    public EntityGolem(World world) {
+        super(world);
+    }
+
+    public void e(float f, float f1) {}
+
+    protected String z() {
+        return "none";
+    }
+
+    protected String bo() {
+        return "none";
+    }
+
+    protected String bp() {
+        return "none";
+    }
+
+    public int w() {
+        return 120;
+    }
+
+    protected boolean isTypeNotPersistent() {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EntityTypes.java b/src/main/java/net/minecraft/server/EntityTypes.java
new file mode 100644
index 000000000..064d0b204
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EntityTypes.java
@@ -0,0 +1,244 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class EntityTypes {
+
+    private static final Logger b = LogManager.getLogger();
+    private static final Map<String, Class<? extends Entity>> c = Maps.newHashMap();
+    private static final Map<Class<? extends Entity>, String> d = Maps.newHashMap();
+    private static final Map<Integer, Class<? extends Entity>> e = Maps.newHashMap();
+    private static final Map<Class<? extends Entity>, Integer> f = Maps.newHashMap();
+    private static final Map<String, Integer> g = Maps.newHashMap();
+    public static final Map<Integer, EntityTypes.MonsterEggInfo> eggInfo = Maps.newLinkedHashMap();
+
+    private static void a(Class<? extends Entity> oclass, String s, int i) {
+        if (EntityTypes.c.containsKey(s)) {
+            throw new IllegalArgumentException("ID is already registered: " + s);
+        } else if (EntityTypes.e.containsKey(Integer.valueOf(i))) {
+            throw new IllegalArgumentException("ID is already registered: " + i);
+        } else if (i == 0) {
+            throw new IllegalArgumentException("Cannot register to reserved id: " + i);
+        } else if (oclass == null) {
+            throw new IllegalArgumentException("Cannot register null clazz for id: " + i);
+        } else {
+            EntityTypes.c.put(s, oclass);
+            EntityTypes.d.put(oclass, s);
+            EntityTypes.e.put(Integer.valueOf(i), oclass);
+            EntityTypes.f.put(oclass, Integer.valueOf(i));
+            EntityTypes.g.put(s, Integer.valueOf(i));
+        }
+    }
+
+    private static void a(Class<? extends Entity> oclass, String s, int i, int j, int k) {
+        a(oclass, s, i);
+        EntityTypes.eggInfo.put(Integer.valueOf(i), new EntityTypes.MonsterEggInfo(i, j, k));
+    }
+
+    public static Entity createEntityByName(String s, World world) {
+        Entity entity = null;
+
+        try {
+            Class oclass = (Class) EntityTypes.c.get(s);
+
+            if (oclass != null) {
+                entity = (Entity) oclass.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+
+        return entity;
+    }
+
+    public static Entity a(NBTTagCompound nbttagcompound, World world) {
+        Entity entity = null;
+
+        if ("Minecart".equals(nbttagcompound.getString("id"))) {
+            nbttagcompound.setString("id", EntityMinecartAbstract.EnumMinecartType.a(nbttagcompound.getInt("Type")).b());
+            nbttagcompound.remove("Type");
+        }
+
+        try {
+            Class oclass = (Class) EntityTypes.c.get(nbttagcompound.getString("id"));
+
+            if (oclass != null) {
+                entity = (Entity) oclass.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+
+        if (entity != null) {
+            entity.f(nbttagcompound);
+        } else {
+            EntityTypes.b.warn("Skipping Entity with id " + nbttagcompound.getString("id"));
+        }
+
+        return entity;
+    }
+
+    public static Entity a(int i, World world) {
+        Entity entity = null;
+
+        try {
+            Class oclass = a(i);
+
+            if (oclass != null) {
+                entity = (Entity) oclass.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
+            }
+        } catch (Exception exception) {
+            exception.printStackTrace();
+        }
+
+        if (entity == null) {
+            EntityTypes.b.warn("Skipping Entity with id " + i);
+        }
+
+        return entity;
+    }
+
+    public static int a(Entity entity) {
+        Integer integer = (Integer) EntityTypes.f.get(entity.getClass());
+
+        return integer == null ? 0 : integer.intValue();
+    }
+
+    public static Class<? extends Entity> a(int i) {
+        return (Class) EntityTypes.e.get(Integer.valueOf(i));
+    }
+
+    public static String b(Entity entity) {
+        return (String) EntityTypes.d.get(entity.getClass());
+    }
+
+    public static String b(int i) {
+        return (String) EntityTypes.d.get(a(i));
+    }
+
+    public static void a() {}
+
+    public static List<String> b() {
+        Set set = EntityTypes.c.keySet();
+        ArrayList arraylist = Lists.newArrayList();
+        Iterator iterator = set.iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            Class oclass = (Class) EntityTypes.c.get(s);
+
+            if ((oclass.getModifiers() & 1024) != 1024) {
+                arraylist.add(s);
+            }
+        }
+
+        arraylist.add("LightningBolt");
+        return arraylist;
+    }
+
+    public static boolean a(Entity entity, String s) {
+        String s1 = b(entity);
+
+        if (s1 == null && entity instanceof EntityHuman) {
+            s1 = "Player";
+        } else if (s1 == null && entity instanceof EntityLightning) {
+            s1 = "LightningBolt";
+        }
+
+        return s.equals(s1);
+    }
+
+    public static boolean b(String s) {
+        return "Player".equals(s) || b().contains(s);
+    }
+
+    static {
+        a(EntityItem.class, "Item", 1);
+        a(EntityExperienceOrb.class, "XPOrb", 2);
+        a(EntityEgg.class, "ThrownEgg", 7);
+        a(EntityLeash.class, "LeashKnot", 8);
+        a(EntityPainting.class, "Painting", 9);
+        a(EntityArrow.class, "Arrow", 10);
+        a(EntitySnowball.class, "Snowball", 11);
+        a(EntityLargeFireball.class, "Fireball", 12);
+        a(EntitySmallFireball.class, "SmallFireball", 13);
+        a(EntityEnderPearl.class, "ThrownEnderpearl", 14);
+        a(EntityEnderSignal.class, "EyeOfEnderSignal", 15);
+        a(EntityPotion.class, "ThrownPotion", 16);
+        a(EntityThrownExpBottle.class, "ThrownExpBottle", 17);
+        a(EntityItemFrame.class, "ItemFrame", 18);
+        a(EntityWitherSkull.class, "WitherSkull", 19);
+        a(EntityTNTPrimed.class, "PrimedTnt", 20);
+        a(EntityFallingBlock.class, "FallingSand", 21);
+        a(EntityFireworks.class, "FireworksRocketEntity", 22);
+        a(EntityArmorStand.class, "ArmorStand", 30);
+        a(EntityBoat.class, "Boat", 41);
+        a(EntityMinecartRideable.class, EntityMinecartAbstract.EnumMinecartType.RIDEABLE.b(), 42);
+        a(EntityMinecartChest.class, EntityMinecartAbstract.EnumMinecartType.CHEST.b(), 43);
+        a(EntityMinecartFurnace.class, EntityMinecartAbstract.EnumMinecartType.FURNACE.b(), 44);
+        a(EntityMinecartTNT.class, EntityMinecartAbstract.EnumMinecartType.TNT.b(), 45);
+        a(EntityMinecartHopper.class, EntityMinecartAbstract.EnumMinecartType.HOPPER.b(), 46);
+        a(EntityMinecartMobSpawner.class, EntityMinecartAbstract.EnumMinecartType.SPAWNER.b(), 47);
+        a(EntityMinecartCommandBlock.class, EntityMinecartAbstract.EnumMinecartType.COMMAND_BLOCK.b(), 40);
+        a(EntityInsentient.class, "Mob", 48);
+        a(EntityMonster.class, "Monster", 49);
+        a(EntityCreeper.class, "Creeper", 50, 894731, 0);
+        a(EntitySkeleton.class, "Skeleton", 51, 12698049, 4802889);
+        a(EntitySpider.class, "Spider", 52, 3419431, 11013646);
+        a(EntityGiantZombie.class, "Giant", 53);
+        a(EntityZombie.class, "Zombie", 54, '\uafaf', 7969893);
+        a(EntitySlime.class, "Slime", 55, 5349438, 8306542);
+        a(EntityGhast.class, "Ghast", 56, 16382457, 12369084);
+        a(EntityPigZombie.class, "PigZombie", 57, 15373203, 5009705);
+        a(EntityEnderman.class, "Enderman", 58, 1447446, 0);
+        a(EntityCaveSpider.class, "CaveSpider", 59, 803406, 11013646);
+        a(EntitySilverfish.class, "Silverfish", 60, 7237230, 3158064);
+        a(EntityBlaze.class, "Blaze", 61, 16167425, 16775294);
+        a(EntityMagmaCube.class, "LavaSlime", 62, 3407872, 16579584);
+        a(EntityEnderDragon.class, "EnderDragon", 63);
+        a(EntityWither.class, "WitherBoss", 64);
+        a(EntityBat.class, "Bat", 65, 4996656, 986895);
+        a(EntityWitch.class, "Witch", 66, 3407872, 5349438);
+        a(EntityEndermite.class, "Endermite", 67, 1447446, 7237230);
+        a(EntityGuardian.class, "Guardian", 68, 5931634, 15826224);
+        a(EntityPig.class, "Pig", 90, 15771042, 14377823);
+        a(EntitySheep.class, "Sheep", 91, 15198183, 16758197);
+        a(EntityCow.class, "Cow", 92, 4470310, 10592673);
+        a(EntityChicken.class, "Chicken", 93, 10592673, 16711680);
+        a(EntitySquid.class, "Squid", 94, 2243405, 7375001);
+        a(EntityWolf.class, "Wolf", 95, 14144467, 13545366);
+        a(EntityMushroomCow.class, "MushroomCow", 96, 10489616, 12040119);
+        a(EntitySnowman.class, "SnowMan", 97);
+        a(EntityOcelot.class, "Ozelot", 98, 15720061, 5653556);
+        a(EntityIronGolem.class, "VillagerGolem", 99);
+        a(EntityHorse.class, "EntityHorse", 100, 12623485, 15656192);
+        a(EntityRabbit.class, "Rabbit", 101, 10051392, 7555121);
+        a(EntityVillager.class, "Villager", 120, 5651507, 12422002);
+        a(EntityEnderCrystal.class, "EnderCrystal", 200);
+    }
+
+    public static class MonsterEggInfo {
+
+        public final int a;
+        public final int b;
+        public final int c;
+        public final Statistic killEntityStatistic;
+        public final Statistic e;
+
+        public MonsterEggInfo(int i, int j, int k) {
+            this.a = i;
+            this.b = j;
+            this.c = k;
+            this.killEntityStatistic = StatisticList.a(this);
+            this.e = StatisticList.b(this);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/EnumDirection.java b/src/main/java/net/minecraft/server/EnumDirection.java
new file mode 100644
index 000000000..f31a184bb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/EnumDirection.java
@@ -0,0 +1,361 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Maps;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Random;
+
+public enum EnumDirection implements INamable {
+
+    DOWN(0, 1, -1, "down", EnumAxisDirection.NEGATIVE, EnumAxis.Y, new BaseBlockPosition(0, -1, 0)), UP(1, 0, -1, "up", EnumAxisDirection.POSITIVE, EnumAxis.Y, new BaseBlockPosition(0, 1, 0)), NORTH(2, 3, 2, "north", EnumAxisDirection.NEGATIVE, EnumAxis.Z, new BaseBlockPosition(0, 0, -1)), SOUTH(3, 2, 0, "south", EnumAxisDirection.POSITIVE, EnumAxis.Z, new BaseBlockPosition(0, 0, 1)), WEST(4, 5, 1, "west", EnumAxisDirection.NEGATIVE, EnumAxis.X, new BaseBlockPosition(-1, 0, 0)), EAST(5, 4, 3, "east", EnumAxisDirection.POSITIVE, EnumAxis.X, new BaseBlockPosition(1, 0, 0));
+
+    private final int g;
+    private final int h;
+    private final int i;
+    private final String j;
+    private final EnumAxis k;
+    private final EnumAxisDirection l;
+    private final BaseBlockPosition m;
+    private static final EnumDirection[] n = new EnumDirection[6];
+    private static final EnumDirection[] o = new EnumDirection[4];
+    private static final Map<String, EnumDirection> p = Maps.newHashMap();
+
+    private EnumDirection(int i, int j, int k, String s, EnumAxisDirection enumdirection_enumaxisdirection, EnumAxis enumdirection_enumaxis, BaseBlockPosition baseblockposition) {
+        this.g = i;
+        this.i = k;
+        this.h = j;
+        this.j = s;
+        this.k = enumdirection_enumaxis;
+        this.l = enumdirection_enumaxisdirection;
+        this.m = baseblockposition;
+    }
+
+    public int a() {
+        return this.g;
+    }
+
+    public int b() {
+        return this.i;
+    }
+
+    public EnumAxisDirection c() {
+        return this.l;
+    }
+
+    public EnumDirection opposite() {
+        return fromType1(this.h);
+    }
+
+    public EnumDirection e() {
+        switch (SyntheticClass_1.b[this.ordinal()]) {
+        case 1:
+            return EnumDirection.EAST;
+
+        case 2:
+            return EnumDirection.SOUTH;
+
+        case 3:
+            return EnumDirection.WEST;
+
+        case 4:
+            return EnumDirection.NORTH;
+
+        default:
+            throw new IllegalStateException("Unable to get Y-rotated facing of " + this);
+        }
+    }
+
+    public EnumDirection f() {
+        switch (SyntheticClass_1.b[this.ordinal()]) {
+        case 1:
+            return EnumDirection.WEST;
+
+        case 2:
+            return EnumDirection.NORTH;
+
+        case 3:
+            return EnumDirection.EAST;
+
+        case 4:
+            return EnumDirection.SOUTH;
+
+        default:
+            throw new IllegalStateException("Unable to get CCW facing of " + this);
+        }
+    }
+
+    public int getAdjacentX() {
+        return this.k == EnumAxis.X ? this.l.a() : 0;
+    }
+
+    public int getAdjacentY() {
+        return this.k == EnumAxis.Y ? this.l.a() : 0;
+    }
+
+    public int getAdjacentZ() {
+        return this.k == EnumAxis.Z ? this.l.a() : 0;
+    }
+
+    public String j() {
+        return this.j;
+    }
+
+    public EnumAxis k() {
+        return this.k;
+    }
+
+    public static EnumDirection fromType1(int i) {
+        return EnumDirection.n[MathHelper.a(i % EnumDirection.n.length)];
+    }
+
+    public static EnumDirection fromType2(int i) {
+        return EnumDirection.o[MathHelper.a(i % EnumDirection.o.length)];
+    }
+
+    public static EnumDirection fromAngle(double d0) {
+        return fromType2(MathHelper.floor(d0 / 90.0D + 0.5D) & 3);
+    }
+
+    public static EnumDirection a(Random random) {
+        return values()[random.nextInt(values().length)];
+    }
+
+    public String toString() {
+        return this.j;
+    }
+
+    public String getName() {
+        return this.j;
+    }
+
+    public static EnumDirection a(EnumAxisDirection enumdirection_enumaxisdirection, EnumAxis enumdirection_enumaxis) {
+        EnumDirection[] aenumdirection = values();
+        int i = aenumdirection.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDirection enumdirection = aenumdirection[j];
+
+            if (enumdirection.c() == enumdirection_enumaxisdirection && enumdirection.k() == enumdirection_enumaxis) {
+                return enumdirection;
+            }
+        }
+
+        throw new IllegalArgumentException("No such direction: " + enumdirection_enumaxisdirection + " " + enumdirection_enumaxis);
+    }
+
+    static {
+        EnumDirection[] aenumdirection = values();
+        int i = aenumdirection.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDirection enumdirection = aenumdirection[j];
+
+            EnumDirection.n[enumdirection.g] = enumdirection;
+            if (enumdirection.k().c()) {
+                EnumDirection.o[enumdirection.i] = enumdirection;
+            }
+
+            EnumDirection.p.put(enumdirection.j().toLowerCase(), enumdirection);
+        }
+
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a;
+        static final int[] b;
+        static final int[] c = new int[EnumDirectionLimit.values().length];
+
+        static {
+            try {
+                SyntheticClass_1.c[EnumDirectionLimit.HORIZONTAL.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.c[EnumDirectionLimit.VERTICAL.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            b = new int[EnumDirection.values().length];
+
+            try {
+                SyntheticClass_1.b[EnumDirection.NORTH.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.b[EnumDirection.EAST.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.b[EnumDirection.SOUTH.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror4) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.b[EnumDirection.WEST.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror5) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.b[EnumDirection.UP.ordinal()] = 5;
+            } catch (NoSuchFieldError nosuchfielderror6) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.b[EnumDirection.DOWN.ordinal()] = 6;
+            } catch (NoSuchFieldError nosuchfielderror7) {
+                ;
+            }
+
+            a = new int[EnumAxis.values().length];
+
+            try {
+                SyntheticClass_1.a[EnumAxis.X.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror8) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.a[EnumAxis.Y.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror9) {
+                ;
+            }
+
+            try {
+                SyntheticClass_1.a[EnumAxis.Z.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror10) {
+                ;
+            }
+
+        }
+    }
+
+    public static enum EnumDirectionLimit implements Predicate<EnumDirection>, Iterable<EnumDirection> {
+
+        HORIZONTAL, VERTICAL;
+
+        private EnumDirectionLimit() {}
+
+        public EnumDirection[] a() {
+            switch (SyntheticClass_1.c[this.ordinal()]) {
+            case 1:
+                return new EnumDirection[] { EnumDirection.NORTH, EnumDirection.EAST, EnumDirection.SOUTH, EnumDirection.WEST};
+
+            case 2:
+                return new EnumDirection[] { EnumDirection.UP, EnumDirection.DOWN};
+
+            default:
+                throw new Error("Someone\'s been tampering with the universe!");
+            }
+        }
+
+        public EnumDirection a(Random random) {
+            EnumDirection[] aenumdirection = this.a();
+
+            return aenumdirection[random.nextInt(aenumdirection.length)];
+        }
+
+        public boolean a(EnumDirection enumdirection) {
+            return enumdirection != null && enumdirection.k().d() == this;
+        }
+
+        public Iterator<EnumDirection> iterator() {
+            return Iterators.forArray(this.a());
+        }
+
+        public boolean apply(EnumDirection enumdirection) { // Blossom - decompile fix
+            return this.a(enumdirection); // Blossom - decompile fix
+        }
+    }
+
+    public static enum EnumAxisDirection {
+
+        POSITIVE(1, "Towards positive"), NEGATIVE(-1, "Towards negative");
+
+        private final int c;
+        private final String d;
+
+        private EnumAxisDirection(int i, String s) {
+            this.c = i;
+            this.d = s;
+        }
+
+        public int a() {
+            return this.c;
+        }
+
+        public String toString() {
+            return this.d;
+        }
+    }
+
+    public static enum EnumAxis implements Predicate<EnumDirection>, INamable {
+
+        X("x", EnumDirectionLimit.HORIZONTAL), Y("y", EnumDirectionLimit.VERTICAL), Z("z", EnumDirectionLimit.HORIZONTAL);
+
+        private static final Map<String, EnumAxis> d = Maps.newHashMap();
+        private final String e;
+        private final EnumDirectionLimit f;
+
+        private EnumAxis(String s, EnumDirectionLimit enumdirection_enumdirectionlimit) {
+            this.e = s;
+            this.f = enumdirection_enumdirectionlimit;
+        }
+
+        public String a() {
+            return this.e;
+        }
+
+        public boolean b() {
+            return this.f == EnumDirectionLimit.VERTICAL;
+        }
+
+        public boolean c() {
+            return this.f == EnumDirectionLimit.HORIZONTAL;
+        }
+
+        public String toString() {
+            return this.e;
+        }
+
+        public boolean a(EnumDirection enumdirection) {
+            return enumdirection != null && enumdirection.k() == this;
+        }
+
+        public EnumDirectionLimit d() {
+            return this.f;
+        }
+
+        public String getName() {
+            return this.e;
+        }
+
+        public boolean apply(EnumDirection enumdirection) { // Blossom - decompile fix
+            return this.a(enumdirection); // Blossom - decompile fix
+        }
+
+        static {
+            EnumAxis[] aenumdirection_enumaxis = values();
+            int i = aenumdirection_enumaxis.length;
+
+            for (int j = 0; j < i; ++j) {
+                EnumAxis enumdirection_enumaxis = aenumdirection_enumaxis[j];
+
+                EnumAxis.d.put(enumdirection_enumaxis.a().toLowerCase(), enumdirection_enumaxis);
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GameProfileSerializer.java b/src/main/java/net/minecraft/server/GameProfileSerializer.java
new file mode 100644
index 000000000..998cf70e3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GameProfileSerializer.java
@@ -0,0 +1,164 @@
+package net.minecraft.server;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.properties.Property;
+import java.util.Iterator;
+import java.util.UUID;
+
+public final class GameProfileSerializer {
+
+    public static GameProfile deserialize(NBTTagCompound nbttagcompound) {
+        String s = null;
+        String s1 = null;
+
+        if (nbttagcompound.hasKeyOfType("Name", 8)) {
+            s = nbttagcompound.getString("Name");
+        }
+
+        if (nbttagcompound.hasKeyOfType("Id", 8)) {
+            s1 = nbttagcompound.getString("Id");
+        }
+
+        if (UtilColor.b(s) && UtilColor.b(s1)) {
+            return null;
+        } else {
+            UUID uuid;
+
+            try {
+                uuid = UUID.fromString(s1);
+            } catch (Throwable throwable) {
+                uuid = null;
+            }
+
+            GameProfile gameprofile = new GameProfile(uuid, s);
+
+            if (nbttagcompound.hasKeyOfType("Properties", 10)) {
+                NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Properties");
+                Iterator iterator = nbttagcompound1.c().iterator();
+
+                while (iterator.hasNext()) {
+                    String s2 = (String) iterator.next();
+                    NBTTagList nbttaglist = nbttagcompound1.getList(s2, 10);
+
+                    for (int i = 0; i < nbttaglist.size(); ++i) {
+                        NBTTagCompound nbttagcompound2 = nbttaglist.get(i);
+                        String s3 = nbttagcompound2.getString("Value");
+
+                        if (nbttagcompound2.hasKeyOfType("Signature", 8)) {
+                            gameprofile.getProperties().put(s2, new Property(s2, s3, nbttagcompound2.getString("Signature")));
+                        } else {
+                            gameprofile.getProperties().put(s2, new Property(s2, s3));
+                        }
+                    }
+                }
+            }
+
+            return gameprofile;
+        }
+    }
+
+    public static NBTTagCompound serialize(NBTTagCompound nbttagcompound, GameProfile gameprofile) {
+        if (!UtilColor.b(gameprofile.getName())) {
+            nbttagcompound.setString("Name", gameprofile.getName());
+        }
+
+        if (gameprofile.getId() != null) {
+            nbttagcompound.setString("Id", gameprofile.getId().toString());
+        }
+
+        if (!gameprofile.getProperties().isEmpty()) {
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+            Iterator iterator = gameprofile.getProperties().keySet().iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+                NBTTagList nbttaglist = new NBTTagList();
+
+                NBTTagCompound nbttagcompound2;
+
+                for (Iterator iterator1 = gameprofile.getProperties().get(s).iterator(); iterator1.hasNext(); nbttaglist.add(nbttagcompound2)) {
+                    Property property = (Property) iterator1.next();
+
+                    nbttagcompound2 = new NBTTagCompound();
+                    nbttagcompound2.setString("Value", property.getValue());
+                    if (property.hasSignature()) {
+                        nbttagcompound2.setString("Signature", property.getSignature());
+                    }
+                }
+
+                nbttagcompound1.set(s, nbttaglist);
+            }
+
+            nbttagcompound.set("Properties", nbttagcompound1);
+        }
+
+        return nbttagcompound;
+    }
+
+    public static boolean a(NBTBase nbtbase, NBTBase nbtbase1, boolean flag) {
+        if (nbtbase == nbtbase1) {
+            return true;
+        } else if (nbtbase == null) {
+            return true;
+        } else if (nbtbase1 == null) {
+            return false;
+        } else if (!nbtbase.getClass().equals(nbtbase1.getClass())) {
+            return false;
+        } else if (nbtbase instanceof NBTTagCompound) {
+            NBTTagCompound nbttagcompound = (NBTTagCompound) nbtbase;
+            NBTTagCompound nbttagcompound1 = (NBTTagCompound) nbtbase1;
+            Iterator iterator = nbttagcompound.c().iterator();
+
+            String s;
+            NBTBase nbtbase2;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return true;
+                }
+
+                s = (String) iterator.next();
+                nbtbase2 = nbttagcompound.get(s);
+            } while (a(nbtbase2, nbttagcompound1.get(s), flag));
+
+            return false;
+        } else if (nbtbase instanceof NBTTagList && flag) {
+            NBTTagList nbttaglist = (NBTTagList) nbtbase;
+            NBTTagList nbttaglist1 = (NBTTagList) nbtbase1;
+
+            if (nbttaglist.size() == 0) {
+                return nbttaglist1.size() == 0;
+            } else {
+                int i = 0;
+
+                while (i < nbttaglist.size()) {
+                    NBTBase nbtbase3 = nbttaglist.g(i);
+                    boolean flag1 = false;
+                    int j = 0;
+
+                    while (true) {
+                        if (j < nbttaglist1.size()) {
+                            if (!a(nbtbase3, nbttaglist1.g(j), flag)) {
+                                ++j;
+                                continue;
+                            }
+
+                            flag1 = true;
+                        }
+
+                        if (!flag1) {
+                            return false;
+                        }
+
+                        ++i;
+                        break;
+                    }
+                }
+
+                return true;
+            }
+        } else {
+            return nbtbase.equals(nbtbase1);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/GameRules.java b/src/main/java/net/minecraft/server/GameRules.java
new file mode 100644
index 000000000..1c89c9058
--- /dev/null
+++ b/src/main/java/net/minecraft/server/GameRules.java
@@ -0,0 +1,160 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+import java.util.Set;
+import java.util.TreeMap;
+
+public class GameRules {
+
+    private TreeMap<String, GameRules.GameRuleValue> a = new TreeMap();
+
+    public GameRules() {
+        this.a("doFireTick", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("mobGriefing", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("keepInventory", "false", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("doMobSpawning", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("doMobLoot", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("doTileDrops", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("doEntityDrops", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("commandBlockOutput", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("naturalRegeneration", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("doDaylightCycle", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("logAdminCommands", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("showDeathMessages", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("randomTickSpeed", "3", GameRules.EnumGameRuleType.NUMERICAL_VALUE);
+        this.a("sendCommandFeedback", "true", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+        this.a("reducedDebugInfo", "false", GameRules.EnumGameRuleType.BOOLEAN_VALUE);
+    }
+
+    public void a(String s, String s1, GameRules.EnumGameRuleType gamerules_enumgameruletype) {
+        this.a.put(s, new GameRules.GameRuleValue(s1, gamerules_enumgameruletype));
+    }
+
+    public void set(String s, String s1) {
+        GameRules.GameRuleValue gamerules_gamerulevalue = (GameRules.GameRuleValue) this.a.get(s);
+
+        if (gamerules_gamerulevalue != null) {
+            gamerules_gamerulevalue.a(s1);
+        } else {
+            this.a(s, s1, GameRules.EnumGameRuleType.ANY_VALUE);
+        }
+
+    }
+
+    public String get(String s) {
+        GameRules.GameRuleValue gamerules_gamerulevalue = (GameRules.GameRuleValue) this.a.get(s);
+
+        return gamerules_gamerulevalue != null ? gamerules_gamerulevalue.a() : "";
+    }
+
+    public boolean getBoolean(String s) {
+        GameRules.GameRuleValue gamerules_gamerulevalue = (GameRules.GameRuleValue) this.a.get(s);
+
+        return gamerules_gamerulevalue != null ? gamerules_gamerulevalue.b() : false;
+    }
+
+    public int c(String s) {
+        GameRules.GameRuleValue gamerules_gamerulevalue = (GameRules.GameRuleValue) this.a.get(s);
+
+        return gamerules_gamerulevalue != null ? gamerules_gamerulevalue.c() : 0;
+    }
+
+    public NBTTagCompound a() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        Iterator iterator = this.a.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            GameRules.GameRuleValue gamerules_gamerulevalue = (GameRules.GameRuleValue) this.a.get(s);
+
+            nbttagcompound.setString(s, gamerules_gamerulevalue.a());
+        }
+
+        return nbttagcompound;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        Set set = nbttagcompound.c();
+        Iterator iterator = set.iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            String s1 = nbttagcompound.getString(s);
+
+            this.set(s, s1);
+        }
+
+    }
+
+    public String[] getGameRules() {
+        Set set = this.a.keySet();
+
+        return (String[]) set.toArray(new String[set.size()]);
+    }
+
+    public boolean contains(String s) {
+        return this.a.containsKey(s);
+    }
+
+    public boolean a(String s, GameRules.EnumGameRuleType gamerules_enumgameruletype) {
+        GameRules.GameRuleValue gamerules_gamerulevalue = (GameRules.GameRuleValue) this.a.get(s);
+
+        return gamerules_gamerulevalue != null && (gamerules_gamerulevalue.e() == gamerules_enumgameruletype || gamerules_enumgameruletype == GameRules.EnumGameRuleType.ANY_VALUE);
+    }
+
+    public static enum EnumGameRuleType {
+
+        ANY_VALUE, BOOLEAN_VALUE, NUMERICAL_VALUE;
+
+        private EnumGameRuleType() {}
+    }
+
+    static class GameRuleValue {
+
+        private String a;
+        private boolean b;
+        private int c;
+        private double d;
+        private final GameRules.EnumGameRuleType e;
+
+        public GameRuleValue(String s, GameRules.EnumGameRuleType gamerules_enumgameruletype) {
+            this.e = gamerules_enumgameruletype;
+            this.a(s);
+        }
+
+        public void a(String s) {
+            this.a = s;
+            this.b = Boolean.parseBoolean(s);
+            this.c = this.b ? 1 : 0;
+
+            try {
+                this.c = Integer.parseInt(s);
+            } catch (NumberFormatException numberformatexception) {
+                ;
+            }
+
+            try {
+                this.d = Double.parseDouble(s);
+            } catch (NumberFormatException numberformatexception1) {
+                ;
+            }
+
+        }
+
+        public String a() {
+            return this.a;
+        }
+
+        public boolean b() {
+            return this.b;
+        }
+
+        public int c() {
+            return this.c;
+        }
+
+        public GameRules.EnumGameRuleType e() {
+            return this.e;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/IBlockData.java b/src/main/java/net/minecraft/server/IBlockData.java
new file mode 100644
index 000000000..3c3ab0c59
--- /dev/null
+++ b/src/main/java/net/minecraft/server/IBlockData.java
@@ -0,0 +1,19 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.Collection;
+
+public interface IBlockData {
+
+    Collection<IBlockState> a();
+
+    <T extends Comparable<T>> T get(IBlockState<T> iblockstate);
+
+    <T extends Comparable<T>, V extends T> IBlockData set(IBlockState<T> iblockstate, V v0);
+
+    <T extends Comparable<T>> IBlockData a(IBlockState<T> iblockstate);
+
+    ImmutableMap<IBlockState, Comparable> b();
+
+    Block getBlock();
+}
diff --git a/src/main/java/net/minecraft/server/InventoryUtils.java b/src/main/java/net/minecraft/server/InventoryUtils.java
new file mode 100644
index 000000000..55ab12f04
--- /dev/null
+++ b/src/main/java/net/minecraft/server/InventoryUtils.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class InventoryUtils {
+
+    private static final Random a = new Random();
+
+    public static void dropInventory(World world, BlockPosition blockposition, IInventory iinventory) {
+        dropInventory(world, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), iinventory);
+    }
+
+    public static void dropEntity(World world, Entity entity, IInventory iinventory) {
+        dropInventory(world, entity.locX, entity.locY, entity.locZ, iinventory);
+    }
+
+    private static void dropInventory(World world, double d0, double d1, double d2, IInventory iinventory) {
+        for (int i = 0; i < iinventory.getSize(); ++i) {
+            ItemStack itemstack = iinventory.getItem(i);
+
+            if (itemstack != null) {
+                dropItem(world, d0, d1, d2, itemstack);
+            }
+        }
+
+    }
+
+    private static void dropItem(World world, double d0, double d1, double d2, ItemStack itemstack) {
+        float f = InventoryUtils.a.nextFloat() * 0.8F + 0.1F;
+        float f1 = InventoryUtils.a.nextFloat() * 0.8F + 0.1F;
+        float f2 = InventoryUtils.a.nextFloat() * 0.8F + 0.1F;
+
+        while (itemstack.count > 0) {
+            int i = InventoryUtils.a.nextInt(21) + 10;
+
+            if (i > itemstack.count) {
+                i = itemstack.count;
+            }
+
+            itemstack.count -= i;
+            EntityItem entityitem = new EntityItem(world, d0 + (double) f, d1 + (double) f1, d2 + (double) f2, new ItemStack(itemstack.getItem(), i, itemstack.getData()));
+
+            if (itemstack.hasTag()) {
+                entityitem.getItemStack().setTag((NBTTagCompound) itemstack.getTag().clone());
+            }
+
+            float f3 = 0.05F;
+
+            entityitem.motX = InventoryUtils.a.nextGaussian() * (double) f3;
+            entityitem.motY = InventoryUtils.a.nextGaussian() * (double) f3 + 0.20000000298023224D;
+            entityitem.motZ = InventoryUtils.a.nextGaussian() * (double) f3;
+            world.addEntity(entityitem);
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Item.java b/src/main/java/net/minecraft/server/Item.java
new file mode 100644
index 000000000..87a2d7b90
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Item.java
@@ -0,0 +1,786 @@
+package net.minecraft.server;
+
+import com.google.common.base.Function;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
+import java.util.Map;
+import java.util.Random;
+import java.util.UUID;
+
+public class Item {
+
+    public static final RegistryMaterials<MinecraftKey, Item> REGISTRY = new RegistryMaterials();
+    private static final Map<Block, Item> a = Maps.newHashMap();
+    protected static final UUID f = UUID.fromString("CB3F55D3-645C-4F38-A497-9C13A33DB5CF");
+    private CreativeModeTab b;
+    protected static Random g = new Random();
+    protected int maxStackSize = 64;
+    private int durability;
+    protected boolean i;
+    protected boolean j;
+    private Item craftingResult;
+    private String k;
+    private String name;
+
+    public Item() {}
+
+    public static int getId(Item item) {
+        return item == null ? 0 : Item.REGISTRY.b(item);
+    }
+
+    public static Item getById(int i) {
+        return (Item) Item.REGISTRY.a(i);
+    }
+
+    public static Item getItemOf(Block block) {
+        return (Item) Item.a.get(block);
+    }
+
+    public static Item d(String s) {
+        Item item = (Item) Item.REGISTRY.get(new MinecraftKey(s));
+
+        if (item == null) {
+            try {
+                return getById(Integer.parseInt(s));
+            } catch (NumberFormatException numberformatexception) {
+                ;
+            }
+        }
+
+        return item;
+    }
+
+    public boolean a(NBTTagCompound nbttagcompound) {
+        return false;
+    }
+
+    public Item c(int i) {
+        this.maxStackSize = i;
+        return this;
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2) {
+        return false;
+    }
+
+    public float getDestroySpeed(ItemStack itemstack, Block block) {
+        return 1.0F;
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        return itemstack;
+    }
+
+    public ItemStack b(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        return itemstack;
+    }
+
+    public int getMaxStackSize() {
+        return this.maxStackSize;
+    }
+
+    public int filterData(int i) {
+        return 0;
+    }
+
+    public boolean k() {
+        return this.j;
+    }
+
+    protected Item a(boolean flag) {
+        this.j = flag;
+        return this;
+    }
+
+    public int getMaxDurability() {
+        return this.durability;
+    }
+
+    protected Item setMaxDurability(int i) {
+        this.durability = i;
+        return this;
+    }
+
+    public boolean usesDurability() {
+        return this.durability > 0 && !this.j;
+    }
+
+    public boolean a(ItemStack itemstack, EntityLiving entityliving, EntityLiving entityliving1) {
+        return false;
+    }
+
+    public boolean a(ItemStack itemstack, World world, Block block, BlockPosition blockposition, EntityLiving entityliving) {
+        return false;
+    }
+
+    public boolean canDestroySpecialBlock(Block block) {
+        return false;
+    }
+
+    public boolean a(ItemStack itemstack, EntityHuman entityhuman, EntityLiving entityliving) {
+        return false;
+    }
+
+    public Item n() {
+        this.i = true;
+        return this;
+    }
+
+    public Item c(String s) {
+        this.name = s;
+        return this;
+    }
+
+    public String k(ItemStack itemstack) {
+        String s = this.e_(itemstack);
+
+        return s == null ? "" : LocaleI18n.get(s);
+    }
+
+    public String getName() {
+        return "item." + this.name;
+    }
+
+    public String e_(ItemStack itemstack) {
+        return "item." + this.name;
+    }
+
+    public Item c(Item item) {
+        this.craftingResult = item;
+        return this;
+    }
+
+    public boolean p() {
+        return true;
+    }
+
+    public Item q() {
+        return this.craftingResult;
+    }
+
+    public boolean r() {
+        return this.craftingResult != null;
+    }
+
+    public void a(ItemStack itemstack, World world, Entity entity, int i, boolean flag) {}
+
+    public void d(ItemStack itemstack, World world, EntityHuman entityhuman) {}
+
+    public boolean f() {
+        return false;
+    }
+
+    public EnumAnimation e(ItemStack itemstack) {
+        return EnumAnimation.NONE;
+    }
+
+    public int d(ItemStack itemstack) {
+        return 0;
+    }
+
+    public void a(ItemStack itemstack, World world, EntityHuman entityhuman, int i) {}
+
+    protected Item e(String s) {
+        this.k = s;
+        return this;
+    }
+
+    public String j(ItemStack itemstack) {
+        return this.k;
+    }
+
+    public boolean l(ItemStack itemstack) {
+        return this.j(itemstack) != null;
+    }
+
+    public String a(ItemStack itemstack) {
+        return ("" + LocaleI18n.get(this.k(itemstack) + ".name")).trim();
+    }
+
+    public EnumItemRarity g(ItemStack itemstack) {
+        return itemstack.hasEnchantments() ? EnumItemRarity.RARE : EnumItemRarity.COMMON;
+    }
+
+    public boolean f_(ItemStack itemstack) {
+        return this.getMaxStackSize() == 1 && this.usesDurability();
+    }
+
+    protected MovingObjectPosition a(World world, EntityHuman entityhuman, boolean flag) {
+        float f = entityhuman.pitch;
+        float f1 = entityhuman.yaw;
+        double d0 = entityhuman.locX;
+        double d1 = entityhuman.locY + (double) entityhuman.getHeadHeight();
+        double d2 = entityhuman.locZ;
+        Vec3D vec3d = new Vec3D(d0, d1, d2);
+        float f2 = MathHelper.cos(-f1 * 0.017453292F - 3.1415927F);
+        float f3 = MathHelper.sin(-f1 * 0.017453292F - 3.1415927F);
+        float f4 = -MathHelper.cos(-f * 0.017453292F);
+        float f5 = MathHelper.sin(-f * 0.017453292F);
+        float f6 = f3 * f4;
+        float f7 = f2 * f4;
+        double d3 = 5.0D;
+        Vec3D vec3d1 = vec3d.add((double) f6 * d3, (double) f5 * d3, (double) f7 * d3);
+
+        return world.rayTrace(vec3d, vec3d1, flag, !flag, false);
+    }
+
+    public int b() {
+        return 0;
+    }
+
+    public Item a(CreativeModeTab creativemodetab) {
+        this.b = creativemodetab;
+        return this;
+    }
+
+    public boolean s() {
+        return false;
+    }
+
+    public boolean a(ItemStack itemstack, ItemStack itemstack1) {
+        return false;
+    }
+
+    public Multimap<String, AttributeModifier> i() {
+        return HashMultimap.create();
+    }
+
+    public static void t() {
+        a(Blocks.STONE, (Item) (new ItemMultiTexture(Blocks.STONE, Blocks.STONE, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockStone.EnumStoneVariant.a(itemstack.getData()).d();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("stone"));
+        a((Block) Blocks.GRASS, (Item) (new ItemWithAuxData(Blocks.GRASS, false)));
+        a(Blocks.DIRT, (Item) (new ItemMultiTexture(Blocks.DIRT, Blocks.DIRT, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockDirt.EnumDirtVariant.a(itemstack.getData()).c();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("dirt"));
+        c(Blocks.COBBLESTONE);
+        a(Blocks.PLANKS, (Item) (new ItemMultiTexture(Blocks.PLANKS, Blocks.PLANKS, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockWood.EnumLogVariant.a(itemstack.getData()).d();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("wood"));
+        a(Blocks.SAPLING, (Item) (new ItemMultiTexture(Blocks.SAPLING, Blocks.SAPLING, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockWood.EnumLogVariant.a(itemstack.getData()).d();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("sapling"));
+        c(Blocks.BEDROCK);
+        a((Block) Blocks.SAND, (Item) (new ItemMultiTexture(Blocks.SAND, Blocks.SAND, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockSand.EnumSandVariant.a(itemstack.getData()).d();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("sand"));
+        c(Blocks.GRAVEL);
+        c(Blocks.GOLD_ORE);
+        c(Blocks.IRON_ORE);
+        c(Blocks.COAL_ORE);
+        a(Blocks.LOG, (Item) (new ItemMultiTexture(Blocks.LOG, Blocks.LOG, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockWood.EnumLogVariant.a(itemstack.getData()).d();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("log"));
+        a(Blocks.LOG2, (Item) (new ItemMultiTexture(Blocks.LOG2, Blocks.LOG2, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockWood.EnumLogVariant.a(itemstack.getData() + 4).d();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("log"));
+        a((Block) Blocks.LEAVES, (Item) (new ItemLeaves(Blocks.LEAVES)).b("leaves"));
+        a((Block) Blocks.LEAVES2, (Item) (new ItemLeaves(Blocks.LEAVES2)).b("leaves"));
+        a(Blocks.SPONGE, (Item) (new ItemMultiTexture(Blocks.SPONGE, Blocks.SPONGE, new Function() {
+            public String a(ItemStack itemstack) {
+                return (itemstack.getData() & 1) == 1 ? "wet" : "dry";
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("sponge"));
+        c(Blocks.GLASS);
+        c(Blocks.LAPIS_ORE);
+        c(Blocks.LAPIS_BLOCK);
+        c(Blocks.DISPENSER);
+        a(Blocks.SANDSTONE, (Item) (new ItemMultiTexture(Blocks.SANDSTONE, Blocks.SANDSTONE, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockSandStone.EnumSandstoneVariant.a(itemstack.getData()).c();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("sandStone"));
+        c(Blocks.NOTEBLOCK);
+        c(Blocks.GOLDEN_RAIL);
+        c(Blocks.DETECTOR_RAIL);
+        a((Block) Blocks.STICKY_PISTON, (Item) (new ItemPiston(Blocks.STICKY_PISTON)));
+        c(Blocks.WEB);
+        a((Block) Blocks.TALLGRASS, (Item) (new ItemWithAuxData(Blocks.TALLGRASS, true)).a(new String[] { "shrub", "grass", "fern"}));
+        c((Block) Blocks.DEADBUSH);
+        a((Block) Blocks.PISTON, (Item) (new ItemPiston(Blocks.PISTON)));
+        a(Blocks.WOOL, (Item) (new ItemCloth(Blocks.WOOL)).b("cloth"));
+        a((Block) Blocks.YELLOW_FLOWER, (Item) (new ItemMultiTexture(Blocks.YELLOW_FLOWER, Blocks.YELLOW_FLOWER, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockFlowers.EnumFlowerVarient.a(BlockFlowers.EnumFlowerType.YELLOW, itemstack.getData()).d();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("flower"));
+        a((Block) Blocks.RED_FLOWER, (Item) (new ItemMultiTexture(Blocks.RED_FLOWER, Blocks.RED_FLOWER, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockFlowers.EnumFlowerVarient.a(BlockFlowers.EnumFlowerType.RED, itemstack.getData()).d();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("rose"));
+        c((Block) Blocks.BROWN_MUSHROOM);
+        c((Block) Blocks.RED_MUSHROOM);
+        c(Blocks.GOLD_BLOCK);
+        c(Blocks.IRON_BLOCK);
+        a((Block) Blocks.STONE_SLAB, (Item) (new ItemStep(Blocks.STONE_SLAB, Blocks.STONE_SLAB, Blocks.DOUBLE_STONE_SLAB)).b("stoneSlab"));
+        c(Blocks.BRICK_BLOCK);
+        c(Blocks.TNT);
+        c(Blocks.BOOKSHELF);
+        c(Blocks.MOSSY_COBBLESTONE);
+        c(Blocks.OBSIDIAN);
+        c(Blocks.TORCH);
+        c(Blocks.MOB_SPAWNER);
+        c(Blocks.OAK_STAIRS);
+        c((Block) Blocks.CHEST);
+        c(Blocks.DIAMOND_ORE);
+        c(Blocks.DIAMOND_BLOCK);
+        c(Blocks.CRAFTING_TABLE);
+        c(Blocks.FARMLAND);
+        c(Blocks.FURNACE);
+        c(Blocks.LIT_FURNACE);
+        c(Blocks.LADDER);
+        c(Blocks.RAIL);
+        c(Blocks.STONE_STAIRS);
+        c(Blocks.LEVER);
+        c(Blocks.STONE_PRESSURE_PLATE);
+        c(Blocks.WOODEN_PRESSURE_PLATE);
+        c(Blocks.REDSTONE_ORE);
+        c(Blocks.REDSTONE_TORCH);
+        c(Blocks.STONE_BUTTON);
+        a(Blocks.SNOW_LAYER, (Item) (new ItemSnow(Blocks.SNOW_LAYER)));
+        c(Blocks.ICE);
+        c(Blocks.SNOW);
+        c((Block) Blocks.CACTUS);
+        c(Blocks.CLAY);
+        c(Blocks.JUKEBOX);
+        c(Blocks.FENCE);
+        c(Blocks.SPRUCE_FENCE);
+        c(Blocks.BIRCH_FENCE);
+        c(Blocks.JUNGLE_FENCE);
+        c(Blocks.DARK_OAK_FENCE);
+        c(Blocks.ACACIA_FENCE);
+        c(Blocks.PUMPKIN);
+        c(Blocks.NETHERRACK);
+        c(Blocks.SOUL_SAND);
+        c(Blocks.GLOWSTONE);
+        c(Blocks.LIT_PUMPKIN);
+        c(Blocks.TRAPDOOR);
+        a(Blocks.MONSTER_EGG, (Item) (new ItemMultiTexture(Blocks.MONSTER_EGG, Blocks.MONSTER_EGG, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockMonsterEggs.EnumMonsterEggVarient.a(itemstack.getData()).c();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("monsterStoneEgg"));
+        a(Blocks.STONEBRICK, (Item) (new ItemMultiTexture(Blocks.STONEBRICK, Blocks.STONEBRICK, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockSmoothBrick.EnumStonebrickType.a(itemstack.getData()).c();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("stonebricksmooth"));
+        c(Blocks.BROWN_MUSHROOM_BLOCK);
+        c(Blocks.RED_MUSHROOM_BLOCK);
+        c(Blocks.IRON_BARS);
+        c(Blocks.GLASS_PANE);
+        c(Blocks.MELON_BLOCK);
+        a(Blocks.VINE, (Item) (new ItemWithAuxData(Blocks.VINE, false)));
+        c(Blocks.FENCE_GATE);
+        c(Blocks.SPRUCE_FENCE_GATE);
+        c(Blocks.BIRCH_FENCE_GATE);
+        c(Blocks.JUNGLE_FENCE_GATE);
+        c(Blocks.DARK_OAK_FENCE_GATE);
+        c(Blocks.ACACIA_FENCE_GATE);
+        c(Blocks.BRICK_STAIRS);
+        c(Blocks.STONE_BRICK_STAIRS);
+        c((Block) Blocks.MYCELIUM);
+        a(Blocks.WATERLILY, (Item) (new ItemWaterLily(Blocks.WATERLILY)));
+        c(Blocks.NETHER_BRICK);
+        c(Blocks.NETHER_BRICK_FENCE);
+        c(Blocks.NETHER_BRICK_STAIRS);
+        c(Blocks.ENCHANTING_TABLE);
+        c(Blocks.END_PORTAL_FRAME);
+        c(Blocks.END_STONE);
+        c(Blocks.DRAGON_EGG);
+        c(Blocks.REDSTONE_LAMP);
+        a((Block) Blocks.WOODEN_SLAB, (Item) (new ItemStep(Blocks.WOODEN_SLAB, Blocks.WOODEN_SLAB, Blocks.DOUBLE_WOODEN_SLAB)).b("woodSlab"));
+        c(Blocks.SANDSTONE_STAIRS);
+        c(Blocks.EMERALD_ORE);
+        c(Blocks.ENDER_CHEST);
+        c((Block) Blocks.TRIPWIRE_HOOK);
+        c(Blocks.EMERALD_BLOCK);
+        c(Blocks.SPRUCE_STAIRS);
+        c(Blocks.BIRCH_STAIRS);
+        c(Blocks.JUNGLE_STAIRS);
+        c(Blocks.COMMAND_BLOCK);
+        c((Block) Blocks.BEACON);
+        a(Blocks.COBBLESTONE_WALL, (Item) (new ItemMultiTexture(Blocks.COBBLESTONE_WALL, Blocks.COBBLESTONE_WALL, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockCobbleWall.EnumCobbleVariant.a(itemstack.getData()).c();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("cobbleWall"));
+        c(Blocks.WOODEN_BUTTON);
+        a(Blocks.ANVIL, (Item) (new ItemAnvil(Blocks.ANVIL)).b("anvil"));
+        c(Blocks.TRAPPED_CHEST);
+        c(Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE);
+        c(Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE);
+        c((Block) Blocks.DAYLIGHT_DETECTOR);
+        c(Blocks.REDSTONE_BLOCK);
+        c(Blocks.QUARTZ_ORE);
+        c((Block) Blocks.HOPPER);
+        a(Blocks.QUARTZ_BLOCK, (Item) (new ItemMultiTexture(Blocks.QUARTZ_BLOCK, Blocks.QUARTZ_BLOCK, new String[] { "default", "chiseled", "lines"})).b("quartzBlock"));
+        c(Blocks.QUARTZ_STAIRS);
+        c(Blocks.ACTIVATOR_RAIL);
+        c(Blocks.DROPPER);
+        a(Blocks.STAINED_HARDENED_CLAY, (Item) (new ItemCloth(Blocks.STAINED_HARDENED_CLAY)).b("clayHardenedStained"));
+        c(Blocks.BARRIER);
+        c(Blocks.IRON_TRAPDOOR);
+        c(Blocks.HAY_BLOCK);
+        a(Blocks.CARPET, (Item) (new ItemCloth(Blocks.CARPET)).b("woolCarpet"));
+        c(Blocks.HARDENED_CLAY);
+        c(Blocks.COAL_BLOCK);
+        c(Blocks.PACKED_ICE);
+        c(Blocks.ACACIA_STAIRS);
+        c(Blocks.DARK_OAK_STAIRS);
+        c(Blocks.SLIME);
+        a((Block) Blocks.DOUBLE_PLANT, (Item) (new ItemTallPlant(Blocks.DOUBLE_PLANT, Blocks.DOUBLE_PLANT, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockTallPlant.EnumTallFlowerVariants.a(itemstack.getData()).c();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("doublePlant"));
+        a((Block) Blocks.STAINED_GLASS, (Item) (new ItemCloth(Blocks.STAINED_GLASS)).b("stainedGlass"));
+        a((Block) Blocks.STAINED_GLASS_PANE, (Item) (new ItemCloth(Blocks.STAINED_GLASS_PANE)).b("stainedGlassPane"));
+        a(Blocks.PRISMARINE, (Item) (new ItemMultiTexture(Blocks.PRISMARINE, Blocks.PRISMARINE, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockPrismarine.EnumPrismarineVariant.a(itemstack.getData()).c();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("prismarine"));
+        c(Blocks.SEA_LANTERN);
+        a(Blocks.RED_SANDSTONE, (Item) (new ItemMultiTexture(Blocks.RED_SANDSTONE, Blocks.RED_SANDSTONE, new Function() {
+            public String a(ItemStack itemstack) {
+                return BlockRedSandstone.EnumRedSandstoneVariant.a(itemstack.getData()).c();
+            }
+
+            public Object apply(Object object) {
+                return this.a((ItemStack) object);
+            }
+        })).b("redSandStone"));
+        c(Blocks.RED_SANDSTONE_STAIRS);
+        a((Block) Blocks.STONE_SLAB2, (Item) (new ItemStep(Blocks.STONE_SLAB2, Blocks.STONE_SLAB2, Blocks.DOUBLE_STONE_SLAB2)).b("stoneSlab2"));
+        a(256, "iron_shovel", (new ItemSpade(Item.EnumToolMaterial.IRON)).c("shovelIron"));
+        a(257, "iron_pickaxe", (new ItemPickaxe(Item.EnumToolMaterial.IRON)).c("pickaxeIron"));
+        a(258, "iron_axe", (new ItemAxe(Item.EnumToolMaterial.IRON)).c("hatchetIron"));
+        a(259, "flint_and_steel", (new ItemFlintAndSteel()).c("flintAndSteel"));
+        a(260, "apple", (new ItemFood(4, 0.3F, false)).c("apple"));
+        a(261, "bow", (new ItemBow()).c("bow"));
+        a(262, "arrow", (new Item()).c("arrow").a(CreativeModeTab.j));
+        a(263, "coal", (new ItemCoal()).c("coal"));
+        a(264, "diamond", (new Item()).c("diamond").a(CreativeModeTab.l));
+        a(265, "iron_ingot", (new Item()).c("ingotIron").a(CreativeModeTab.l));
+        a(266, "gold_ingot", (new Item()).c("ingotGold").a(CreativeModeTab.l));
+        a(267, "iron_sword", (new ItemSword(Item.EnumToolMaterial.IRON)).c("swordIron"));
+        a(268, "wooden_sword", (new ItemSword(Item.EnumToolMaterial.WOOD)).c("swordWood"));
+        a(269, "wooden_shovel", (new ItemSpade(Item.EnumToolMaterial.WOOD)).c("shovelWood"));
+        a(270, "wooden_pickaxe", (new ItemPickaxe(Item.EnumToolMaterial.WOOD)).c("pickaxeWood"));
+        a(271, "wooden_axe", (new ItemAxe(Item.EnumToolMaterial.WOOD)).c("hatchetWood"));
+        a(272, "stone_sword", (new ItemSword(Item.EnumToolMaterial.STONE)).c("swordStone"));
+        a(273, "stone_shovel", (new ItemSpade(Item.EnumToolMaterial.STONE)).c("shovelStone"));
+        a(274, "stone_pickaxe", (new ItemPickaxe(Item.EnumToolMaterial.STONE)).c("pickaxeStone"));
+        a(275, "stone_axe", (new ItemAxe(Item.EnumToolMaterial.STONE)).c("hatchetStone"));
+        a(276, "diamond_sword", (new ItemSword(Item.EnumToolMaterial.EMERALD)).c("swordDiamond"));
+        a(277, "diamond_shovel", (new ItemSpade(Item.EnumToolMaterial.EMERALD)).c("shovelDiamond"));
+        a(278, "diamond_pickaxe", (new ItemPickaxe(Item.EnumToolMaterial.EMERALD)).c("pickaxeDiamond"));
+        a(279, "diamond_axe", (new ItemAxe(Item.EnumToolMaterial.EMERALD)).c("hatchetDiamond"));
+        a(280, "stick", (new Item()).n().c("stick").a(CreativeModeTab.l));
+        a(281, "bowl", (new Item()).c("bowl").a(CreativeModeTab.l));
+        a(282, "mushroom_stew", (new ItemSoup(6)).c("mushroomStew"));
+        a(283, "golden_sword", (new ItemSword(Item.EnumToolMaterial.GOLD)).c("swordGold"));
+        a(284, "golden_shovel", (new ItemSpade(Item.EnumToolMaterial.GOLD)).c("shovelGold"));
+        a(285, "golden_pickaxe", (new ItemPickaxe(Item.EnumToolMaterial.GOLD)).c("pickaxeGold"));
+        a(286, "golden_axe", (new ItemAxe(Item.EnumToolMaterial.GOLD)).c("hatchetGold"));
+        a(287, "string", (new ItemReed(Blocks.TRIPWIRE)).c("string").a(CreativeModeTab.l));
+        a(288, "feather", (new Item()).c("feather").a(CreativeModeTab.l));
+        a(289, "gunpowder", (new Item()).c("sulphur").e(PotionBrewer.k).a(CreativeModeTab.l));
+        a(290, "wooden_hoe", (new ItemHoe(Item.EnumToolMaterial.WOOD)).c("hoeWood"));
+        a(291, "stone_hoe", (new ItemHoe(Item.EnumToolMaterial.STONE)).c("hoeStone"));
+        a(292, "iron_hoe", (new ItemHoe(Item.EnumToolMaterial.IRON)).c("hoeIron"));
+        a(293, "diamond_hoe", (new ItemHoe(Item.EnumToolMaterial.EMERALD)).c("hoeDiamond"));
+        a(294, "golden_hoe", (new ItemHoe(Item.EnumToolMaterial.GOLD)).c("hoeGold"));
+        a(295, "wheat_seeds", (new ItemSeeds(Blocks.WHEAT, Blocks.FARMLAND)).c("seeds"));
+        a(296, "wheat", (new Item()).c("wheat").a(CreativeModeTab.l));
+        a(297, "bread", (new ItemFood(5, 0.6F, false)).c("bread"));
+        a(298, "leather_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.LEATHER, 0, 0)).c("helmetCloth"));
+        a(299, "leather_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.LEATHER, 0, 1)).c("chestplateCloth"));
+        a(300, "leather_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.LEATHER, 0, 2)).c("leggingsCloth"));
+        a(301, "leather_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.LEATHER, 0, 3)).c("bootsCloth"));
+        a(302, "chainmail_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.CHAIN, 1, 0)).c("helmetChain"));
+        a(303, "chainmail_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.CHAIN, 1, 1)).c("chestplateChain"));
+        a(304, "chainmail_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.CHAIN, 1, 2)).c("leggingsChain"));
+        a(305, "chainmail_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.CHAIN, 1, 3)).c("bootsChain"));
+        a(306, "iron_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.IRON, 2, 0)).c("helmetIron"));
+        a(307, "iron_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.IRON, 2, 1)).c("chestplateIron"));
+        a(308, "iron_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.IRON, 2, 2)).c("leggingsIron"));
+        a(309, "iron_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.IRON, 2, 3)).c("bootsIron"));
+        a(310, "diamond_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.DIAMOND, 3, 0)).c("helmetDiamond"));
+        a(311, "diamond_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.DIAMOND, 3, 1)).c("chestplateDiamond"));
+        a(312, "diamond_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.DIAMOND, 3, 2)).c("leggingsDiamond"));
+        a(313, "diamond_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.DIAMOND, 3, 3)).c("bootsDiamond"));
+        a(314, "golden_helmet", (new ItemArmor(ItemArmor.EnumArmorMaterial.GOLD, 4, 0)).c("helmetGold"));
+        a(315, "golden_chestplate", (new ItemArmor(ItemArmor.EnumArmorMaterial.GOLD, 4, 1)).c("chestplateGold"));
+        a(316, "golden_leggings", (new ItemArmor(ItemArmor.EnumArmorMaterial.GOLD, 4, 2)).c("leggingsGold"));
+        a(317, "golden_boots", (new ItemArmor(ItemArmor.EnumArmorMaterial.GOLD, 4, 3)).c("bootsGold"));
+        a(318, "flint", (new Item()).c("flint").a(CreativeModeTab.l));
+        a(319, "porkchop", (new ItemFood(3, 0.3F, true)).c("porkchopRaw"));
+        a(320, "cooked_porkchop", (new ItemFood(8, 0.8F, true)).c("porkchopCooked"));
+        a(321, "painting", (new ItemHanging(EntityPainting.class)).c("painting"));
+        a(322, "golden_apple", (new ItemGoldenApple(4, 1.2F, false)).h().a(MobEffectList.REGENERATION.id, 5, 1, 1.0F).c("appleGold"));
+        a(323, "sign", (new ItemSign()).c("sign"));
+        a(324, "wooden_door", (new ItemDoor(Blocks.WOODEN_DOOR)).c("doorOak"));
+        Item item = (new ItemBucket(Blocks.AIR)).c("bucket").c(16);
+
+        a(325, "bucket", item);
+        a(326, "water_bucket", (new ItemBucket(Blocks.FLOWING_WATER)).c("bucketWater").c(item));
+        a(327, "lava_bucket", (new ItemBucket(Blocks.FLOWING_LAVA)).c("bucketLava").c(item));
+        a(328, "minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.RIDEABLE)).c("minecart"));
+        a(329, "saddle", (new ItemSaddle()).c("saddle"));
+        a(330, "iron_door", (new ItemDoor(Blocks.IRON_DOOR)).c("doorIron"));
+        a(331, "redstone", (new ItemRedstone()).c("redstone").e(PotionBrewer.i));
+        a(332, "snowball", (new ItemSnowball()).c("snowball"));
+        a(333, "boat", (new ItemBoat()).c("boat"));
+        a(334, "leather", (new Item()).c("leather").a(CreativeModeTab.l));
+        a(335, "milk_bucket", (new ItemMilkBucket()).c("milk").c(item));
+        a(336, "brick", (new Item()).c("brick").a(CreativeModeTab.l));
+        a(337, "clay_ball", (new Item()).c("clay").a(CreativeModeTab.l));
+        a(338, "reeds", (new ItemReed(Blocks.REEDS)).c("reeds").a(CreativeModeTab.l));
+        a(339, "paper", (new Item()).c("paper").a(CreativeModeTab.f));
+        a(340, "book", (new ItemBook()).c("book").a(CreativeModeTab.f));
+        a(341, "slime_ball", (new Item()).c("slimeball").a(CreativeModeTab.f));
+        a(342, "chest_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.CHEST)).c("minecartChest"));
+        a(343, "furnace_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.FURNACE)).c("minecartFurnace"));
+        a(344, "egg", (new ItemEgg()).c("egg"));
+        a(345, "compass", (new Item()).c("compass").a(CreativeModeTab.i));
+        a(346, "fishing_rod", (new ItemFishingRod()).c("fishingRod"));
+        a(347, "clock", (new Item()).c("clock").a(CreativeModeTab.i));
+        a(348, "glowstone_dust", (new Item()).c("yellowDust").e(PotionBrewer.j).a(CreativeModeTab.l));
+        a(349, "fish", (new ItemFish(false)).c("fish").a(true));
+        a(350, "cooked_fish", (new ItemFish(true)).c("fish").a(true));
+        a(351, "dye", (new ItemDye()).c("dyePowder"));
+        a(352, "bone", (new Item()).c("bone").n().a(CreativeModeTab.f));
+        a(353, "sugar", (new Item()).c("sugar").e(PotionBrewer.b).a(CreativeModeTab.l));
+        a(354, "cake", (new ItemReed(Blocks.CAKE)).c(1).c("cake").a(CreativeModeTab.h));
+        a(355, "bed", (new ItemBed()).c(1).c("bed"));
+        a(356, "repeater", (new ItemReed(Blocks.UNPOWERED_REPEATER)).c("diode").a(CreativeModeTab.d));
+        a(357, "cookie", (new ItemFood(2, 0.1F, false)).c("cookie"));
+        a(358, "filled_map", (new ItemWorldMap()).c("map"));
+        a(359, "shears", (new ItemShears()).c("shears"));
+        a(360, "melon", (new ItemFood(2, 0.3F, false)).c("melon"));
+        a(361, "pumpkin_seeds", (new ItemSeeds(Blocks.PUMPKIN_STEM, Blocks.FARMLAND)).c("seeds_pumpkin"));
+        a(362, "melon_seeds", (new ItemSeeds(Blocks.MELON_STEM, Blocks.FARMLAND)).c("seeds_melon"));
+        a(363, "beef", (new ItemFood(3, 0.3F, true)).c("beefRaw"));
+        a(364, "cooked_beef", (new ItemFood(8, 0.8F, true)).c("beefCooked"));
+        a(365, "chicken", (new ItemFood(2, 0.3F, true)).a(MobEffectList.HUNGER.id, 30, 0, 0.3F).c("chickenRaw"));
+        a(366, "cooked_chicken", (new ItemFood(6, 0.6F, true)).c("chickenCooked"));
+        a(367, "rotten_flesh", (new ItemFood(4, 0.1F, true)).a(MobEffectList.HUNGER.id, 30, 0, 0.8F).c("rottenFlesh"));
+        a(368, "ender_pearl", (new ItemEnderPearl()).c("enderPearl"));
+        a(369, "blaze_rod", (new Item()).c("blazeRod").a(CreativeModeTab.l).n());
+        a(370, "ghast_tear", (new Item()).c("ghastTear").e(PotionBrewer.c).a(CreativeModeTab.k));
+        a(371, "gold_nugget", (new Item()).c("goldNugget").a(CreativeModeTab.l));
+        a(372, "nether_wart", (new ItemSeeds(Blocks.NETHER_WART, Blocks.SOUL_SAND)).c("netherStalkSeeds").e("+4"));
+        a(373, "potion", (new ItemPotion()).c("potion"));
+        a(374, "glass_bottle", (new ItemGlassBottle()).c("glassBottle"));
+        a(375, "spider_eye", (new ItemFood(2, 0.8F, false)).a(MobEffectList.POISON.id, 5, 0, 1.0F).c("spiderEye").e(PotionBrewer.d));
+        a(376, "fermented_spider_eye", (new Item()).c("fermentedSpiderEye").e(PotionBrewer.e).a(CreativeModeTab.k));
+        a(377, "blaze_powder", (new Item()).c("blazePowder").e(PotionBrewer.g).a(CreativeModeTab.k));
+        a(378, "magma_cream", (new Item()).c("magmaCream").e(PotionBrewer.h).a(CreativeModeTab.k));
+        a(379, "brewing_stand", (new ItemReed(Blocks.BREWING_STAND)).c("brewingStand").a(CreativeModeTab.k));
+        a(380, "cauldron", (new ItemReed(Blocks.cauldron)).c("cauldron").a(CreativeModeTab.k));
+        a(381, "ender_eye", (new ItemEnderEye()).c("eyeOfEnder"));
+        a(382, "speckled_melon", (new Item()).c("speckledMelon").e(PotionBrewer.f).a(CreativeModeTab.k));
+        a(383, "spawn_egg", (new ItemMonsterEgg()).c("monsterPlacer"));
+        a(384, "experience_bottle", (new ItemExpBottle()).c("expBottle"));
+        a(385, "fire_charge", (new ItemFireball()).c("fireball"));
+        a(386, "writable_book", (new ItemBookAndQuill()).c("writingBook").a(CreativeModeTab.f));
+        a(387, "written_book", (new ItemWrittenBook()).c("writtenBook").c(16));
+        a(388, "emerald", (new Item()).c("emerald").a(CreativeModeTab.l));
+        a(389, "item_frame", (new ItemHanging(EntityItemFrame.class)).c("frame"));
+        a(390, "flower_pot", (new ItemReed(Blocks.FLOWER_POT)).c("flowerPot").a(CreativeModeTab.c));
+        a(391, "carrot", (new ItemSeedFood(3, 0.6F, Blocks.CARROTS, Blocks.FARMLAND)).c("carrots"));
+        a(392, "potato", (new ItemSeedFood(1, 0.3F, Blocks.POTATOES, Blocks.FARMLAND)).c("potato"));
+        a(393, "baked_potato", (new ItemFood(5, 0.6F, false)).c("potatoBaked"));
+        a(394, "poisonous_potato", (new ItemFood(2, 0.3F, false)).a(MobEffectList.POISON.id, 5, 0, 0.6F).c("potatoPoisonous"));
+        a(395, "map", (new ItemMapEmpty()).c("emptyMap"));
+        a(396, "golden_carrot", (new ItemFood(6, 1.2F, false)).c("carrotGolden").e(PotionBrewer.l).a(CreativeModeTab.k));
+        a(397, "skull", (new ItemSkull()).c("skull"));
+        a(398, "carrot_on_a_stick", (new ItemCarrotStick()).c("carrotOnAStick"));
+        a(399, "nether_star", (new ItemNetherStar()).c("netherStar").a(CreativeModeTab.l));
+        a(400, "pumpkin_pie", (new ItemFood(8, 0.3F, false)).c("pumpkinPie").a(CreativeModeTab.h));
+        a(401, "fireworks", (new ItemFireworks()).c("fireworks"));
+        a(402, "firework_charge", (new ItemFireworksCharge()).c("fireworksCharge").a(CreativeModeTab.f));
+        a(403, "enchanted_book", (new ItemEnchantedBook()).c(1).c("enchantedBook"));
+        a(404, "comparator", (new ItemReed(Blocks.UNPOWERED_COMPARATOR)).c("comparator").a(CreativeModeTab.d));
+        a(405, "netherbrick", (new Item()).c("netherbrick").a(CreativeModeTab.l));
+        a(406, "quartz", (new Item()).c("netherquartz").a(CreativeModeTab.l));
+        a(407, "tnt_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.TNT)).c("minecartTnt"));
+        a(408, "hopper_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.HOPPER)).c("minecartHopper"));
+        a(409, "prismarine_shard", (new Item()).c("prismarineShard").a(CreativeModeTab.l));
+        a(410, "prismarine_crystals", (new Item()).c("prismarineCrystals").a(CreativeModeTab.l));
+        a(411, "rabbit", (new ItemFood(3, 0.3F, true)).c("rabbitRaw"));
+        a(412, "cooked_rabbit", (new ItemFood(5, 0.6F, true)).c("rabbitCooked"));
+        a(413, "rabbit_stew", (new ItemSoup(10)).c("rabbitStew"));
+        a(414, "rabbit_foot", (new Item()).c("rabbitFoot").e(PotionBrewer.n).a(CreativeModeTab.k));
+        a(415, "rabbit_hide", (new Item()).c("rabbitHide").a(CreativeModeTab.l));
+        a(416, "armor_stand", (new ItemArmorStand()).c("armorStand").c(16));
+        a(417, "iron_horse_armor", (new Item()).c("horsearmormetal").c(1).a(CreativeModeTab.f));
+        a(418, "golden_horse_armor", (new Item()).c("horsearmorgold").c(1).a(CreativeModeTab.f));
+        a(419, "diamond_horse_armor", (new Item()).c("horsearmordiamond").c(1).a(CreativeModeTab.f));
+        a(420, "lead", (new ItemLeash()).c("leash"));
+        a(421, "name_tag", (new ItemNameTag()).c("nameTag"));
+        a(422, "command_block_minecart", (new ItemMinecart(EntityMinecartAbstract.EnumMinecartType.COMMAND_BLOCK)).c("minecartCommandBlock").a((CreativeModeTab) null));
+        a(423, "mutton", (new ItemFood(2, 0.3F, true)).c("muttonRaw"));
+        a(424, "cooked_mutton", (new ItemFood(6, 0.8F, true)).c("muttonCooked"));
+        a(425, "banner", (new ItemBanner()).b("banner"));
+        a(427, "spruce_door", (new ItemDoor(Blocks.SPRUCE_DOOR)).c("doorSpruce"));
+        a(428, "birch_door", (new ItemDoor(Blocks.BIRCH_DOOR)).c("doorBirch"));
+        a(429, "jungle_door", (new ItemDoor(Blocks.JUNGLE_DOOR)).c("doorJungle"));
+        a(430, "acacia_door", (new ItemDoor(Blocks.ACACIA_DOOR)).c("doorAcacia"));
+        a(431, "dark_oak_door", (new ItemDoor(Blocks.DARK_OAK_DOOR)).c("doorDarkOak"));
+        a(2256, "record_13", (new ItemRecord("13")).c("record"));
+        a(2257, "record_cat", (new ItemRecord("cat")).c("record"));
+        a(2258, "record_blocks", (new ItemRecord("blocks")).c("record"));
+        a(2259, "record_chirp", (new ItemRecord("chirp")).c("record"));
+        a(2260, "record_far", (new ItemRecord("far")).c("record"));
+        a(2261, "record_mall", (new ItemRecord("mall")).c("record"));
+        a(2262, "record_mellohi", (new ItemRecord("mellohi")).c("record"));
+        a(2263, "record_stal", (new ItemRecord("stal")).c("record"));
+        a(2264, "record_strad", (new ItemRecord("strad")).c("record"));
+        a(2265, "record_ward", (new ItemRecord("ward")).c("record"));
+        a(2266, "record_11", (new ItemRecord("11")).c("record"));
+        a(2267, "record_wait", (new ItemRecord("wait")).c("record"));
+    }
+
+    private static void c(Block block) {
+        a(block, (Item) (new ItemBlock(block)));
+    }
+
+    protected static void a(Block block, Item item) {
+        a(Block.getId(block), (MinecraftKey) Block.REGISTRY.c(block), item);
+        Item.a.put(block, item);
+    }
+
+    private static void a(int i, String s, Item item) {
+        a(i, new MinecraftKey(s), item);
+    }
+
+    private static void a(int i, MinecraftKey minecraftkey, Item item) {
+        Item.REGISTRY.a(i, minecraftkey, item);
+    }
+
+    public static enum EnumToolMaterial {
+
+        WOOD(0, 59, 2.0F, 0.0F, 15), STONE(1, 131, 4.0F, 1.0F, 5), IRON(2, 250, 6.0F, 2.0F, 14), EMERALD(3, 1561, 8.0F, 3.0F, 10), GOLD(0, 32, 12.0F, 0.0F, 22);
+
+        private final int f;
+        private final int g;
+        private final float h;
+        private final float i;
+        private final int j;
+
+        private EnumToolMaterial(int i, int j, float f, float f1, int k) {
+            this.f = i;
+            this.g = j;
+            this.h = f;
+            this.i = f1;
+            this.j = k;
+        }
+
+        public int a() {
+            return this.g;
+        }
+
+        public float b() {
+            return this.h;
+        }
+
+        public float c() {
+            return this.i;
+        }
+
+        public int d() {
+            return this.f;
+        }
+
+        public int e() {
+            return this.j;
+        }
+
+        public Item f() {
+            return this == Item.EnumToolMaterial.WOOD ? Item.getItemOf(Blocks.PLANKS) : (this == Item.EnumToolMaterial.STONE ? Item.getItemOf(Blocks.COBBLESTONE) : (this == Item.EnumToolMaterial.GOLD ? Items.GOLD_INGOT : (this == Item.EnumToolMaterial.IRON ? Items.IRON_INGOT : (this == Item.EnumToolMaterial.EMERALD ? Items.DIAMOND : null))));
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemArmorStand.java b/src/main/java/net/minecraft/server/ItemArmorStand.java
new file mode 100644
index 000000000..d8de61902
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemArmorStand.java
@@ -0,0 +1,78 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class ItemArmorStand extends Item {
+
+    public ItemArmorStand() {
+        this.a(CreativeModeTab.c);
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (enumdirection == EnumDirection.DOWN) {
+            return false;
+        } else {
+            boolean flag = world.getType(blockposition).getBlock().a(world, blockposition);
+            BlockPosition blockposition1 = flag ? blockposition : blockposition.shift(enumdirection);
+
+            if (!entityhuman.a(blockposition1, enumdirection, itemstack)) {
+                return false;
+            } else {
+                BlockPosition blockposition2 = blockposition1.up();
+                boolean flag1 = !world.isEmpty(blockposition1) && !world.getType(blockposition1).getBlock().a(world, blockposition1);
+
+                flag1 |= !world.isEmpty(blockposition2) && !world.getType(blockposition2).getBlock().a(world, blockposition2);
+                if (flag1) {
+                    return false;
+                } else {
+                    double d0 = (double) blockposition1.getX();
+                    double d1 = (double) blockposition1.getY();
+                    double d2 = (double) blockposition1.getZ();
+                    List list = world.getEntities((Entity) null, AxisAlignedBB.a(d0, d1, d2, d0 + 1.0D, d1 + 2.0D, d2 + 1.0D));
+
+                    if (list.size() > 0) {
+                        return false;
+                    } else {
+                        if (!world.isClientSide) {
+                            world.setAir(blockposition1);
+                            world.setAir(blockposition2);
+                            EntityArmorStand entityarmorstand = new EntityArmorStand(world, d0 + 0.5D, d1, d2 + 0.5D);
+                            float f3 = (float) MathHelper.d((MathHelper.g(entityhuman.yaw - 180.0F) + 22.5F) / 45.0F) * 45.0F;
+
+                            entityarmorstand.setPositionRotation(d0 + 0.5D, d1, d2 + 0.5D, f3, 0.0F);
+                            this.a(entityarmorstand, world.random);
+                            NBTTagCompound nbttagcompound = itemstack.getTag();
+
+                            if (nbttagcompound != null && nbttagcompound.hasKeyOfType("EntityTag", 10)) {
+                                NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                                entityarmorstand.d(nbttagcompound1);
+                                nbttagcompound1.a(nbttagcompound.getCompound("EntityTag"));
+                                entityarmorstand.f(nbttagcompound1);
+                            }
+
+                            world.addEntity(entityarmorstand);
+                        }
+
+                        --itemstack.count;
+                        return true;
+                    }
+                }
+            }
+        }
+    }
+
+    private void a(EntityArmorStand entityarmorstand, Random random) {
+        Vector3f vector3f = entityarmorstand.t();
+        float f = random.nextFloat() * 5.0F;
+        float f1 = random.nextFloat() * 20.0F - 10.0F;
+        Vector3f vector3f1 = new Vector3f(vector3f.getX() + f, vector3f.getY() + f1, vector3f.getZ());
+
+        entityarmorstand.setHeadPose(vector3f1);
+        vector3f = entityarmorstand.u();
+        f = random.nextFloat() * 10.0F - 5.0F;
+        vector3f1 = new Vector3f(vector3f.getX(), vector3f.getY() + f, vector3f.getZ());
+        entityarmorstand.setBodyPose(vector3f1);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemBookAndQuill.java b/src/main/java/net/minecraft/server/ItemBookAndQuill.java
new file mode 100644
index 000000000..a34550702
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemBookAndQuill.java
@@ -0,0 +1,38 @@
+package net.minecraft.server;
+
+public class ItemBookAndQuill extends Item {
+
+    public ItemBookAndQuill() {
+        this.c(1);
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        entityhuman.openBook(itemstack);
+        entityhuman.b(StatisticList.USE_ITEM_COUNT[Item.getId(this)]);
+        return itemstack;
+    }
+
+    public static boolean b(NBTTagCompound nbttagcompound) {
+        if (nbttagcompound == null) {
+            return false;
+        } else if (!nbttagcompound.hasKeyOfType("pages", 9)) {
+            return false;
+        } else {
+            NBTTagList nbttaglist = nbttagcompound.getList("pages", 8);
+
+            for (int i = 0; i < nbttaglist.size(); ++i) {
+                String s = nbttaglist.getString(i);
+
+                if (s == null) {
+                    return false;
+                }
+
+                if (s.length() > 32767) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemFireworks.java b/src/main/java/net/minecraft/server/ItemFireworks.java
new file mode 100644
index 000000000..e193a077b
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemFireworks.java
@@ -0,0 +1,21 @@
+package net.minecraft.server;
+
+public class ItemFireworks extends Item {
+
+    public ItemFireworks() {}
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (!world.isClientSide) {
+            EntityFireworks entityfireworks = new EntityFireworks(world, (double) ((float) blockposition.getX() + f), (double) ((float) blockposition.getY() + f1), (double) ((float) blockposition.getZ() + f2), itemstack);
+
+            world.addEntity(entityfireworks);
+            if (!entityhuman.abilities.canInstantlyBuild) {
+                --itemstack.count;
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemSeedFood.java b/src/main/java/net/minecraft/server/ItemSeedFood.java
new file mode 100644
index 000000000..3229add95
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemSeedFood.java
@@ -0,0 +1,27 @@
+package net.minecraft.server;
+
+public class ItemSeedFood extends ItemFood {
+
+    private Block b;
+    private Block c;
+
+    public ItemSeedFood(int i, float f, Block block, Block block1) {
+        super(i, f, false);
+        this.b = block;
+        this.c = block1;
+    }
+
+    public boolean interactWith(ItemStack itemstack, EntityHuman entityhuman, World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (enumdirection != EnumDirection.UP) {
+            return false;
+        } else if (!entityhuman.a(blockposition.shift(enumdirection), enumdirection, itemstack)) {
+            return false;
+        } else if (world.getType(blockposition).getBlock() == this.c && world.isEmpty(blockposition.up())) {
+            world.setTypeUpdate(blockposition.up(), this.b.getBlockData());
+            --itemstack.count;
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemWrittenBook.java b/src/main/java/net/minecraft/server/ItemWrittenBook.java
new file mode 100644
index 000000000..d17904972
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ItemWrittenBook.java
@@ -0,0 +1,84 @@
+package net.minecraft.server;
+
+public class ItemWrittenBook extends Item {
+
+    public ItemWrittenBook() {
+        this.c(1);
+    }
+
+    public static boolean b(NBTTagCompound nbttagcompound) {
+        if (!ItemBookAndQuill.b(nbttagcompound)) {
+            return false;
+        } else if (!nbttagcompound.hasKeyOfType("title", 8)) {
+            return false;
+        } else {
+            String s = nbttagcompound.getString("title");
+
+            return s != null && s.length() <= 32 ? nbttagcompound.hasKeyOfType("author", 8) : false;
+        }
+    }
+
+    public static int h(ItemStack itemstack) {
+        return itemstack.getTag().getInt("generation");
+    }
+
+    public String a(ItemStack itemstack) {
+        if (itemstack.hasTag()) {
+            NBTTagCompound nbttagcompound = itemstack.getTag();
+            String s = nbttagcompound.getString("title");
+
+            if (!UtilColor.b(s)) {
+                return s;
+            }
+        }
+
+        return super.a(itemstack);
+    }
+
+    public ItemStack a(ItemStack itemstack, World world, EntityHuman entityhuman) {
+        if (!world.isClientSide) {
+            this.a(itemstack, entityhuman);
+        }
+
+        entityhuman.openBook(itemstack);
+        entityhuman.b(StatisticList.USE_ITEM_COUNT[Item.getId(this)]);
+        return itemstack;
+    }
+
+    private void a(ItemStack itemstack, EntityHuman entityhuman) {
+        if (itemstack != null && itemstack.getTag() != null) {
+            NBTTagCompound nbttagcompound = itemstack.getTag();
+
+            if (!nbttagcompound.getBoolean("resolved")) {
+                nbttagcompound.setBoolean("resolved", true);
+                if (b(nbttagcompound)) {
+                    NBTTagList nbttaglist = nbttagcompound.getList("pages", 8);
+
+                    for (int i = 0; i < nbttaglist.size(); ++i) {
+                        String s = nbttaglist.getString(i);
+
+                        Object object;
+
+                        try {
+                            IChatBaseComponent ichatbasecomponent = IChatBaseComponent.ChatSerializer.a(s);
+
+                            object = ChatComponentUtils.filterForDisplay(entityhuman, ichatbasecomponent, entityhuman);
+                        } catch (Exception exception) {
+                            object = new ChatComponentText(s);
+                        }
+
+                        nbttaglist.a(i, new NBTTagString(IChatBaseComponent.ChatSerializer.a((IChatBaseComponent) object)));
+                    }
+
+                    nbttagcompound.set("pages", nbttaglist);
+                    if (entityhuman instanceof EntityPlayer && entityhuman.bZ() == itemstack) {
+                        Slot slot = entityhuman.activeContainer.getSlot(entityhuman.inventory, entityhuman.inventory.itemInHandIndex);
+
+                        ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutSetSlot(0, slot.rawSlotIndex, itemstack));
+                    }
+
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
new file mode 100644
index 000000000..22d7c2ab3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -0,0 +1,364 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+import java.util.concurrent.Callable;
+
+public class NBTTagCompound extends NBTBase {
+
+    private Map<String, NBTBase> map = Maps.newHashMap();
+
+    public NBTTagCompound() {}
+
+    void write(DataOutput dataoutput) throws IOException {
+        Iterator iterator = this.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            NBTBase nbtbase = (NBTBase) this.map.get(s);
+
+            a(s, nbtbase, dataoutput);
+        }
+
+        dataoutput.writeByte(0);
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        nbtreadlimiter.a(384L);
+        if (i > 512) {
+            throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+        } else {
+            this.map.clear();
+
+            byte b0;
+
+            while ((b0 = a(datainput, nbtreadlimiter)) != 0) {
+                String s = b(datainput, nbtreadlimiter);
+
+                nbtreadlimiter.a((long) (224 + 16 * s.length()));
+                NBTBase nbtbase = a(b0, s, datainput, i + 1, nbtreadlimiter);
+
+                if (this.map.put(s, nbtbase) != null) {
+                    nbtreadlimiter.a(288L);
+                }
+            }
+
+        }
+    }
+
+    public Set<String> c() {
+        return this.map.keySet();
+    }
+
+    public byte getTypeId() {
+        return (byte) 10;
+    }
+
+    public void set(String s, NBTBase nbtbase) {
+        this.map.put(s, nbtbase);
+    }
+
+    public void setByte(String s, byte b0) {
+        this.map.put(s, new NBTTagByte(b0));
+    }
+
+    public void setShort(String s, short short0) {
+        this.map.put(s, new NBTTagShort(short0));
+    }
+
+    public void setInt(String s, int i) {
+        this.map.put(s, new NBTTagInt(i));
+    }
+
+    public void setLong(String s, long i) {
+        this.map.put(s, new NBTTagLong(i));
+    }
+
+    public void setFloat(String s, float f) {
+        this.map.put(s, new NBTTagFloat(f));
+    }
+
+    public void setDouble(String s, double d0) {
+        this.map.put(s, new NBTTagDouble(d0));
+    }
+
+    public void setString(String s, String s1) {
+        this.map.put(s, new NBTTagString(s1));
+    }
+
+    public void setByteArray(String s, byte[] abyte) {
+        this.map.put(s, new NBTTagByteArray(abyte));
+    }
+
+    public void setIntArray(String s, int[] aint) {
+        this.map.put(s, new NBTTagIntArray(aint));
+    }
+
+    public void setBoolean(String s, boolean flag) {
+        this.setByte(s, (byte) (flag ? 1 : 0));
+    }
+
+    public NBTBase get(String s) {
+        return (NBTBase) this.map.get(s);
+    }
+
+    public byte b(String s) {
+        NBTBase nbtbase = (NBTBase) this.map.get(s);
+
+        return nbtbase != null ? nbtbase.getTypeId() : 0;
+    }
+
+    public boolean hasKey(String s) {
+        return this.map.containsKey(s);
+    }
+
+    public boolean hasKeyOfType(String s, int i) {
+        byte b0 = this.b(s);
+
+        if (b0 == i) {
+            return true;
+        } else if (i != 99) {
+            if (b0 > 0) {
+                ;
+            }
+
+            return false;
+        } else {
+            return b0 == 1 || b0 == 2 || b0 == 3 || b0 == 4 || b0 == 5 || b0 == 6;
+        }
+    }
+
+    public byte getByte(String s) {
+        try {
+            return !this.hasKeyOfType(s, 99) ? 0 : ((NBTBase.NBTNumber) this.map.get(s)).f();
+        } catch (ClassCastException classcastexception) {
+            return (byte) 0;
+        }
+    }
+
+    public short getShort(String s) {
+        try {
+            return !this.hasKeyOfType(s, 99) ? 0 : ((NBTBase.NBTNumber) this.map.get(s)).e();
+        } catch (ClassCastException classcastexception) {
+            return (short) 0;
+        }
+    }
+
+    public int getInt(String s) {
+        try {
+            return !this.hasKeyOfType(s, 99) ? 0 : ((NBTBase.NBTNumber) this.map.get(s)).d();
+        } catch (ClassCastException classcastexception) {
+            return 0;
+        }
+    }
+
+    public long getLong(String s) {
+        try {
+            return !this.hasKeyOfType(s, 99) ? 0L : ((NBTBase.NBTNumber) this.map.get(s)).c();
+        } catch (ClassCastException classcastexception) {
+            return 0L;
+        }
+    }
+
+    public float getFloat(String s) {
+        try {
+            return !this.hasKeyOfType(s, 99) ? 0.0F : ((NBTBase.NBTNumber) this.map.get(s)).h();
+        } catch (ClassCastException classcastexception) {
+            return 0.0F;
+        }
+    }
+
+    public double getDouble(String s) {
+        try {
+            return !this.hasKeyOfType(s, 99) ? 0.0D : ((NBTBase.NBTNumber) this.map.get(s)).g();
+        } catch (ClassCastException classcastexception) {
+            return 0.0D;
+        }
+    }
+
+    public String getString(String s) {
+        try {
+            return !this.hasKeyOfType(s, 8) ? "" : ((NBTBase) this.map.get(s)).a_();
+        } catch (ClassCastException classcastexception) {
+            return "";
+        }
+    }
+
+    public byte[] getByteArray(String s) {
+        try {
+            return !this.hasKeyOfType(s, 7) ? new byte[0] : ((NBTTagByteArray) this.map.get(s)).c();
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, 7, classcastexception));
+        }
+    }
+
+    public int[] getIntArray(String s) {
+        try {
+            return !this.hasKeyOfType(s, 11) ? new int[0] : ((NBTTagIntArray) this.map.get(s)).c();
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, 11, classcastexception));
+        }
+    }
+
+    public NBTTagCompound getCompound(String s) {
+        try {
+            return !this.hasKeyOfType(s, 10) ? new NBTTagCompound() : (NBTTagCompound) this.map.get(s);
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, 10, classcastexception));
+        }
+    }
+
+    public NBTTagList getList(String s, int i) {
+        try {
+            if (this.b(s) != 9) {
+                return new NBTTagList();
+            } else {
+                NBTTagList nbttaglist = (NBTTagList) this.map.get(s);
+
+                return nbttaglist.size() > 0 && nbttaglist.f() != i ? new NBTTagList() : nbttaglist;
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, 9, classcastexception));
+        }
+    }
+
+    public boolean getBoolean(String s) {
+        return this.getByte(s) != 0;
+    }
+
+    public void remove(String s) {
+        this.map.remove(s);
+    }
+
+    public String toString() {
+        StringBuilder stringbuilder = new StringBuilder("{");
+
+        Entry entry;
+
+        for (Iterator iterator = this.map.entrySet().iterator(); iterator.hasNext(); stringbuilder.append((String) entry.getKey()).append(':').append(entry.getValue())) {
+            entry = (Entry) iterator.next();
+            if (stringbuilder.length() != 1) {
+                stringbuilder.append(',');
+            }
+        }
+
+        return stringbuilder.append('}').toString();
+    }
+
+    public boolean isEmpty() {
+        return this.map.isEmpty();
+    }
+
+    private CrashReport a(final String s, final int i, ClassCastException classcastexception) {
+        CrashReport crashreport = CrashReport.a(classcastexception, "Reading NBT data");
+        CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Corrupt NBT tag", 1);
+
+        crashreportsystemdetails.a("Tag type found", new Callable() {
+            public String a() throws Exception {
+                return NBTBase.a[((NBTBase) NBTTagCompound.this.map.get(s)).getTypeId()];
+            }
+
+            public Object call() throws Exception {
+                return this.a();
+            }
+        });
+        crashreportsystemdetails.a("Tag type expected", new Callable() {
+            public String a() throws Exception {
+                return NBTBase.a[i];
+            }
+
+            public Object call() throws Exception {
+                return this.a();
+            }
+        });
+        crashreportsystemdetails.a("Tag name", (Object) s);
+        return crashreport;
+    }
+
+    public NBTBase clone() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        Iterator iterator = this.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+
+            nbttagcompound.set(s, ((NBTBase) this.map.get(s)).clone());
+        }
+
+        return nbttagcompound;
+    }
+
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagCompound nbttagcompound = (NBTTagCompound) object;
+
+            return this.map.entrySet().equals(nbttagcompound.map.entrySet());
+        } else {
+            return false;
+        }
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ this.map.hashCode();
+    }
+
+    private static void a(String s, NBTBase nbtbase, DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(nbtbase.getTypeId());
+        if (nbtbase.getTypeId() != 0) {
+            dataoutput.writeUTF(s);
+            nbtbase.write(dataoutput);
+        }
+    }
+
+    private static byte a(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
+        return datainput.readByte();
+    }
+
+    private static String b(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
+        return datainput.readUTF();
+    }
+
+    static NBTBase a(byte b0, String s, DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        NBTBase nbtbase = NBTBase.createTag(b0);
+
+        try {
+            nbtbase.load(datainput, i, nbtreadlimiter);
+            return nbtbase;
+        } catch (IOException ioexception) {
+            CrashReport crashreport = CrashReport.a(ioexception, "Loading NBT data");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("NBT Tag");
+
+            crashreportsystemdetails.a("Tag name", (Object) s);
+            crashreportsystemdetails.a("Tag type", (Object) Byte.valueOf(b0));
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        Iterator iterator = nbttagcompound.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            NBTBase nbtbase = (NBTBase) nbttagcompound.map.get(s);
+
+            if (nbtbase.getTypeId() == 10) {
+                if (this.hasKeyOfType(s, 10)) {
+                    NBTTagCompound nbttagcompound1 = this.getCompound(s);
+
+                    nbttagcompound1.a((NBTTagCompound) nbtbase);
+                } else {
+                    this.set(s, nbtbase.clone());
+                }
+            } else {
+                this.set(s, nbtbase.clone());
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/OpList.java b/src/main/java/net/minecraft/server/OpList.java
new file mode 100644
index 000000000..26b4e44b0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/OpList.java
@@ -0,0 +1,60 @@
+package net.minecraft.server;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import java.io.File;
+import java.util.Iterator;
+
+public class OpList extends JsonList<GameProfile, OpListEntry> {
+
+    public OpList(File file) {
+        super(file);
+    }
+
+    protected JsonListEntry<GameProfile> a(JsonObject jsonobject) {
+        return new OpListEntry(jsonobject);
+    }
+
+    public String[] getEntries() {
+        String[] astring = new String[this.e().size()];
+        int i = 0;
+
+        OpListEntry oplistentry;
+
+        for (Iterator iterator = this.e().values().iterator(); iterator.hasNext(); astring[i++] = ((GameProfile) oplistentry.getKey()).getName()) {
+            oplistentry = (OpListEntry) iterator.next();
+        }
+
+        return astring;
+    }
+
+    public boolean b(GameProfile gameprofile) {
+        OpListEntry oplistentry = (OpListEntry) this.get(gameprofile);
+
+        return oplistentry != null ? oplistentry.b() : false;
+    }
+
+    protected String c(GameProfile gameprofile) {
+        return gameprofile.getId().toString();
+    }
+
+    public GameProfile a(String s) {
+        Iterator iterator = this.e().values().iterator();
+
+        OpListEntry oplistentry;
+
+        do {
+            if (!iterator.hasNext()) {
+                return null;
+            }
+
+            oplistentry = (OpListEntry) iterator.next();
+        } while (!s.equalsIgnoreCase(((GameProfile) oplistentry.getKey()).getName()));
+
+        return (GameProfile) oplistentry.getKey();
+    }
+
+    protected String a(GameProfile object) { // Blossom - decompile fix
+        return this.c((GameProfile) object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutBlockAction.java b/src/main/java/net/minecraft/server/PacketPlayOutBlockAction.java
new file mode 100644
index 000000000..cfb92ead8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutBlockAction.java
@@ -0,0 +1,39 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutBlockAction implements Packet<PacketListenerPlayOut> {
+
+    private BlockPosition a;
+    private int b;
+    private int c;
+    private Block d;
+
+    public PacketPlayOutBlockAction() {}
+
+    public PacketPlayOutBlockAction(BlockPosition blockposition, Block block, int i, int j) {
+        this.a = blockposition;
+        this.b = i;
+        this.c = j;
+        this.d = block;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c();
+        this.b = packetdataserializer.readUnsignedByte();
+        this.c = packetdataserializer.readUnsignedByte();
+        this.d = Block.getById(packetdataserializer.e() & 4095);
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.a);
+        packetdataserializer.writeByte(this.b);
+        packetdataserializer.writeByte(this.c);
+        packetdataserializer.b(Block.getId(this.d) & 4095);
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutBlockChange.java b/src/main/java/net/minecraft/server/PacketPlayOutBlockChange.java
new file mode 100644
index 000000000..fae8704b5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutBlockChange.java
@@ -0,0 +1,31 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+
+public class PacketPlayOutBlockChange implements Packet<PacketListenerPlayOut> {
+
+    private BlockPosition a;
+    public IBlockData block;
+
+    public PacketPlayOutBlockChange() {}
+
+    public PacketPlayOutBlockChange(World world, BlockPosition blockposition) {
+        this.a = blockposition;
+        this.block = world.getType(blockposition);
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.c();
+        this.block = (IBlockData) Block.d.a(packetdataserializer.e());
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+        packetdataserializer.a(this.a);
+        packetdataserializer.b(Block.d.b(this.block));
+    }
+
+    public void a(PacketListenerPlayOut packetlistenerplayout) {
+        packetlistenerplayout.a(this);
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/RegistryID.java b/src/main/java/net/minecraft/server/RegistryID.java
new file mode 100644
index 000000000..d9d458239
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegistryID.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicates;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.List;
+
+public class RegistryID<T> implements Registry<T> {
+
+    private final IdentityHashMap<T, Integer> a = new IdentityHashMap(512);
+    private final List<T> b = Lists.newArrayList();
+
+    public RegistryID() {}
+
+    public void a(T t0, int i) {
+        this.a.put(t0, Integer.valueOf(i));
+
+        while (this.b.size() <= i) {
+            this.b.add(null);
+        }
+
+        this.b.set(i, t0);
+    }
+
+    public int b(T t0) {
+        Integer integer = (Integer) this.a.get(t0);
+
+        return integer == null ? -1 : integer.intValue();
+    }
+
+    public final T a(int i) {
+        return i >= 0 && i < this.b.size() ? this.b.get(i) : null;
+    }
+
+    public Iterator<T> iterator() {
+        return Iterators.filter(this.b.iterator(), Predicates.notNull());
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityContainer.java b/src/main/java/net/minecraft/server/TileEntityContainer.java
new file mode 100644
index 000000000..209fe3bfe
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityContainer.java
@@ -0,0 +1,39 @@
+package net.minecraft.server;
+
+public abstract class TileEntityContainer extends TileEntity implements ITileEntityContainer, ITileInventory {
+
+    private ChestLock a;
+
+    public TileEntityContainer() {
+        this.a = ChestLock.a;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        super.a(nbttagcompound);
+        this.a = ChestLock.b(nbttagcompound);
+    }
+
+    public void b(NBTTagCompound nbttagcompound) {
+        super.b(nbttagcompound);
+        if (this.a != null) {
+            this.a.a(nbttagcompound);
+        }
+
+    }
+
+    public boolean r_() {
+        return this.a != null && !this.a.a();
+    }
+
+    public ChestLock i() {
+        return this.a;
+    }
+
+    public void a(ChestLock chestlock) {
+        this.a = chestlock;
+    }
+
+    public IChatBaseComponent getScoreboardDisplayName() {
+        return (IChatBaseComponent) (this.hasCustomName() ? new ChatComponentText(this.getName()) : new ChatMessage(this.getName(), new Object[0]));
+    }
+}
-- 
2.49.0

